OpenAI Codex v0.63.0 (research preview)
--------
workdir: /Users/jameswest/Desktop/nfl_predict
model: gpt-5.1-codex-max
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: none
reasoning summaries: auto
session id: 019abf84-2fd8-7052-84b8-ca247a4e4580
--------
user
Okay, great. Please work like an agent and implement the following plan in this repository.

    Here is the plan:

    <BEGIN_PLAN_START>
    Here’s a roadmap that a future agent (or you) could execute step‑by‑step. I’ll prioritize by impact, then drill into detailed steps, risks, and checks.

---

**Top‑Level Priorities**

- **Tier 1 (High impact, relatively contained):**
  - T1.1: Align `ps_*` train vs inference semantics and remove same‑game leakage.
  - T1.2: Fix classification pipelines to use probabilities end‑to‑end (availability, anytime TD).
  - T1.3: Deduplicate and simplify TD efficiency / anytime TD configs.

- **Tier 2 (Important but slightly more invasive):**
  - T2.1: Re‑design pre‑snap feature namespace (historical vs same‑game) and audit them out of downstream problems where unrealistic.
  - T2.2: Make pre‑snap tracking coverage explicit; treat missing data sensibly.
  - T2.3: Refine scripted touches / early‑game heuristics to better match real offensive design.

- **Tier 3 (Cleanup, observability, polish):**
  - T3.1: Prune legacy/unused model configs and modules.
  - T3.2: Add invariant tests and monitoring around feature parity and leakage.
  - T3.3: Document football‑mechanism assumptions and how they map into features.

Below, I’ll describe each “epic” with concrete implementation steps and pitfalls.

---

**Epic T1.1 – Align `ps_*` semantics & eliminate same‑game leakage**

**Goal:** Ensure any pre‑snap features used as inputs at training are built from the same type of information available at prediction time (historical tracking, injuries, odds), not realized same‑game outcomes. Same‑game `ps_*` stats become labels or diagnostic outputs, not features for upstream models.

**Design decision (choose one path, but plan supports both):**

- **Option A (Recommended):**  
  - `ps_game_*` = realized same‑game pre‑snap stats, used only as labels.
  - `ps_hist_*` = rolling historical estimates (what inference currently uses, e.g. `1g_ps_route_participation_pct_per_game`, `3g_*`).
  - Models that approximate “pre‑snap plan” train solely on `ps_hist_*` + contextual features, predicting `ps_game_*` as labels.
- **Option B:**  
  - Retain `ps_*` as historical by definition (rename current same‑game fields to something else and keep them out of features).

I’ll assume Option A for concreteness.

**Steps:**

1. **Audit where `ps_*` is computed and used**
   - Identify:
     - Where same‑game `ps_*` is created in `utils/feature/player_game_level.py` (e.g. `_compute_pre_snap_usage`, route participation, scripted touches).
     - Where rolling `ps_*` per‑game features are created in training (feature pipeline) and inference (`pipeline/predict.py → add_rolling_features` and renaming).
     - All problems referencing `ps_*` columns in `config/training.yaml` (`feature_prefixes_to_include`, `other_features_to_include`).
   - Deliverable: a short mapping doc listing:
     - `ps_game_*` columns (same‑game).
     - `ps_hist_*` columns (rolling historical).
     - Which problems currently use which.

2. **Introduce clear namespaces for pre‑snap metrics**
   - In the feature builders:
     - Rename same‑game pre‑snap columns to `ps_game_*` (e.g., `ps_route_participation_pct` → `ps_game_route_participation_pct`).
     - Ensure they are **never** used as features; mark them as labels or “diagnostic targets” in training config.
   - For historical/pre‑snap projections:
     - Ensure rolling per‑game features carry a separate prefix, e.g. `ps_hist_*` or `ps_roll_*`.  
       - Example: `1g_ps_route_participation_pct_per_game` → `ps_hist_route_participation_pct_1g`.
       - `3g_ps_route_participation_pct_per_game` → `ps_hist_route_participation_pct_3g`.
     - Update the renaming logic in prediction to **not** alias them to names that collide with same‑game stats.

3. **Refine model configs to use only historical pre‑snap inputs**
   - For `pre_snap_routes`, `pre_snap_scripted_touches`, and any upstream pre‑snap problems:
     - Change `feature_prefixes_to_include` to include `ps_hist_*` (and contextual stuff like `injury_`, `team_`, `odds_`, `defense_`).
     - Explicitly exclude `ps_game_*` and all other same‑game realized stats via `columns_to_discard`.
   - For downstream problems (usage, efficiency, anytime TDs):
     - Ensure no `ps_game_*` columns are present as features:
       - If they are, either:
         - Replace with `ps_hist_*` analogs, or
         - Drop them if there is no sensible historical proxy.

4. **Re‑wire the pre‑snap model stack**
   - Make the pipeline explicit:
     - Stage 1: Historical & context (`ps_hist_*`, injuries, odds, team tendencies) → predict `ps_game_*` labels (`routes`, `scripted_touches`, alignment).
     - Stage 2: Use predicted `ps_game_*` or their expectations as inputs into usage/efficiency models.
   - Concretely:
     - Modify `_inject_composed_features` in `pipeline/predict.py` to:
       - Take the predicted pre‑snap distributions (e.g. expected routes, expected scripted touches) and feed them into target/carry distribution models.
       - Avoid directly using realized same‑game stats (they won’t exist at inference anyway).

5. **Align training & prediction feature selection artifacts**
   - Regenerate and persist feature lists per problem after the namespace change.
   - Update prediction code to always:
     - Load the exact feature list saved during training.
     - Enforce that `ps_game_*` columns are **never required** as inputs to inference models (they may exist in data for diagnostics, but not in `X`).

6. **Add invariants / tests for leakage and parity**
   - Tests (or assertions) to add:
     - For each problem, assert that any column with suffix `_yards`, `_targets`, `_tds`, `ps_game_*` is never in the “input features” list.
     - For the set of features used in training vs prediction for a given problem:
       - They match exactly, or differences are explicitly enumerated (e.g., extra diagnostic columns that are ignored at inference).
     - A dedicated “no same‑game `ps_game_*` as feature” check in `tests/test_training_config_features.py` or equivalent.

**Risks / Pitfalls:**

- Removing strong same‑game `ps_*` inputs can **reduce short‑term model performance metrics** (AUC/R²) because you’re taking away label‑adjacent inputs. That’s expected and healthy.
- Renaming `ps_*` columns requires careful migration of:
  - Saved models.
  - Downstream reporting code and notebooks.
- Need to ensure no silent back‑compat fallbacks (e.g., try/except dropping missing columns) mask broken pipelines.

---

**Epic T1.2 – Fix classification pipeline & probability semantics**

**Goal:** Ensure all classification models (availability, anytime TD, and any others) are trained, stored, and used as probability estimators, not hard thresholds.

**Steps:**

1. **Inventory all classification‑type problems**
   - From `config/training.yaml`, identify problems with:
     - `problem_type: classification` or similar.
     - Binary labels (e.g., `availability_active`, `anytime_td`, maybe some injury/roster problems).
   - Document expected outputs (probabilities vs labels) for each.

2. **Standardize model saving/loading for classifiers**
   - Confirm how calibration is applied in training:
     - If you wrap base models with calibrators (e.g., Platt scaling, isotonic), ensure the wrapper is what gets saved.
   - Define a clear interface for loaded models:
     - All classification models must support `predict_proba(X)[:, 1]`.
   - If some models are stored without calibrator:
     - Either migrate to saving calibrated wrappers.
     - Or store metadata about calibration in the artifact and re‑apply on load.

3. **Refactor `_predict_for_problem` to use model metadata, not name heuristics**
   - Instead of `if "anytime_td" in problem_name: use predict_proba else predict`, do:
     - Load problem metadata (e.g. from config or a small manifest saved with the model) specifying:
       - `problem_type` (`classification`, `regression`).
       - `output_mode` (`probability`, `count`, etc.).
     - If `problem_type == "classification"`, always call `predict_proba`.
   - Ensure special cases (like multi‑class, if any) are handled explicitly.

4. **Update downstream usage of classification outputs**
   - For `availability_active`:
     - Treat `p_active = model.predict_proba(X)[:, 1]` as a probability.
     - Use `p_active` directly in expected value calculations (e.g., `expected_targets *= p_active`).
     - If you want a binary flag for some guardrails, derive it via thresholding (e.g., `p_active > 0.5`), but **keep both**.
   - For `anytime_td`:
     - Ensure chain uses `p_td` as a probability:
       - When combining with usage/efficiency models, keep the semantics clear: `expected_td = p_anytime_td` vs `expected_td_count` from Poisson approximations, etc.

5. **Guard against accidental integer clipping / casting**
   - Review any code where outputs are:
     - Cast to `int` or `round`ed prematurely.
     - Clipped to `[0, 1]` under the assumption they’re probabilities, but coming from `predict()` of regression models.
   - Make sure clipping is applied **only** to values that are logically probabilities.

6. **Validation & regression checks**
   - Recompute:
     - Calibration curves / Brier scores for `availability_active` and `anytime_td`.
     - Compare pre‑change vs post‑change (you should see better calibration, maybe slightly different AUC).
   - Add tests that:
     - For classification problems, `predict_proba` is used and output values are between 0 and 1.
     - Downstream functions that expect probabilities receive `float` arrays, not `int` labels.

**Risks / Pitfalls:**

- Models trained with assumptions about `predict()` vs `predict_proba()` might require minor retraining or calibration.
- If some classification problems are currently implemented as regression (e.g., target `0/1` with regression objective), you’ll need to either:
  - Convert them to true classification objectives, or
  - Treat their outputs as scores and calibrate separately.

---

**Epic T1.3 – Deduplicate and simplify TD efficiency / anytime TD configs**

**Goal:** Have a single, clear, auditable configuration for TD‑related models with no duplicate `efficiency_tds` definitions or conflicting feature sets.

**Steps:**

1. **Clarify the intended TD efficiency problem definition**
   - Decide with domain logic:
     - What is the canonical label (`tds_per_opportunity`, `prob_td_on_touch`, etc.)?
     - Which feature families should TD efficiency use (usage, red zone roles, team totals, pace, defense, etc.)?
   - Capture this in a short design note.

2. **Resolve the duplicate `efficiency_tds` blocks**
   - Compare the two blocks in `config/training.yaml`:
     - Feature prefixes.
     - Columns to discard.
     - Any differences in hyperparams.
   - Choose one as canonical (or merge them):
     - E.g., keep the richer feature set but drop obviously redundant or leaky prefixes (`ps_game_*`, same‑game outcomes).
   - Remove the duplicate block and update any references that rely on it.

3. **Align anytime TD model configuration with the efficiency chain**
   - Document the chain:
     - Availability → usage (targets/carries) → efficiency (yards/TD per opportunity) → anytime TD.
   - Ensure:
     - Anytime TD config uses:
       - Probabilities and expected counts from upstream problems.
       - Contextual features like team totals, game totals, pace.
     - Avoid re‑using raw same‑game stats or label proxies as features.

4. **Simplify modeling options**
   - If LightGBM isn’t used:
     - Either remove it from `models:` or clearly comment it as “experimental/off by default”.
   - Ensure `training.models_to_train` includes only the models you actually train and deploy (e.g., `['xgboost']`).

5. **Add consistency checks**
   - Test to assert no duplicate `name:` entries in `problems` config.
   - Add a small script or test that:
     - Loads all problem definitions.
     - Checks for unique names and consistent `problem_type`.

**Risks / Pitfalls:**

- Removing a duplicate block changes behavior if production unexpectedly relies on the “second” version; you’ll want to re‑run a backtest to confirm performance stays acceptable or improves.

---

**Epic T2.1 – Pre‑snap feature audit and realistic football semantics**

**Goal:** Ensure every pre‑snap feature reflects something knowable pre‑kickoff and ties clearly to real mechanisms: role, alignment, script, red zone usage, team tendencies.

**Steps:**

1. **Categorize pre‑snap features by realism**
   - For each `ps_*` (or new `ps_hist_*`/`ps_game_*`) prefix, classify:
     - **Realistic pre‑game info:** historical role, alignment tendencies, red zone share, scripted usage trends.
     - **Borderline:** things that correlate with game plan but may be noisy (e.g., early‑game pace within the current season).
     - **Unrealistic (leaky):** same‑game realized stats, direct label proxies (e.g., same‑game TD shares).
   - Document per feature family: `ps_route_participation_*`, `ps_targets_*`, `ps_scripted_*`, red zone splits, etc.

2. **Prune or rename unrealistic pre‑snap features**
   - For features that are “unrealistic” but currently used:
     - Either:
       - Remove them as inputs (preferred).
       - Or redesign them as historical aggregates (e.g., last 8 games, season to date).
   - Ensure new names reflect semantics:
     - `rz_target_share_last_8g` rather than `player_red_zone_target_share`.

3. **Re‑balance feature sets around real drivers**
   - Emphasize:
     - Team implied totals and spreads (odds).
     - Historical red zone role (`targets inside 10`, `carries inside 5`, etc. per player).
     - Positional and formation tendencies (slot vs wide vs backfield usage).
     - Pace, pass rate over expected, run/pass splits by game script.
   - De‑emphasize:
     - Features that mix realized “hot hand” from the current game with historical role.

4. **Define small, interpretable pre‑snap feature groups**
   - Create 3–5 conceptual groups:
     - `role_usage` (routes, snaps, alignment history).
     - `scripted_intent` (openers, 3rd‑down usage).
     - `scoring_context` (team totals, red zone history).
     - `game_environment` (pace, spread, weather).
   - Ensure each pre‑snap or TD model uses these groups in ways that match football logic.

5. **Add documentation**
   - Write brief docs (even in comments or a markdown file) describing:
     - What each group means.
     - How it ties to real decision‑making (e.g., “this approximates OC’s likely red zone plan”).

**Risks / Pitfalls:**

- Over‑simplifying may hurt raw accuracy; need to balance football realism with empirical performance.
- Some features may have overlapping information; regularization/hyperparameters may need retuning after pruning.

---

**Epic T2.2 – Handling low‑coverage pre‑snap tracking and baselines**

**Goal:** Make tracking coverage and baseline fallback explicit, avoiding silent “noisy filler” behavior for players/seasons without tracking.

**Steps:**

1. **Make tracking coverage visible**
   - Add indicators:
     - `has_tracking_this_season`, `has_tracking_last_3g`, etc.
   - When `_load_ps_baselines` succeeds/fails, record:
     - A flag column: `ps_baseline_source` (`actual`, `baseline`, `none`).

2. **Define a clear fallback strategy**
   - Policies for missing tracking:
     - If no tracking and no meaningful baseline:
       - Either drop those player‑game rows from pre‑snap models, or
       - Use heavily shrunk priors (e.g., depth‑chart based role) with explicit indicator flags.
   - For low‑usage players:
     - Consider hierarchical pooling (e.g., use positional averages by team/role).

3. **Update `_apply_ps_fallback` to be explicit, not silent**
   - Instead of a no‑op on empty baseline:
     - Set `ps_hist_*` to `NaN` or a defined prior and mark the row via an indicator.
   - Ensure models:
     - Either handle missing values robustly, or
     - Use the indicator to “know” that this is a low‑info case and rely more on team/position context.

4. **Stratify evaluation by tracking coverage**
   - When evaluating pre‑snap and TD models:
     - Slice metrics by `has_tracking_*` and `ps_baseline_source`.
     - Confirm that:
       - Performance on fully tracked cohorts is good.
       - Performance on low‑coverage cohorts is at least reasonable, not driven by noise.

**Risks / Pitfalls:**

- Dropping low‑coverage rows reduces sample size; may need regularization tweaks.
- Introducing NaNs requires careful handling in feature matrices and model training.

---

**Epic T2.3 – Refine scripted touches / early‑game heuristics**

**Goal:** Move from a rigid “first 15 plays” definition to something that captures how teams actually script drives and touches.

**Steps:**

1. **Analyze current scripted heuristic**
   - Use existing `offense_play_rank < 15` scripted labels to:
     - Compute per‑team distribution of scripted plays per game.
     - See whether 15 is a good cutoff across teams/seasons.
   - Look for:
     - Two‑minute drills, hurry‑up sequences that are mis‑classified.
     - Games where the first 15 plays span multiple drives with very different context.

2. **Design a more nuanced scripted definition**
   - Candidate heuristics:
     - “Scripted” = plays in first X minutes of game clock on early downs outside two‑minute/4‑minute situations.
     - Or: first N plays **per offense** excluding hurry‑up scenarios (no huddles, < 1:00 on clock).
   - Optionally:
     - Design team‑level `script_length` parameters learned from historical behavior.

3. **Adjust labels and recompute `ps_game_scripted_*`**
   - Implement improved heuristics in `player_game_level`:
     - New flag `is_scripted_play`.
     - Recompute `ps_game_scripted_targets`, `ps_game_scripted_carries`, etc.
   - Use historical data to confirm:
     - New scripted labels correlate with expected openers (WR1/WR2, goal‑line RBs, etc.).

4. **Re‑train pre‑snap models that use scripted features**
   - Update pre‑snap models that include scripted touch features:
     - Use `ps_hist_*` approximations to predict new `ps_game_scripted_*` labels.
   - Re‑evaluate:
     - How much scripted touches add over generic role metrics to anytime TD prediction.

**Risks / Pitfalls:**

- More complex heuristics may be harder to reason about; keep them as simple as possible while fixing major issues.
- Some teams may have inconsistent scripting; avoid overfitting to quirks in small samples.

---

**Epic T3.1 – Cleanup of legacy / unused code**

**Goal:** Reduce cognitive load and risk of misinterpretation by clearly marking or removing unused configs and modules.

**Steps:**

1. **Identify unused model families and configs**
   - LightGBM blocks in `config/training.yaml`.
   - Legacy MLB code under `utils/train/selective/*`, `mlb_legacy.md`, etc.
   - Any old problems in `problems` list that are not:
     - Trained.
     - Saved.
     - Used downstream in prediction.

2. **Decide policy: remove vs quarantine**
   - For NFL work, likely:
     - Move legacy configs into a `legacy/` or `archive/` section with explicit comments.
     - Or delete entirely if not referenced.

3. **Update documentation**
   - Document the active set of problems and model types:
     - E.g., “Active for NFL anytime TD pipeline: availability_active, pre_snap_routes, pre_snap_scripted_touches, usage_targets, usage_carries, efficiency_yards, efficiency_tds, anytime_td.”

4. **Add CI/Tests for config hygiene**
   - Test that:
     - All `problems.name` values are unique.
     - All referenced problems have corresponding model artifacts.
     - No model type is declared in `config` but never used anywhere.

**Risks / Pitfalls:**

- Removing code that is used in ad‑hoc scripts or by other teams. Favor quarantining with documentation over hard deletion unless you’re sure.

---

**Epic T3.2 – Observability & leakage guards**

**Goal:** Add automated checks that protect against reintroducing leakage or train/predict feature mismatches.

**Steps:**

1. **Feature parity tests**
   - For each problem:
     - Load training feature names from artifacts.
     - Load prediction feature names from the live pipeline.
     - Assert parity, with a small list of allowed differences (e.g., `game_id`, `player_id`).

2. **Leakage signature tests**
   - Maintain lists of “never features”:
     - Same‑game outcomes: `*_yards`, `*_td`, `*_touches`, `*_targets`, etc.
     - `ps_game_*` namespace.
   - Test that:
     - These columns never appear in `features_to_use` for any problem.

3. **As‑of and snapshot tests**
   - Add regression tests ensuring:
     - `decision_cutoff_ts` logic in `feature.py` and `player_game_level.py` correctly filters injury/odds/weather columns.
     - No columns with `reported_at` > `decision_cutoff_ts` survive into training matrices.

4. **Monitoring / dashboards (if applicable)**
   - For production predictions:
     - Track distributions of key features and outputs over time.
     - Alert on distribution shifts, especially for:
       - `ps_hist_*` inputs.
       - `p_active`, `p_anytime_td`.

**Risks / Pitfalls:**

- Over‑constraining tests can slow iteration; keep rules minimal but high‑impact.

---

**Epic T3.3 – Documentation of football mechanisms**

**Goal:** Make the mapping from football concepts to features and models explicit so future changes stay aligned with reality.

**Steps:**

1. **Write a short “anytime TD model design” doc**
   - Sections:
     - High‑level architecture (availability → usage → efficiency → TD).
     - Definitions of key labels (what is “anytime TD” exactly, what is “efficiency_tds”).
     - Explanation of pre‑snap models and how their predictions are used.

2. **Document feature groups and semantics**
   - For each group (role_usage, scripted_intent, scoring_context, game_environment):
     - List representative features.
     - Explain their intended connection to TD probability.

3. **Add inline references from config to docs**
   - In `config/training.yaml`:
     - Add short comments or references to the design doc sections next to each problem.
   - Optionally, generate a markdown summary from the config so docs stay in sync.

---

If you’d like, next step could be to pick one Tier‑1 epic (e.g., `ps_*` alignment or classification pipeline) and I can turn that into a more concrete implementation checklist (file‑by‑file changes, data migration steps, and specific tests to add), ready for an agent to execute.
    <END_PLAN_END>

    Repository + Git requirements:

    - This repo is under git. At the very beginning of THIS RUN, before editing any files:
        1) Run `git status` to inspect the current state.
        2) If there are uncommitted changes from previous runs, stage and commit them with a concise
           message like `codex: iteration checkpoint` (or a slightly more descriptive variant).
        3) If a remote named `origin` exists and authentication allows, run `git push` so that the
           current state is saved remotely. If push fails due to auth or remote issues, continue with
           local commits only, but do NOT delete history.
        4) Only after ensuring there is a clean commit of the current state should you begin making
           new edits in this run.

    - During this run:
        * Make coherent, incremental commits as you reach logical checkpoints.
        * If you realize that your changes have badly broken the project and you cannot fix them
          cleanly within this run, you may revert to the last good commit (for example, using
          `git reset --hard HEAD` or `git checkout .`), then proceed more conservatively.

    Your tools allow you to:
    - Inspect files in this repo.
    - Edit files.
    - Run shell commands/tests as needed (e.g. project-specific tests, evaluations, or scripts).
    - Use git commands to create commits and, if possible, push them.

    Your goal in THIS RUN:
    - Implement as much of the plan as you reasonably can with high quality.
    - Prioritize correctness, alignment with football reality, and improved model performance
      over speed.
    - Run whatever tests or checks are appropriate to validate your changes.

    At the end of THIS RUN:
    - Give a concise update on your progress.
    - If the ENTIRE plan is fully implemented and validated, include a line with EXACTLY:
        The plan is completely implemented
      (case and spacing exactly as written).
    - If the plan is NOT fully implemented, include a concise progress summary starting with:
        PROGRESS:
      followed by a short description of what you accomplished and what remains.

    Take your time and implement the richest / most complete solution for the pieces you touch in this run.

mcp startup: no servers

thinking
**Checking git status before edits**
exec
/bin/zsh -lc 'git status --short' in /Users/jameswest/Desktop/nfl_predict succeeded in 826ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
 M codex_meta_loop.py
 M docs/rolling_window_implementation.md
 M pipeline/feature.py
 M pipeline/predict.py
 M utils/feature/rolling_window.py
 M utils/feature/stats.py
?? .codex_meta_logs/
?? codex_output.md

thinking
**Preparing git commit**
exec
/bin/zsh -lc 'git add -A' in /Users/jameswest/Desktop/nfl_predict exited 128 in 1.05s:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
fatal: Unable to create '/Users/jameswest/Desktop/nfl_predict/.git/index.lock': Operation not permitted

thinking
**Checking for git index lock file**
exec
/bin/zsh -lc 'ls -l .git/index.lock' in /Users/jameswest/Desktop/nfl_predict exited 1 in 3.41s:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
ls: .git/index.lock: No such file or directory

thinking
**Investigating git add permission issues**
exec
/bin/zsh -lc 'ls -ld .git' in /Users/jameswest/Desktop/nfl_predict succeeded in 825ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
drwxr-xr-x  13 jameswest  staff  416 Nov 26 01:35 .git

thinking
**Investigating permission error with git index.lock**
exec
/bin/zsh -lc 'ls .git | rg index' in /Users/jameswest/Desktop/nfl_predict succeeded in 820ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
index

thinking
**Checking file creation permissions**
exec
/bin/zsh -lc 'touch .git/test_write_permission' in /Users/jameswest/Desktop/nfl_predict exited 1 in 810ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
touch: .git/test_write_permission: Operation not permitted

thinking
**Investigating write permissions for git operations**
exec
/bin/zsh -lc 'touch /Users/jameswest/Desktop/nfl_predict/test_write' in /Users/jameswest/Desktop/nfl_predict succeeded in 786ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted

thinking
**Checking .git directory permissions**
exec
/bin/zsh -lc 'ls -le .git' in /Users/jameswest/Desktop/nfl_predict succeeded in 769ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
total 72
-rw-r--r--    1 jameswest  staff     18 Nov 26 01:04 COMMIT_EDITMSG
-rw-r--r--    1 jameswest  staff     21 Nov 25 22:42 HEAD
-rw-r--r--    1 jameswest  staff     41 Nov 25 22:50 ORIG_HEAD
-rw-r--r--    1 jameswest  staff    308 Nov 25 22:58 config
-rw-r--r--    1 jameswest  staff     73 Nov 25 22:42 description
drwxr-xr-x   15 jameswest  staff    480 Nov 25 22:42 hooks
-rw-r--r--    1 jameswest  staff  13040 Nov 26 01:04 index
drwxr-xr-x    3 jameswest  staff     96 Nov 25 22:42 info
drwxr-xr-x    4 jameswest  staff    128 Nov 25 22:45 logs
drwxr-xr-x  170 jameswest  staff   5440 Nov 26 01:35 objects
drwxr-xr-x    5 jameswest  staff    160 Nov 25 22:58 refs

thinking
**Investigating write permission issues on .git directory**
exec
/bin/zsh -lc 'ls -ldO .git' in /Users/jameswest/Desktop/nfl_predict succeeded in 774ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
drwxr-xr-x  13 jameswest  staff  - 416 Nov 26 01:35 .git

thinking
**Troubleshooting git commit permission issues**
exec
/bin/zsh -lc 'touch .git/objects/test' in /Users/jameswest/Desktop/nfl_predict exited 1 in 782ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
touch: .git/objects/test: Operation not permitted

thinking
**Handling git write restrictions**
exec
/bin/zsh -lc 'rm /Users/jameswest/Desktop/nfl_predict/test_write' in /Users/jameswest/Desktop/nfl_predict succeeded in 780ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted

thinking
**Planning approach and inspecting repo structure**
exec
/bin/zsh -lc ls in /Users/jameswest/Desktop/nfl_predict succeeded in 786ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
README.md
__pycache__
audit
cache
codex_meta_loop.py
codex_output.md
config
data
docs
logs
main.py
output
pipeline
pyproject.toml
requirements.txt
scripts
tests
tmp.parquet
tmp_features.parquet

thinking
**Evaluating plan scope and initial inspection**
exec
/bin/zsh -lc 'rg "ps_" utils/feature' in /Users/jameswest/Desktop/nfl_predict succeeded in 798ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
utils/feature/concatenate_parquets.py:          .select(pl.len().alias("__n_dup_groups__"))
utils/feature/concatenate_parquets.py:    if dup_groups["__n_dup_groups__"][0] == 0:
utils/feature/stats.py:    "ps_route_participation_pct",
utils/feature/stats.py:    "ps_route_participation_plays",
utils/feature/stats.py:    "ps_targets_total",
utils/feature/stats.py:    "ps_targets_slot_count",
utils/feature/stats.py:    "ps_targets_wide_count",
utils/feature/stats.py:    "ps_targets_inline_count",
utils/feature/stats.py:    "ps_targets_backfield_count",
utils/feature/stats.py:    "ps_targets_slot_share",
utils/feature/stats.py:    "ps_targets_wide_share",
utils/feature/stats.py:    "ps_targets_inline_share",
utils/feature/stats.py:    "ps_targets_backfield_share",
utils/feature/player_game_level.py:    "ps_route_participation_plays",
utils/feature/player_game_level.py:    "ps_team_dropbacks",
utils/feature/player_game_level.py:    "ps_route_participation_pct",
utils/feature/player_game_level.py:    "ps_targets_total",
utils/feature/player_game_level.py:    "ps_targets_slot_count",
utils/feature/player_game_level.py:    "ps_targets_wide_count",

thinking
**Searching for ps references in config**
exec
/bin/zsh -lc 'rg "ps_" config' in /Users/jameswest/Desktop/nfl_predict succeeded in 778ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
config/training.yaml:    target_col: 'ps_route_participation_pct'
config/training.yaml:      - 'ps_route_participation_'
config/training.yaml:      - 'ps_targets_'
config/training.yaml:    target_col: 'ps_scripted_touches'
config/training.yaml:      - 'ps_scripted_'
config/training.yaml:      - 'ps_route_participation_'
config/training.yaml:      - 'ps_total_'
config/training.yaml:      - 'ps_targets_'
config/training.yaml:      - 'ps_route_participation_'
config/training.yaml:      - 'ps_targets_'
config/training.yaml:      - 'ps_targets_backfield_'
config/training.yaml:      - 'ps_route_participation_'
config/training.yaml:      - 'ps_targets_'
config/training.yaml:      - 'ps_targets_backfield_'

thinking
**Checking training.yaml for context**
exec
/bin/zsh -lc 'rg -n "ps_" config/training.yaml' in /Users/jameswest/Desktop/nfl_predict succeeded in 792ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
178:    target_col: 'ps_route_participation_pct'
183:      - 'ps_route_participation_'
184:      - 'ps_targets_'
203:    target_col: 'ps_scripted_touches'
208:      - 'ps_scripted_'
209:      - 'ps_route_participation_'
210:      - 'ps_total_'
211:      - 'ps_targets_'
235:      - 'ps_route_participation_'
236:      - 'ps_targets_'
270:      - 'ps_targets_backfield_'
310:      - 'ps_route_participation_'
311:      - 'ps_targets_'
348:      - 'ps_targets_backfield_'

thinking
**Preparing to extract more context lines**
exec
/bin/zsh -lc "sed -n '130,260p' config/training.yaml" in /Users/jameswest/Desktop/nfl_predict succeeded in 813ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
      - 'travel_'
    other_features_to_include:
      - 'week'
      - 'season'
      - 'position'
      - 'recent_inactivity_count'
      - 'was_inactive_last_game'
      - 'travel_rest_days'
      - 'travel_rest_days_l3'
      - 'rest_days_since_last_game'
    columns_to_discard: *columns_to_discard_extended

  # ============================================================================
  # 1B. TEAM PACE MODEL
  # ============================================================================
  # Predict team-level offensive plays to stabilize downstream usage forecasts.
  - name: 'team_pace'
    target_col: 'team_offensive_plays_actual'
    task_type: 'regression'
exec
/bin/zsh -lc "sed -n '260,380p' config/training.yaml" in /Users/jameswest/Desktop/nfl_predict succeeded in 964ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
  # 2B. USAGE MODEL - CARRIES
  # ============================================================================
  # Predict carries given availability.
  - name: 'usage_carries'
    target_col: 'carry'
    task_type: 'regression'
    input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes', 'pre_snap_scripted_touches']
    feature_prefixes_to_include:
      - 'pred_'
      - 'hist_carry_share_'
      - 'ps_targets_backfield_'
      - 'travel_'
      - 'team_pace_'
      - 'opp_pace_'
      - 'matchup_pace_'
      - 'implied_prob_'
      - 'moneyline_'
      - 'spread_'
    other_features_to_include:
exec
/bin/zsh -lc "sed -n '380,520p' config/training.yaml" in /Users/jameswest/Desktop/nfl_predict succeeded in 786ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
      - 'efficiency_rush_yards'
    feature_prefixes_to_include:
      - 'pred_'
      - 'expected_'
      - 'opp_def_'
      - 'red_zone_'
      - 'goal_to_go_'
      - 'off_ctx_'
      - 'qb_profile_'
      - 'drive_hist_'
      - 'weather_'
      - 'travel_'
    other_features_to_include:
      - 'week'
      - 'season'
      - 'position'
      - 'total_line'
      - 'team_implied_total'
      - 'travel_rest_days'

thinking
**Investigating feature prefix usage**
exec
/bin/zsh -lc 'rg -n "add_rolling" pipeline/predict.py' in /Users/jameswest/Desktop/nfl_predict succeeded in 776ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
46:from utils.feature.rolling_window import add_rolling_features
1290:        enriched = add_rolling_features(
exec
/bin/zsh -lc "sed -n '1250,1325p' pipeline/predict.py" in /Users/jameswest/Desktop/nfl_predict succeeded in 825ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
    if "week" in pl_df.columns:
        pl_df = pl_df.with_columns(pl.col("week").cast(pl.Int32))

    seasons = pl_df.get_column("season").unique().to_list() if "season" in pl_df.columns else []
    game_ids = pl_df.get_column("game_id").unique().to_list() if "game_id" in pl_df.columns else []
    asof_meta = pl.DataFrame()
    try:
        asof_meta = load_asof_metadata()
    except Exception as exc:
        logger.warning("Failed to load as-of metadata: %s", exc)
        asof_meta = pl.DataFrame()

    if asof_meta.is_empty() or (game_ids and asof_meta.filter(pl.col("game_id").is_in(game_ids)).height < len(game_ids)):
        if seasons:
            try:
                asof_meta = build_asof_metadata(seasons, force=True)
            except Exception as exc:
                logger.warning("Unable to rebuild as-of metadata: %s", exc)
                asof_meta = pl.DataFrame()
exec
/bin/zsh -lc "sed -n '1325,1405p' pipeline/predict.py" in /Users/jameswest/Desktop/nfl_predict succeeded in 779ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
    }
    existing = set(enriched.columns)
    valid_renames = {k: v for k, v in rename_map.items() if k in existing}
    if valid_renames:

thinking
**Investigating feature renaming conflicts**
exec
/bin/zsh -lc 'rg -n "_predict_for_problem" pipeline/predict.py' in /Users/jameswest/Desktop/nfl_predict succeeded in 766ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
2334:def _predict_for_problem(features: pd.DataFrame, problem_name: str, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
2404:            preds = _predict_for_problem(features, p_name, artifacts)
exec
/bin/zsh -lc "sed -n '2330,2375p' pipeline/predict.py" in /Users/jameswest/Desktop/nfl_predict succeeded in 788ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
             adj[floor_mask] = np.maximum(adj[floor_mask], 0.35)
             
    return adj

def _predict_for_problem(features: pd.DataFrame, problem_name: str, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
    X, _ = _prepare_feature_matrix(features, artifacts)
    
    model = joblib.load(_latest_model_path(problem_name))
    
    # Assuming XGBoost or similar with predict_proba for classification and predict for regression
    # But for simplicity and compatibility with regression, check model type or problem definition?
    # Actually, regression models in sklearn/xgb return values directly on predict().
    # Classification models return class labels on predict(), and probas on predict_proba().
    
    try:
        # Heuristic: Try predict_proba first if it looks like a classifier (anytime_td)
        # But we need to know task type.
        if "anytime_td" in problem_name:
             proba = model.predict_proba(X)[:, 1]

thinking
**Outlining partial feature refactor plan**
exec
/bin/zsh -lc 'rg -n "pre" utils/feature/player_game_level.py' in /Users/jameswest/Desktop/nfl_predict succeeded in 810ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
1:"""Player-game level aggregation for NFL predictions.
38:    predict_probabilities as predict_injury_probabilities,
87:    "market_anytime_td_spread",
91:    "market_anytime_td_spread_2h",
95:    "market_anytime_td_spread_6h",
99:    "market_anytime_td_spread_24h",
103:    "market_anytime_td_spread_open",
174:def _compute_pre_snap_usage(df: pl.DataFrame) -> pl.DataFrame:
808:        pl.lit(0.0).cast(pl.Float32).alias("snap_offense_pct_prev"),
810:        pl.lit(0).cast(pl.Int32).alias("snap_offense_snaps_prev"),
811:        pl.lit(0.0).cast(pl.Float32).alias("snap_defense_pct_prev"),
813:        pl.lit(0).cast(pl.Int32).alias("snap_defense_snaps_prev"),
814:        pl.lit(0.0).cast(pl.Float32).alias("snap_st_pct_prev"),
816:        pl.lit(0).cast(pl.Int32).alias("snap_st_snaps_prev"),
836:        # Removed explicit stub feature per user preference for natural feature learning
949:    """Build first() expressions for metadata columns present in the frame."""
976:            roster_pl.write_parquet(cache_path, compression="zstd")
1148:            injury_pl.write_parquet(cache_path, compression="zstd")
1205:    """Create a Polars expression to normalize player names."""

thinking
**Opening _compute_pre_snap_usage function**
exec
/bin/zsh -lc "sed -n '150,260p' utils/feature/player_game_level.py" in /Users/jameswest/Desktop/nfl_predict succeeded in 874ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
    "ps_targets_slot_share",
    "ps_targets_wide_share",
    "ps_targets_inline_share",
    "ps_targets_backfield_share",
    "ps_total_touches",
    "ps_scripted_touches",
    "ps_scripted_touch_share",
]
PRE_SNAP_ROLLING_TARGETS = [
    "ps_route_participation_pct",
    "ps_scripted_touch_share",
    "ps_targets_slot_share",
    "ps_targets_wide_share",
    "ps_targets_inline_share",
    "ps_targets_backfield_share",
]
def _safe_split(col: pl.Expr) -> pl.Expr:
    return (
        pl.when(col.is_not_null())

thinking
**Continuing to review code**
exec
/bin/zsh -lc "sed -n '260,420p' utils/feature/player_game_level.py" in /Users/jameswest/Desktop/nfl_predict succeeded in 856ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
                "team",
                "game_id",
                "play_id",
                "player_id",
            ]
        )
        .unique()
        .group_by(["season", "week", "team", "player_id"])
        .agg(pl.len().alias("ps_route_participation_plays"))
    )

    dropbacks = (
        pass_lists.select(["season", "week", "team", "game_id"])
        .unique()
        .group_by(["season", "week", "team"])
        .agg(pl.len().alias("ps_team_dropbacks"))
    )

    route_participation = route_participation.join(

thinking
**Continuing script review**
exec
/bin/zsh -lc "sed -n '420,620p' utils/feature/player_game_level.py" in /Users/jameswest/Desktop/nfl_predict succeeded in 766ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
                pl.col("receiver_player_id").cast(pl.Utf8).alias("player_id"),
                "is_scripted_play",
            ]
        )
    )

    rush_touches = (
        scripted_source.filter(pl.col("carry").fill_null(0) == 1)
        .filter(pl.col("rusher_player_id").is_not_null())
        .select(
            [
                "season",
                "week",
                "team",
                pl.col("rusher_player_id").cast(pl.Utf8).alias("player_id"),
                "is_scripted_play",
            ]
        )
    )

thinking
**Searching for rolling feature stats definitions**
exec
/bin/zsh -lc 'rg -n "ROLLING_FEATURE_STATS" utils/feature/stats.py' in /Users/jameswest/Desktop/nfl_predict succeeded in 832ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
95:ROLLING_FEATURE_STATS: List[str] = [
exec
/bin/zsh -lc "sed -n '70,130p' utils/feature/stats.py" in /Users/jameswest/Desktop/nfl_predict succeeded in 791ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
    "ps_route_participation_plays",
    "ps_targets_total",
    "ps_targets_slot_count",
    "ps_targets_wide_count",
    "ps_targets_inline_count",
    "ps_targets_backfield_count",
    "ps_targets_slot_share",
    "ps_targets_wide_share",
    "ps_targets_inline_share",
    "ps_targets_backfield_share",
]

# Windows for rolling computations (at game level)
# Integers = N most recent games, "season" = current season, "lifetime" = all history
ROLLING_WINDOWS = [1, 3, 5, "season"]

# Contexts for rolling computations
# "vs_any" = all opponents; vs_team/with_team disabled until caches exist
ROLLING_CONTEXTS = ["vs_any"]

thinking
**Investigating ROLLING_FEATURE_STATS source**
exec
/bin/zsh -lc "sed -n '1,80p' utils/feature/stats.py" in /Users/jameswest/Desktop/nfl_predict succeeded in 763ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
"""NFL player statistics configuration for rolling window features.

Defines the standard set of stats tracked at all aggregation levels
(play, drive, game) for rolling window computations.

This module is the SINGLE SOURCE OF TRUTH for stat definitions used
throughout the pipeline. Import from here rather than defining locally.
"""

from typing import List

# =============================================================================
# Core Stats (used for drive and game level aggregation)
# =============================================================================

# Basic stats aggregated at player-drive level
PLAYER_DRIVE_STATS: List[str] = [
    # Yardage
    "receiving_yards",

thinking
**Analyzing rolling feature stats and ps_ features**
exec
/bin/zsh -lc 'rg "ps_route_participation_pct_per_game"' in /Users/jameswest/Desktop/nfl_predict succeeded in 860ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
codex_output.md:pipeline/predict.py:        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
codex_output.md:pipeline/predict.py:        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
codex_output.md:pipeline/predict.py:        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
codex_output.md:pipeline/predict.py:        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
codex_output.md:pipeline/predict.py:        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
codex_output.md:pipeline/predict.py:        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
codex_output.md:pipeline/predict.py:        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
codex_output.md:pipeline/predict.py:        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
codex_output.md:pipeline/predict.py:        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
codex_output.md:pipeline/predict.py:        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
codex_output.md:pipeline/predict.py:        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
codex_output.md:pipeline/predict.py:        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
codex_output.md:pipeline/predict.py:        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
codex_output.md:pipeline/predict.py:        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
pipeline/predict.py:        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
pipeline/predict.py:        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",

thinking
**Checking rolling_window utilities**
exec
/bin/zsh -lc 'rg -n "ps_" utils/feature/rolling_window.py' in /Users/jameswest/Desktop/nfl_predict exited 1 in 738ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted

thinking
**Investigating missing rolling features**
exec
/bin/zsh -lc 'rg -n "ps_" pipeline/feature.py' in /Users/jameswest/Desktop/nfl_predict exited 1 in 826ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted

thinking
**Formulating partial implementation plan**

I'm weighing how to update feature naming in the pipeline, balancing complexity with progress by possibly renaming same-game features to ps_game_* and historical to ps_hist_ while aligning the classification pipeline and deduplicating config. Given environment limits and uncertainty in the full pipeline, I'll prioritize manageable Tier 1 tasks and consider lighter scope changes like excluding same-game features to reduce leakage.

thinking
**Planning feature renaming and rolling stats**

thinking
**Investigating feature naming and pipeline compatibility**
exec
/bin/zsh -lc 'rg -n "add_rolling_features" pipeline' in /Users/jameswest/Desktop/nfl_predict succeeded in 798ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
pipeline/feature.py:31:from utils.feature.rolling_window import add_rolling_features
pipeline/feature.py:838:            df_player_game_all = add_rolling_features(
pipeline/predict.py:46:from utils.feature.rolling_window import add_rolling_features
pipeline/predict.py:1290:        enriched = add_rolling_features(

thinking
**Inspecting pipeline feature.py near line 838**
exec
/bin/zsh -lc "sed -n '780,890p' pipeline/feature.py" in /Users/jameswest/Desktop/nfl_predict succeeded in 743ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
        )
    if "odds_anytime_td_price" in df_player_game_all.columns:
        df_player_game_all = df_player_game_all.drop("odds_anytime_td_price", strict=False)
        logging.info("Player prop odds enrichment disabled to avoid live snapshot leakage.")

    numeric_casts = []
    if "depth_chart_order" in df_player_game_all.columns:
        numeric_casts.append(pl.col("depth_chart_order").cast(pl.Int16))
    for col in ("is_home", "game_start_hour_utc", "game_day_of_week"):
        if col in df_player_game_all.columns:
            numeric_casts.append(pl.col(col).cast(pl.Int8))
    for col in (
        "injury_is_listed",
        "injury_practice_dnp_count",
        "injury_practice_limited_count",
        "injury_practice_full_count",
    ):
        if col in df_player_game_all.columns:
            numeric_casts.append(pl.col(col).cast(pl.Int8))

thinking
**Planning rolling feature renaming and integration**

I'm working through how to update rolling ps_* stats naming and integration into training and prediction pipelines. The goal is to adopt a consistent `ps_hist_{stat}_{window}` prefix, adjusting rename mappings and pipeline steps to keep training and inference aligned while considering where best to centralize the renaming logic. I'll explore helper functions or constants to share renaming rules and ensure base same-game columns get renamed to `ps_game_` too.

thinking
**Weighing column renaming strategies**

thinking
**Investigating feature column selection**
exec
/bin/zsh -lc 'rg -n "columns_to_discard" pipeline/predict.py' in /Users/jameswest/Desktop/nfl_predict exited 1 in 828ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted

thinking
**Checking pipeline for selection feature**
exec
/bin/zsh -lc 'rg -n "feature_prefixes_to_include" pipeline' in /Users/jameswest/Desktop/nfl_predict succeeded in 796ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
pipeline/train.py:2226:                include_prefixes = tuple(problem_copy.get('feature_prefixes_to_include') or [])
exec
/bin/zsh -lc "sed -n '2190,2265p' pipeline/train.py" in /Users/jameswest/Desktop/nfl_predict succeeded in 780ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted

                if not is_structurally_valid:
                    logger.warning(f"STALE CACHE DETECTED for problem '{problem_name}'. "
                                   "Artifact file has an outdated structure. "
                                   "Discarding stale artifacts and regenerating from scratch.")
                    use_cached_for_problem = False
                    artifact_path.unlink(missing_ok=True)
                
                # --- VALIDATION 2: Data Consistency ---
                if is_structurally_valid:
                    cached_features = artifacts.get('feature_columns', [])
                    if all_parquet_cols is not None:
                        missing_features = set(cached_features) - set(all_parquet_cols)
                        if missing_features:
                            logger.warning(
                                f"STALE CACHE DETECTED for problem '{problem_name}'. "
                                f"Cached artifacts require features that are missing from the input data: {sorted(list(missing_features))}. "
                                "Discarding stale artifacts and regenerating from scratch."
                            )
exec
/bin/zsh -lc "sed -n '2265,2360p' pipeline/train.py" in /Users/jameswest/Desktop/nfl_predict succeeded in 776ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
            )
            if df_problem.columns.duplicated().any():
                dup_cols = df_problem.columns[df_problem.columns.duplicated()].tolist()
                logger.warning(f"Duplicate columns detected after load: {dup_cols}")
                df_problem = df_problem.loc[:, ~df_problem.columns.duplicated()]

            df_problem = self._apply_problem_level_overrides(df_problem, problem_copy)
            
            # Merge input predictions if required
            if input_preds:
                logger.info(f"Merging input predictions for {problem_name}: {input_preds}")
                for pred_name in input_preds:
                    payload = self.problem_predictions.get(pred_name)
                    if not payload:
                        logger.warning(f"Input prediction '{pred_name}' not found in memory! Skipping.")
                        continue
                    pred_df = payload.get("data")
                    pred_keys = payload.get("keys", [])
                    pred_col = f"pred_{pred_name}"

thinking
**Reviewing training helper functions**
exec
/bin/zsh -lc 'rg -n "_inject_composed_features" -n pipeline/train.py' in /Users/jameswest/Desktop/nfl_predict succeeded in 785ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
514:    def _inject_composed_features(self, df: pd.DataFrame) -> pd.DataFrame:
2308:                df_problem = self._inject_composed_features(df_problem)
exec
/bin/zsh -lc "sed -n '480,560p' pipeline/train.py" in /Users/jameswest/Desktop/nfl_predict succeeded in 810ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
        """
        problem_name = problem_config['name']
        self.current_problem_name = problem_name
        logger.info(f"Fitting feature artifacts for problem '{problem_name}' from training data...")

        artifacts = build_feature_artifacts(df_train, problem_config)
        self.feature_columns = artifacts.feature_columns
        self.datetime_features[problem_name] = artifacts.datetime_features
        self.categorical_features[problem_name] = artifacts.categorical_features
        self.category_levels[problem_name] = artifacts.category_levels
    def _normalize_datetime_like_columns(self, df: pd.DataFrame, problem_name: str) -> None:
        """Force datetime/date-like columns into pandas datetime dtype so downstream encoding works."""
        dt_cols: list[str] = []
        for col in df.columns:
            series = df[col]
            if is_datetime64_any_dtype(series):
                dt_cols.append(col)
                continue
            if series.dtype == object:

thinking
**Planning feature renaming and classification fix**

I’m organizing a multi-step plan to rename ps_game features to ps_hist, add rolling stats, update the training pipeline and config accordingly, and ensure no leakage from ps_game features. I also want to standardize classification inference by checking how problem metadata is used in the predict pipeline and inspecting the config loading and structure in pipeline/predict.py.
exec
/bin/zsh -lc "sed -n '1,200p' pipeline/predict.py" in /Users/jameswest/Desktop/nfl_predict succeeded in 893ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
"""
NFL prediction pipeline
=======================

Generates anytime-touchdown probabilities for upcoming games by:

1. Loading the upcoming schedule and weekly rosters (via nfl_data_py)
2. Building a player-level scaffold for offensive skill positions
3. Enriching that scaffold with rolling-window features using the same
   caches that power the training pipeline
4. Sequentially running the model chain:
   Availability -> Team Pace -> Usage -> Efficiency -> Anytime TD
5. Writing an actionable slate under `output/predictions/`
"""

from __future__ import annotations

import argparse
from datetime import date, datetime, timedelta

thinking
**Prioritizing classification and deduplication tasks**
exec
/bin/zsh -lc 'rg "classification" config/training.yaml' in /Users/jameswest/Desktop/nfl_predict succeeded in 757ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
    task_type: 'classification'
    task_type: 'classification'
  classification_metrics:

thinking
**Searching for classification context**
exec
/bin/zsh -lc "rg -n \"task_type: 'classification'\" -n -B 2 -A 2 config/training.yaml" in /Users/jameswest/Desktop/nfl_predict succeeded in 782ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
98-  - name: 'availability_active'
99-    target_col: 'is_active'
100:    task_type: 'classification'
101-    feature_prefixes_to_include:
102-      - 'injury_'
--
433-  - name: 'anytime_td'
434-    target_col: 'anytime_td'
435:    task_type: 'classification'
436-    input_predictions:
437-      - 'availability_active'

thinking
**Investigating classification handling**
exec
/bin/zsh -lc 'rg -n "task_type" pipeline/train.py' in /Users/jameswest/Desktop/nfl_predict succeeded in 762ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
48:    get_task_type, is_classification, is_regression, get_model_instance, auto_spw
1134:                    get_task_type(problem_config),
1312:                    get_task_type(problem_config),
1331:                            get_task_type(problem_config),
1354:                            get_task_type(problem_config),
1593:                        "task_type": "regression",
1691:                get_task_type(problem_config),
1712:                    get_task_type(problem_config),

thinking
**Searching for classification helpers**
exec
/bin/zsh -lc 'rg -n "def get_task_type"' in /Users/jameswest/Desktop/nfl_predict succeeded in 773ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
utils/train/model_factory.py:5:def get_task_type(problem_cfg: dict) -> str:
exec
/bin/zsh -lc "sed -n '1,200p' utils/train/model_factory.py" in /Users/jameswest/Desktop/nfl_predict succeeded in 766ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
# utils/train/model_factory.py
import numpy as np
import xgboost as xgb

def get_task_type(problem_cfg: dict) -> str:
    return str(problem_cfg.get("task_type", "classification")).lower()

def is_classification(problem_cfg: dict) -> bool:
    return get_task_type(problem_cfg) in ("classification", "binary", "multiclass")

def is_regression(problem_cfg: dict) -> bool:
    return get_task_type(problem_cfg) == "regression"

def get_model_instance(model_name, problem_config, params=None):
    """Exact behavior preserved from train.py."""
    task_type = get_task_type(problem_config)
    model_params = params or problem_config.get(f'{model_name}_params', {})
    if model_name == 'xgboost':
        model_params['n_jobs'] = 1

thinking
**Planning classification probability support**
exec
/bin/zsh -lc 'rg -n "_load_config" pipeline/predict.py' in /Users/jameswest/Desktop/nfl_predict succeeded in 764ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
263:def _load_config() -> dict:
2360:    config = _load_config()
exec
/bin/zsh -lc "sed -n '240,320p' pipeline/predict.py" in /Users/jameswest/Desktop/nfl_predict succeeded in 778ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
    "injury_",
    "drive_hist_",
)
OUTPUT_COLUMN_WHITELIST = [
    "spread_line",
    "team_implied_total",
    "season",
    "week",
    "game_id",
    "position",
]

with STADIUM_COORDS_FILE.open() as fh:
    _STADIUM_COORDS = json.load(fh)

_STADIUM_ALIAS_MAP: dict[str, str] = {}
for code, meta in _STADIUM_COORDS.items():
    if isinstance(meta, dict):
        _STADIUM_ALIAS_MAP[code.upper()] = code

thinking
**Searching for _prepare_feature_matrix definition**
exec
/bin/zsh -lc 'rg -n "def _prepare_feature_matrix" -n pipeline/predict.py' in /Users/jameswest/Desktop/nfl_predict succeeded in 764ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
2197:def _prepare_feature_matrix(df: pd.DataFrame, artifacts: dict) -> Tuple[pd.DataFrame, pd.DataFrame]:
exec
/bin/zsh -lc "sed -n '2170,2245p' pipeline/predict.py" in /Users/jameswest/Desktop/nfl_predict succeeded in 786ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
            pl.col("injury_practice_full_count").cast(pl.Float32),
        ]
    ).drop(["_prob_report", "_prob_practice"])
    aggregated = aggregated.with_columns(
        pl.col("injury_inactive_probability").fill_null(0.1).cast(pl.Float32)
    )

    return enriched.join(aggregated, on=["season", "week", "player_id"], how="left")


def _load_artifacts(problem_name: str) -> dict:
    path = MODEL_DIR / f"inference_artifacts_{problem_name}.joblib"
    if not path.exists():
        if problem_name == "anytime_td":
            alt = MODEL_DIR / "inference_artifacts_anytime_td_meta.joblib"
            if alt.exists():
                logger.warning(
                    "Using legacy anytime_td_meta inference artifacts for anytime_td."
                )

thinking
**Investigating artifact metadata usage**
exec
/bin/zsh -lc 'rg -n "inference_artifacts" -n' in /Users/jameswest/Desktop/nfl_predict succeeded in 774ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
pipeline/train.py:86:    save_inference_artifacts,
pipeline/train.py:2076:        save_inference_artifacts(self, problem_name)
pipeline/train.py:2181:            artifact_path = self.model_dir / f"inference_artifacts_{problem_name}.joblib"
pipeline/train.py:2337:                save_inference_artifacts(self, problem_name)
docs/predict.md:15:  - Inference artifacts (`output/models/inference_artifacts_anytime_td.joblib`) for frozen feature order + categorical levels.
pipeline/predict.py:2181:    path = MODEL_DIR / f"inference_artifacts_{problem_name}.joblib"
pipeline/predict.py:2184:            alt = MODEL_DIR / "inference_artifacts_anytime_td_meta.joblib"
utils/train/ordinal_ev_integration.py:17:def _load_inference_artifacts(trainer, problem_name: str) -> dict:
utils/train/ordinal_ev_integration.py:19:    art_path = trainer.model_dir / f"inference_artifacts_{problem_name}.joblib"  # Use legacy flat path for now
utils/train/ordinal_ev_integration.py:23:        art_path = _vdir(trainer, problem_name, None, "artifacts") / "inference" / f"inference_artifacts_{problem_name}.joblib"
utils/train/ordinal_ev_integration.py:96:        artifacts = _load_inference_artifacts(trainer, prob_name)
utils/train/persist.py:47:def save_inference_artifacts(trainer, problem_name: str) -> None:
utils/train/persist.py:51:    v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
utils/train/persist.py:53:    legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
utils/train/persist.py:170:        artifacts_src = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
utils/train/persist.py:171:        artifacts_dst = v_dir / f"inference_artifacts_{problem_name}.joblib"
utils/train/persist.py:464:        artifact_pattern = "inference_artifacts_*.joblib"
docs/train.md:412:`inference_artifacts_{problem}.joblib` at the problem scope (shared across models).
docs/train.md:663:- `inference_artifacts_gets_2plus_bases.joblib` exists at the problem scope.
exec
/bin/zsh -lc "sed -n '30,120p' utils/train/persist.py" in /Users/jameswest/Desktop/nfl_predict succeeded in 759ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
        out = Path(*parts)
    else:
        out = base
    out.mkdir(parents=True, exist_ok=True)
    return out

def format_metrics_for_yaml(data: dict) -> dict:
    """Moved from _format_metrics_for_yaml."""
    formatted = {}
    for k, v in data.items():
        import numpy as _np
        if isinstance(v, (int, float, _np.floating, _np.integer)):
            formatted[k] = round(v, 4)
        else:
            formatted[k] = v
    return formatted

def save_inference_artifacts(trainer, problem_name: str) -> None:
    # Versioned artifact copy

thinking
**Extending inference artifacts with task metadata**

I’m figuring out how to extend `save_inference_artifacts` to include problem config info like `task_type` from the trainer’s current problem config. This involves adjusting the function signature and updating its call sites in the training pipeline—especially in `TrainPipeline.run`—to ensure the right metadata is saved alongside inference artifacts. I’ll need to check all places calling this function, including ordinal eval integration, to keep things consistent.
exec
/bin/zsh -lc 'rg -n "save_inference_artifacts" -n' in /Users/jameswest/Desktop/nfl_predict succeeded in 766ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
pipeline/train.py:86:    save_inference_artifacts,
pipeline/train.py:2076:        save_inference_artifacts(self, problem_name)
pipeline/train.py:2337:                save_inference_artifacts(self, problem_name)
utils/train/persist.py:47:def save_inference_artifacts(trainer, problem_name: str) -> None:

thinking
**Planning pipeline signature and metadata updates**
exec
/bin/zsh -lc "sed -n '2360,2490p' pipeline/predict.py" in /Users/jameswest/Desktop/nfl_predict succeeded in 713ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
    config = _load_config()
    problems = config.get("problems", [])

    with decision_cutoff_override(
        cutoff_hours=args.decision_cutoff_hours,
        fallback_hours=args.fallback_cutoff_hours,
    ):
        active_cutoff = get_decision_cutoff_hours()
        print(
            f"Generating predictions for {start_date} → {end_date} "
            f"(cutoff {active_cutoff:.2f}h before kickoff)"
        )
        games = _load_schedule(start_date, end_date)
        roster = _load_rosters(games["season"].unique())
        scaffold = _build_scaffold(games, roster)

        _ensure_injury_cache(games["season"].unique())
        _ensure_weather_cache(games["season"].unique())
        _ensure_odds_cache(games["season"].unique(), start_date=start_date, end_date=end_date)

thinking
**Correcting classification predictions and planning config cleanup**

I want to fix the classification prediction method to use predicted probabilities instead of labels, which should improve how availability and guards are applied. Also, I'm planning to deduplicate repeated config blocks in training and cautiously handle feature usage to avoid leakage, possibly by auditing and documenting problematic feature mappings first before making big code changes.

thinking
**Drafting partial fix for feature leakage**

I'll lay out a plan to address feature leakage by distinguishing same-game features from historical ones using new naming like `ps_game_` and `ps_hist_`. Since fully fixing training data is big, I’ll focus on creating rolling historical features and renaming in both training and inference pipelines for a solid foundation.

thinking
**Designing transition to historical features**

I'm working out how to introduce new historical features for predicting ps_game targets by adding rolling-window stats as `ps_hist_*` columns alongside existing base features. I want to keep old names for compatibility while updating configs and dataset filters to exclude outdated prefixes, making sure artifacts and tests reflect this shift and preparing for retraining after these changes.

thinking
**Planning feature aliasing and baseline update**
exec
/bin/zsh -lc 'rg -n "_apply_ps_fallback" -n pipeline/predict.py' in /Users/jameswest/Desktop/nfl_predict succeeded in 805ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
595:def _apply_ps_fallback(enriched: pl.DataFrame, *, season_hint: int | None) -> pl.DataFrame:
1346:    enriched = _apply_ps_fallback(enriched, season_hint=season_hint)
exec
/bin/zsh -lc "sed -n '560,660p' pipeline/predict.py" in /Users/jameswest/Desktop/nfl_predict succeeded in 778ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
        .with_columns(pl.col("game_date").cast(pl.Datetime("ms")))
        .sort(["player_id", "game_date"])
        .group_by("player_id", maintain_order=True)
        .agg([pl.col(col).last().alias(col) for col in required_cols if col not in {"player_id", "game_date"}])
        .collect()
    )
    return df


def _load_opponent_split_features(seasons: Iterable[int]) -> pl.DataFrame:
    """
    Mirror the rolling opponent-level defensive splits that were used during training.
    """
    df = load_rolling_opponent_splits(list(seasons), windows=[3])
    if df.is_empty():
        return df
    df = df.with_columns(
        [
            pl.col("season").cast(pl.Int32),

thinking
**Prioritizing classification improvements and test additions**

I’m thinking it’s best to focus on classification pipeline upgrades around using predict_proba properly and metadata-driven config, while postponing full baseline and ps_game_ name integration due to complexity. I’ll also plan adding tests to ensure no duplicate feature names and validate correct use of predict_proba, checking existing test setups to build on them effectively.
exec
/bin/zsh -lc 'ls tests' in /Users/jameswest/Desktop/nfl_predict succeeded in 774ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
__pycache__
cache
conftest.py
data
output
test_data_leak_guard.py
test_offense_context.py
test_role_flags.py
test_rolling_window_extended.py
test_training_config_features.py
test_tuning_config.py
test_weather_features.py

thinking
**Planning config deduplication and tests**
exec
/bin/zsh -lc "sed -n '1,200p' tests/test_training_config_features.py" in /Users/jameswest/Desktop/nfl_predict succeeded in 764ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
from pathlib import Path
from typing import Dict, List

import polars as pl
import pytest
import yaml

from utils.general.constants import LEAK_PRONE_COLUMNS


def _load_training_config() -> Dict:
    config_path = Path(__file__).resolve().parents[1] / "config" / "training.yaml"
    with config_path.open("r") as fh:
        return yaml.safe_load(fh)


def test_training_config_feature_guards():
    """Ensure columns_to_discard and other_features_to_include don't overlap."""
    training_cfg = _load_training_config()

thinking
**Planning tests and feature prefix updates**

I’m outlining tasks to add classification metadata, deduplicate config blocks, and write tests for duplicate problem names and classification probability usage. Also, I’m considering renaming certain features with a ps_game_ prefix for clarity while maintaining backward compatibility by aliasing old names. This involves updating feature lists and carefully modifying code to avoid breaking functionality.

thinking
**Noticing incomplete input**
exec
/bin/zsh -lc 'rg -n "PRE_SNAP_ROLLING_TARGETS" utils/feature/player_game_level.py' in /Users/jameswest/Desktop/nfl_predict succeeded in 725ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
158:PRE_SNAP_ROLLING_TARGETS = [
1584:    if PRE_SNAP_ROLLING_TARGETS:
1593:                for col in PRE_SNAP_ROLLING_TARGETS
1604:                for col in PRE_SNAP_ROLLING_TARGETS
exec
/bin/zsh -lc "sed -n '1560,1625p' utils/feature/player_game_level.py" in /Users/jameswest/Desktop/nfl_predict succeeded in 771ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
    # Combine all player roles
    df_all = pl.concat(player_games, how="diagonal")
    
    # Merge rows where same player had multiple roles in same game
    # (e.g., QB who also rushed, WR who also rushed)
    df_merged = _merge_multi_role_players(df_all)

    df_merged = _append_zero_usage_players(df_merged, seasons_in_window)
    
    pre_snap_usage = _compute_pre_snap_usage(df)
    if not pre_snap_usage.is_empty():
        df_merged = df_merged.join(
            pre_snap_usage, on=["season", "week", "team", "player_id"], how="left"
        )
    for col in PRE_SNAP_BASE_COLUMNS:
        if col in df_merged.columns:
            df_merged = df_merged.with_columns(
                pl.col(col).fill_null(0).cast(pl.Float32).alias(col)
            )

thinking
**Searching for PRE_SNAP_BASE_COLUMNS definition**
exec
/bin/zsh -lc 'rg -n "PRE_SNAP_BASE_COLUMNS" utils/feature/player_game_level.py' in /Users/jameswest/Desktop/nfl_predict succeeded in 720ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
141:PRE_SNAP_BASE_COLUMNS = [
1574:    for col in PRE_SNAP_BASE_COLUMNS:
exec
/bin/zsh -lc "sed -n '120,170p' utils/feature/player_game_level.py" in /Users/jameswest/Desktop/nfl_predict succeeded in 721ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
def _collect_partition_paths(base_dir: Path, seasons: list[int]) -> list[Path]:
    paths: List[Path] = []
    for season in sorted({int(s) for s in seasons}):
        season_dir = base_dir / f"season={season}"
        if not season_dir.exists():
            continue
        paths.extend(sorted(season_dir.glob("week=*/part.parquet")))
    return paths


SKILL_POSITIONS = {"WR", "TE", "RB", "HB", "FB"}
ALIGNMENT_ORDER = ["slot", "wide", "inline", "backfield"]
SLOT_ROUTE_CUES = {
    "SLANT",
    "IN/DIG",
    "SHALLOW CROSS/DRAG",
    "SCREEN",
    "QUICK OUT",
    "HITCH/CURL",

thinking
**Analyzing feature leakage risks**

thinking
**Planning feature renaming and aliasing**

thinking
**Revising feature renaming and aliases**

thinking
**Planning pre-snap hist feature aliases**

thinking
**Planning target column aliasing and feature updates**

I'm figuring out how to rename target columns to new aliases like `ps_game_scripted_touches` while keeping consistency across config, training, and inference modules. I'll consider which parts need updating—especially around feature composition and dataset creation—and think about adding tests to catch inconsistencies with these new `ps_game_` prefixes. I'll make sure new aliases get created without duplicating data unnecessarily.

thinking
**Planning feature aliasing and column updates**
exec
/bin/zsh -lc 'rg "ps_route_participation_pct_prev"' in /Users/jameswest/Desktop/nfl_predict succeeded in 1.10s:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
codex_output.md:pipeline/predict.py:    "ps_route_participation_pct_prev",
codex_output.md:pipeline/predict.py:    "ps_route_participation_pct_prev",
codex_output.md:pipeline/predict.py:    "ps_route_participation_pct_prev",
codex_output.md:pipeline/predict.py:    "ps_route_participation_pct_prev",
codex_output.md:pipeline/predict.py:    "ps_route_participation_pct_prev",
codex_output.md:pipeline/predict.py:    "ps_route_participation_pct_prev",
codex_output.md:pipeline/predict.py:    "ps_route_participation_pct_prev",
pipeline/predict.py:    "ps_route_participation_pct_prev",

thinking
**Inspecting training config anchors**
exec
/bin/zsh -lc "sed -n '1,140p' config/training.yaml" in /Users/jameswest/Desktop/nfl_predict succeeded in 853ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
# config/training.yaml
# Configuration for the model training pipeline (pipeline/train.py)
# NFL Player Prediction Targets

# --- Data I/O ---
data:
  raw_pbp_dir: 'data/raw/pbp_by_day'  # NFL play-by-play raw data
  feature_matrix_path: 'data/processed/final/processed.parquet'  # NFL feature matrix
  
  # Directory to save trained model artifacts (models and feature lists).
  model_output_dir: 'output/models'
  
  # Directory to save evaluation reports and metrics.
  metrics_output_dir: 'output/metrics/'

# =============================================================================
# SHARED COLUMN DEFINITIONS (using YAML anchors to avoid duplication)
# =============================================================================
# These columns leak same-game outcomes and must be excluded from training.

thinking
**Organizing plan for feature and config updates**

I’m outlining a plan with four steps to carefully update feature naming, fix classification pipelines, deduplicate config, and introduce aliases to prevent data leakage, balancing scope with manageability. I'll use the planning tool to keep track and ensure tests guard against regressions.
Plan update
Implement Tier-1 essentials we can reasonably cover this run: (a) make pre-snap features explicitly same-game vs historical and avoid leakage, (b) fix classifier probability semantics, (c) dedupe TD config / add config hygiene tests.
  • Add ps_game aliases for realized pre-snap stats, create ps_hist rolling aliases, and switch training/prediction to consume ps_hist while excluding ps_game/same-game columns.
  • Standardize classification outputs: persist task metadata in artifacts and always use predict_proba for classification problems in inference.
  • Clean TD config duplication and add config/tests for uniqueness/leakage guards (e.g., no duplicate problem names, ps_game not in features).

thinking
**Planning PS_GAME alias implementation**
exec
/bin/zsh -lc 'rg -n "LEAK_PRONE_COLUMNS" -n utils/general/constants.py' in /Users/jameswest/Desktop/nfl_predict succeeded in 815ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
8:config/training.yaml should mirror LEAK_PRONE_COLUMNS for YAML-based configuration,
113:LEAK_PRONE_COLUMNS: Tuple[str, ...] = (
208:    "LEAK_PRONE_COLUMNS",
exec
/bin/zsh -lc "sed -n '100,140p' utils/general/constants.py" in /Users/jameswest/Desktop/nfl_predict succeeded in 725ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
}


# =============================================================================
# Leak-Prone Columns (Same-Game Outcomes)
# =============================================================================
# Stats that leak same-game outcomes and must be excluded from training features.
# These represent what happened in the game we're trying to predict.
#
# This is the AUTHORITATIVE definition. config/training.yaml mirrors this list
# using YAML anchors for per-problem configuration. Keep them in sync!
# Validated by: tests/test_training_config_features.py

LEAK_PRONE_COLUMNS: Tuple[str, ...] = (
    # Yardage (same-game outcomes)
    "passing_yards",
    "rushing_yards",
    "receiving_yards",
    # Usage counts (same-game outcomes)

thinking
**Evaluating leak-prone feature handling**
exec
/bin/zsh -lc 'rg -n "_apply_problem_level_overrides" pipeline/train.py' in /Users/jameswest/Desktop/nfl_predict succeeded in 848ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
688:    def _apply_problem_level_overrides(self, df: pd.DataFrame, problem_config: dict) -> pd.DataFrame:
2271:            df_problem = self._apply_problem_level_overrides(df_problem, problem_copy)
exec
/bin/zsh -lc "sed -n '660,750p' pipeline/train.py" in /Users/jameswest/Desktop/nfl_predict succeeded in 754ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
            df["expected_rz_td_signal"] = df["pred_efficiency_tds"] * df["expected_rz_opportunities"]
        if "pred_efficiency_tds" in df.columns and "expected_rz_opportunities_raw" in df.columns:
            df["expected_rz_td_signal_raw"] = df["pred_efficiency_tds"] * df["expected_rz_opportunities_raw"]

        if "pred_efficiency_rec_yards" in df.columns:
            df["expected_receiving_yards"] = (
                pd.to_numeric(df["pred_efficiency_rec_yards"], errors="coerce")
                .clip(lower=0.0)
            )
        if "pred_efficiency_rush_yards" in df.columns:
            df["expected_rushing_yards"] = (
                pd.to_numeric(df["pred_efficiency_rush_yards"], errors="coerce")
                .clip(lower=0.0)
            )
        if "expected_receiving_yards" in df.columns and "expected_rushing_yards" in df.columns:
            df["expected_total_yards"] = df["expected_receiving_yards"] + df["expected_rushing_yards"]

        if "expected_td_signal" in df.columns and "expected_td_prob_poisson" not in df.columns:
            df["expected_td_prob_poisson"] = 1.0 - np.exp(-df["expected_td_signal"].clip(lower=0.0))

thinking
**Analyzing feature selection impact**

thinking
**Adjusting feature aliasing and prefixes**

thinking
**Evaluating feature discard strategy**

thinking
**Investigating columns_to_discard usage**
exec
/bin/zsh -lc 'rg -n "columns_to_discard" pipeline/train.py' in /Users/jameswest/Desktop/nfl_predict exited 1 in 881ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted

thinking
**Searching for feature_artifacts usage**
exec
/bin/zsh -lc 'rg -n "columns_to_discard"' in /Users/jameswest/Desktop/nfl_predict succeeded in 840ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
docs/monitoring.md:4:- `tests/test_training_config_features.py` ensures `columns_to_discard` never overlaps with `other_features_to_include` and enforces snapshot coverage thresholds.
tests/test_training_config_features.py:18:    """Ensure columns_to_discard and other_features_to_include don't overlap."""
tests/test_training_config_features.py:26:        discard = set(problem.get("columns_to_discard", []))
tests/test_training_config_features.py:31:        ), f"columns_to_discard and other_features_to_include intersect for '{name}': {sorted(intersection)}"
tests/test_training_config_features.py:45:    # Get the shared columns_to_discard from any problem that uses the anchor
tests/test_training_config_features.py:49:        discard = problem.get("columns_to_discard", [])
tests/test_training_config_features.py:97:        discard = set(problem.get("columns_to_discard", []))
docs/train.md:114:    columns_to_discard: []
utils/train/feature_artifacts.py:27:    discard_cols = set(problem_config.get("columns_to_discard") or [])
exec
/bin/zsh -lc "sed -n '1,120p' utils/train/feature_artifacts.py" in /Users/jameswest/Desktop/nfl_predict succeeded in 888ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
from __future__ import annotations

import logging
from dataclasses import dataclass
from typing import Dict, List, Tuple

import numpy as np
import pandas as pd

logger = logging.getLogger(__name__)


@dataclass
class FeatureArtifacts:
    feature_columns: List[str]
    datetime_features: List[str]
    categorical_features: List[str]
    category_levels: Dict[str, List[str]]


thinking
**Planning feature alias additions and updates**

thinking
**Preparing aliases for ps_game columns**
file update
M /Users/jameswest/Desktop/nfl_predict/utils/feature/player_game_level.py
@@ -165,2 +165,9 @@
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
@@ -3318,2 +3325 @@
     return merged
-
apply_patch(auto_approved=true) exited 0 in 37ms:
Success. Updated the following files:
M utils/feature/player_game_level.py
file update:
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..9a100b4affcfc9ba54b3d4a910fb68e3a861d688
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -163,6 +163,13 @@
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -3316,4 +3323,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-

file update:
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..9a100b4affcfc9ba54b3d4a910fb68e3a861d688
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -163,6 +163,13 @@
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -3316,4 +3323,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-


thinking
**Updating method to add alias after numeric fill**
file update
M /Users/jameswest/Desktop/nfl_predict/utils/feature/player_game_level.py
@@ -503,2 +503,12 @@
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
apply_patch(auto_approved=true) exited 0 in 31ms:
Success. Updated the following files:
M utils/feature/player_game_level.py
file update:
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..d07be9ced88b7199e5caccd032534909ce2369e3
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -163,6 +163,13 @@
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +501,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -3316,4 +3333,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-

file update:
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..d07be9ced88b7199e5caccd032534909ce2369e3
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -163,6 +163,13 @@
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +501,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -3316,4 +3333,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-


thinking
**Adding alias for historical features**
file update
M /Users/jameswest/Desktop/nfl_predict/utils/feature/player_game_level.py
@@ -1623,2 +1623,10 @@
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
apply_patch(auto_approved=true) exited 0 in 35ms:
Success. Updated the following files:
M utils/feature/player_game_level.py
file update:
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..176b22ad3803344e66eb419ebab8345efa8ab94f
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -163,6 +163,13 @@
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +501,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1604,6 +1621,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3341,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-

file update:
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..176b22ad3803344e66eb419ebab8345efa8ab94f
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -163,6 +163,13 @@
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +501,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1604,6 +1621,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3341,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-


thinking
**Ensuring ps_game aliases in final dataframe**
file update
M /Users/jameswest/Desktop/nfl_predict/utils/feature/player_game_level.py
@@ -1599,2 +1599,9 @@
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
apply_patch(auto_approved=true) exited 0 in 32ms:
Success. Updated the following files:
M utils/feature/player_game_level.py
file update:
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..4814be8ecf3b8fbf719ce6de4403b5f50fddfca0
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -163,6 +163,13 @@
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +501,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1597,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1628,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3348,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-

file update:
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..4814be8ecf3b8fbf719ce6de4403b5f50fddfca0
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -163,6 +163,13 @@
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +501,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1597,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1628,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3348,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-


thinking
**Aligning historical alias naming conventions**

thinking
**Evaluating feature aliasing and rolling targets**

thinking
**Revising feature aliasing and rolling targets**

thinking
**Updating target and alignment metrics list**
file update
M /Users/jameswest/Desktop/nfl_predict/utils/feature/player_game_level.py
@@ -159,3 +159,11 @@
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
apply_patch(auto_approved=true) exited 0 in 33ms:
Success. Updated the following files:
M utils/feature/player_game_level.py
file update:
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-

file update:
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-


thinking
**Adjusting histogram alias and rename mapping**

thinking
**Analyzing ROLLING_FEATURE_STATS updates**

thinking
**Revising feature aliasing to prevent data leakage**

thinking
**Modifying rolling feature stats**
file update
M /Users/jameswest/Desktop/nfl_predict/utils/feature/stats.py
@@ -106,2 +106,17 @@
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
apply_patch(auto_approved=true) exited 0 in 41ms:
Success. Updated the following files:
M utils/feature/stats.py
file update:
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations

file update:
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations


thinking
**Modifying rename_map with patch**

thinking
**Reviewing feature key mappings**
file update
M /Users/jameswest/Desktop/nfl_predict/pipeline/predict.py
@@ -1316,25 +1316,31 @@
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
apply_patch(auto_approved=true) exited 0 in 54ms:
Success. Updated the following files:
M pipeline/predict.py
file update:
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..8878ee48934ab5b6e88456e90dd1155037a94143
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations

file update:
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..8878ee48934ab5b6e88456e90dd1155037a94143
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations


thinking
**Removing ps_prev_exprs block**
file update
M /Users/jameswest/Desktop/nfl_predict/pipeline/predict.py
@@ -1377,24 +1377,2 @@
 
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
-
     cutoff_hours = float(get_decision_cutoff_hours())
apply_patch(auto_approved=true) exited 0 in 54ms:
Success. Updated the following files:
M pipeline/predict.py
file update:
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..9e06ebfd37ff5aa9bd4e673065efd9431a5fe76a
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1368,28 +1374,6 @@
     ]
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
-
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
 
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations

file update:
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..9e06ebfd37ff5aa9bd4e673065efd9431a5fe76a
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1368,28 +1374,6 @@
     ]
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
-
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
 
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations


thinking
**Updating leak-prone columns with ps_game features**

I'm ensuring that new ps_game_* features are added to the leak-prone columns constants and config, alongside their base counterparts, to prevent unintended usage during inference. I'll carefully place these in the constants tuple, update related YAML anchors, and adjust tests to keep everything consistent.
file update
M /Users/jameswest/Desktop/nfl_predict/utils/general/constants.py
@@ -143,2 +143,33 @@
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
@@ -216,2 +247 @@
 ]
-
apply_patch(auto_approved=true) exited 0 in 63ms:
Success. Updated the following files:
M utils/general/constants.py
file update:
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..9e06ebfd37ff5aa9bd4e673065efd9431a5fe76a
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1368,28 +1374,6 @@
     ]
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
-
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
 
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-

file update:
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..9e06ebfd37ff5aa9bd4e673065efd9431a5fe76a
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1368,28 +1374,6 @@
     ]
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
-
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
 
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-


thinking
**Updating training config anchors**
file update
M /Users/jameswest/Desktop/nfl_predict/config/training.yaml
@@ -50,2 +50,33 @@
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
@@ -79,2 +110,33 @@
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
apply_patch(auto_approved=true) exited 0 in 73ms:
Success. Updated the following files:
M config/training.yaml
file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..c20cfce434e43455952b355d1bbe23cd2edb1cec
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..9e06ebfd37ff5aa9bd4e673065efd9431a5fe76a
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1368,28 +1374,6 @@
     ]
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
-
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
 
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-

file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..c20cfce434e43455952b355d1bbe23cd2edb1cec
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..9e06ebfd37ff5aa9bd4e673065efd9431a5fe76a
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1368,28 +1374,6 @@
     ]
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
-
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
 
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-


thinking
**Updating prefixes and targets in configs**

I'm systematically renaming pre-snap target columns and feature prefixes in the config and training sections to use 'ps_game_' for targets and 'ps_hist_' for features. I’ll carefully replace old prefixes like 'ps_route_participation_' and 'ps_targets_' with these new ones and adjust various model config blocks accordingly, applying patches where needed.
file update
M /Users/jameswest/Desktop/nfl_predict/config/training.yaml
@@ -239,3 +239,3 @@
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
@@ -244,4 +244,3 @@
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
apply_patch(auto_approved=true) exited 0 in 80ms:
Success. Updated the following files:
M config/training.yaml
file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..81d4ba630cf7d6a5b936434c225c0ca5054e26ad
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..9e06ebfd37ff5aa9bd4e673065efd9431a5fe76a
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1368,28 +1374,6 @@
     ]
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
-
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
 
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-

file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..81d4ba630cf7d6a5b936434c225c0ca5054e26ad
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..9e06ebfd37ff5aa9bd4e673065efd9431a5fe76a
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1368,28 +1374,6 @@
     ]
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
-
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
 
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-


thinking
**Patching pre_snap_scripted_touches block**
file update
M /Users/jameswest/Desktop/nfl_predict/config/training.yaml
@@ -263,3 +263,3 @@
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
@@ -268,6 +268,3 @@
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
apply_patch(auto_approved=true) exited 0 in 81ms:
Success. Updated the following files:
M config/training.yaml
file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..2a2f50257f7621798f6904b5d8b571e5306af6a2
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..9e06ebfd37ff5aa9bd4e673065efd9431a5fe76a
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1368,28 +1374,6 @@
     ]
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
-
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
 
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-

file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..2a2f50257f7621798f6904b5d8b571e5306af6a2
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..9e06ebfd37ff5aa9bd4e673065efd9431a5fe76a
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1368,28 +1374,6 @@
     ]
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
-
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
 
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-


thinking
**Updating usage_targets block**
file update
M /Users/jameswest/Desktop/nfl_predict/config/training.yaml
@@ -292,4 +292,3 @@
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
apply_patch(auto_approved=true) exited 0 in 78ms:
Success. Updated the following files:
M config/training.yaml
file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..2e8d6c2e63fbd5139cebb07ee7bea1e1483e5409
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..9e06ebfd37ff5aa9bd4e673065efd9431a5fe76a
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1368,28 +1374,6 @@
     ]
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
-
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
 
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-

file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..2e8d6c2e63fbd5139cebb07ee7bea1e1483e5409
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..9e06ebfd37ff5aa9bd4e673065efd9431a5fe76a
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1368,28 +1374,6 @@
     ]
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
-
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
 
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-


thinking
**Updating usage_carries block**
file update
M /Users/jameswest/Desktop/nfl_predict/config/training.yaml
@@ -326,3 +326,3 @@
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
apply_patch(auto_approved=true) exited 0 in 77ms:
Success. Updated the following files:
M config/training.yaml
file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..5a38d6818b7a535c86ebc4462cea09aeec56c896
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..9e06ebfd37ff5aa9bd4e673065efd9431a5fe76a
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1368,28 +1374,6 @@
     ]
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
-
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
 
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-

file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..5a38d6818b7a535c86ebc4462cea09aeec56c896
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..9e06ebfd37ff5aa9bd4e673065efd9431a5fe76a
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1368,28 +1374,6 @@
     ]
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
-
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
 
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-


thinking
**Updating efficiency_rec_yards block**
file update
M /Users/jameswest/Desktop/nfl_predict/config/training.yaml
@@ -366,4 +366,3 @@
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
apply_patch(auto_approved=true) exited 0 in 72ms:
Success. Updated the following files:
M config/training.yaml
file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..67c82ae76d96ebcfd5b63df765dd718cb043ba0f
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..9e06ebfd37ff5aa9bd4e673065efd9431a5fe76a
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1368,28 +1374,6 @@
     ]
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
-
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
 
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-

file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..67c82ae76d96ebcfd5b63df765dd718cb043ba0f
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..9e06ebfd37ff5aa9bd4e673065efd9431a5fe76a
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1368,28 +1374,6 @@
     ]
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
-
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
 
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-


thinking
**Updating efficiency block references**
file update
M /Users/jameswest/Desktop/nfl_predict/config/training.yaml
@@ -403,3 +403,3 @@
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
apply_patch(auto_approved=true) exited 0 in 75ms:
Success. Updated the following files:
M config/training.yaml
file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..165d6021220f3bfc271efa4080b2d5ec1fe9abd8
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..9e06ebfd37ff5aa9bd4e673065efd9431a5fe76a
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1368,28 +1374,6 @@
     ]
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
-
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
 
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-

file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..165d6021220f3bfc271efa4080b2d5ec1fe9abd8
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..9e06ebfd37ff5aa9bd4e673065efd9431a5fe76a
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1368,28 +1374,6 @@
     ]
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
-
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
 
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-


thinking
**Searching for references to old target names**
exec
/bin/zsh -lc 'rg "ps_scripted_touches"' in /Users/jameswest/Desktop/nfl_predict succeeded in 780ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
utils/general/constants.py:    "ps_scripted_touches",
pipeline/predict.py:    "ps_scripted_touches",
pipeline/predict.py:        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
pipeline/predict.py:        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
utils/feature/player_game_level.py:    "ps_scripted_touches",
utils/feature/player_game_level.py:    "ps_scripted_touches",
utils/feature/player_game_level.py:                    "ps_scripted_touches"
utils/feature/player_game_level.py:            .then(pl.col("ps_scripted_touches") / pl.col("ps_total_touches"))
utils/feature/stats.py:    "ps_scripted_touches",
file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..165d6021220f3bfc271efa4080b2d5ec1fe9abd8
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..9e06ebfd37ff5aa9bd4e673065efd9431a5fe76a
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1368,28 +1374,6 @@
     ]
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
-
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
 
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-


thinking
**Reviewing feature aliases and dataset consistency**

I'm making sure the dataset and training configs consistently use new aliases like `ps_game_scripted_touches` and `ps_hist_` prefixes for features, while considering fallback options and adjusting tests accordingly. I’m verifying that both training and inference datasets include these updated columns and that artifacts don’t rely on outdated base columns.

thinking
**Verifying new column usage and adjusting aliases**

thinking
**Enhancing prediction pipeline with metadata handling**

thinking
**Enhancing inference artifact saving**

I'm updating the save_inference_artifacts function to include task_type and output_mode in its payload, deriving them from problem_config. I plan to set output_mode based on task_type—defaulting to "probability" for classification tasks and "value" otherwise—and adjust the function signature and internals accordingly to support classification probability semantics.
file update
M /Users/jameswest/Desktop/nfl_predict/utils/train/persist.py
@@ -53,2 +53,13 @@
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
@@ -58,2 +69,4 @@
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
apply_patch(auto_approved=true) exited 0 in 90ms:
Success. Updated the following files:
M utils/train/persist.py
file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..165d6021220f3bfc271efa4080b2d5ec1fe9abd8
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..9e06ebfd37ff5aa9bd4e673065efd9431a5fe76a
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1368,28 +1374,6 @@
     ]
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
-
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
 
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..24e8f6c7632520e261b71b215b52aca745af4f8d
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -51,11 +51,24 @@
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync

file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..165d6021220f3bfc271efa4080b2d5ec1fe9abd8
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..9e06ebfd37ff5aa9bd4e673065efd9431a5fe76a
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1368,28 +1374,6 @@
     ]
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
-
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
 
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..24e8f6c7632520e261b71b215b52aca745af4f8d
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -51,11 +51,24 @@
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync


thinking
**Updating function signature with type union**
file update
M /Users/jameswest/Desktop/nfl_predict/utils/train/persist.py
@@ -46,3 +46,3 @@
 
-def save_inference_artifacts(trainer, problem_name: str) -> None:
+def save_inference_artifacts(trainer, problem_name: str, problem_config: dict | None = None) -> None:
     # Versioned artifact copy
apply_patch(auto_approved=true) exited 0 in 101ms:
Success. Updated the following files:
M utils/train/persist.py
file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..165d6021220f3bfc271efa4080b2d5ec1fe9abd8
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..9e06ebfd37ff5aa9bd4e673065efd9431a5fe76a
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1368,28 +1374,6 @@
     ]
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
-
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
 
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..eb5471f38ae1512ba5cabf81e6baf81aab0e986b
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -44,18 +44,31 @@
             formatted[k] = v
     return formatted
 
-def save_inference_artifacts(trainer, problem_name: str) -> None:
+def save_inference_artifacts(trainer, problem_name: str, problem_config: dict | None = None) -> None:
     # Versioned artifact copy
     v_dir = _vdir(trainer, problem_name, None, "artifacts") / "inference"
     v_dir.mkdir(parents=True, exist_ok=True)
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync

file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..165d6021220f3bfc271efa4080b2d5ec1fe9abd8
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..9e06ebfd37ff5aa9bd4e673065efd9431a5fe76a
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1368,28 +1374,6 @@
     ]
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
-
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
 
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..eb5471f38ae1512ba5cabf81e6baf81aab0e986b
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -44,18 +44,31 @@
             formatted[k] = v
     return formatted
 
-def save_inference_artifacts(trainer, problem_name: str) -> None:
+def save_inference_artifacts(trainer, problem_name: str, problem_config: dict | None = None) -> None:
     # Versioned artifact copy
     v_dir = _vdir(trainer, problem_name, None, "artifacts") / "inference"
     v_dir.mkdir(parents=True, exist_ok=True)
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync


thinking
**Updating pipeline/train call sites for problem config**
exec
/bin/zsh -lc "rg -n \"save_inference_artifacts\\(self, problem_name\" pipeline/train.py" in /Users/jameswest/Desktop/nfl_predict succeeded in 909ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
2076:        save_inference_artifacts(self, problem_name)
2337:                save_inference_artifacts(self, problem_name)
file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..165d6021220f3bfc271efa4080b2d5ec1fe9abd8
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..9e06ebfd37ff5aa9bd4e673065efd9431a5fe76a
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1368,28 +1374,6 @@
     ]
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
-
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
 
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..eb5471f38ae1512ba5cabf81e6baf81aab0e986b
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -44,18 +44,31 @@
             formatted[k] = v
     return formatted
 
-def save_inference_artifacts(trainer, problem_name: str) -> None:
+def save_inference_artifacts(trainer, problem_name: str, problem_config: dict | None = None) -> None:
     # Versioned artifact copy
     v_dir = _vdir(trainer, problem_name, None, "artifacts") / "inference"
     v_dir.mkdir(parents=True, exist_ok=True)
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync


thinking
**Applying patch changes**
file update
M /Users/jameswest/Desktop/nfl_predict/pipeline/train.py
@@ -2075,3 +2075,3 @@
         # This ensures the state (imputation, categories) is from the pre-tuning/pre-holdout phase.
-        save_inference_artifacts(self, problem_name)
+        save_inference_artifacts(self, problem_name, problem_copy)
 
@@ -2699,2 +2699,2 @@
         logger.critical(f"The pipeline has failed with a critical error: {e}", exc_info=True)
-        sys.exit(1)
\ No newline at end of file
+        sys.exit(1)
apply_patch(auto_approved=true) exited 0 in 92ms:
Success. Updated the following files:
M pipeline/train.py
file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..165d6021220f3bfc271efa4080b2d5ec1fe9abd8
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..9e06ebfd37ff5aa9bd4e673065efd9431a5fe76a
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1368,28 +1374,6 @@
     ]
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
-
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
 
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
diff --git a/pipeline/train.py b/pipeline/train.py
index 2e2508f5ee50bf4b1877b56465304ecac80dc0bb..4f6e658bf053a0facee243631a64ff25c60a275c
--- a/pipeline/train.py
+++ b/pipeline/train.py
@@ -2073,7 +2073,7 @@
 
         # --- Save inference artifacts AFTER all models for the problem are trained ---
         # This ensures the state (imputation, categories) is from the pre-tuning/pre-holdout phase.
-        save_inference_artifacts(self, problem_name)
+        save_inference_artifacts(self, problem_name, problem_copy)
 
     def _unwrap_base_model(self, model):
         """Return the true fitted estimator, no matter how it's wrapped."""
@@ -2697,4 +2697,4 @@
             train(config_path=args.config, ordinal_only=args.ordinal_only, ordinal_ev=ordinal_ev_flag, **overrides)
     except Exception as e:
         logger.critical(f"The pipeline has failed with a critical error: {e}", exc_info=True)
-        sys.exit(1)
\ No newline at end of file
+        sys.exit(1)
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..eb5471f38ae1512ba5cabf81e6baf81aab0e986b
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -44,18 +44,31 @@
             formatted[k] = v
     return formatted
 
-def save_inference_artifacts(trainer, problem_name: str) -> None:
+def save_inference_artifacts(trainer, problem_name: str, problem_config: dict | None = None) -> None:
     # Versioned artifact copy
     v_dir = _vdir(trainer, problem_name, None, "artifacts") / "inference"
     v_dir.mkdir(parents=True, exist_ok=True)
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync

file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..165d6021220f3bfc271efa4080b2d5ec1fe9abd8
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..9e06ebfd37ff5aa9bd4e673065efd9431a5fe76a
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1368,28 +1374,6 @@
     ]
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
-
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
 
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
diff --git a/pipeline/train.py b/pipeline/train.py
index 2e2508f5ee50bf4b1877b56465304ecac80dc0bb..4f6e658bf053a0facee243631a64ff25c60a275c
--- a/pipeline/train.py
+++ b/pipeline/train.py
@@ -2073,7 +2073,7 @@
 
         # --- Save inference artifacts AFTER all models for the problem are trained ---
         # This ensures the state (imputation, categories) is from the pre-tuning/pre-holdout phase.
-        save_inference_artifacts(self, problem_name)
+        save_inference_artifacts(self, problem_name, problem_copy)
 
     def _unwrap_base_model(self, model):
         """Return the true fitted estimator, no matter how it's wrapped."""
@@ -2697,4 +2697,4 @@
             train(config_path=args.config, ordinal_only=args.ordinal_only, ordinal_ev=ordinal_ev_flag, **overrides)
     except Exception as e:
         logger.critical(f"The pipeline has failed with a critical error: {e}", exc_info=True)
-        sys.exit(1)
\ No newline at end of file
+        sys.exit(1)
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..eb5471f38ae1512ba5cabf81e6baf81aab0e986b
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -44,18 +44,31 @@
             formatted[k] = v
     return formatted
 
-def save_inference_artifacts(trainer, problem_name: str) -> None:
+def save_inference_artifacts(trainer, problem_name: str, problem_config: dict | None = None) -> None:
     # Versioned artifact copy
     v_dir = _vdir(trainer, problem_name, None, "artifacts") / "inference"
     v_dir.mkdir(parents=True, exist_ok=True)
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync


thinking
**Applying second patch**
file update
M /Users/jameswest/Desktop/nfl_predict/pipeline/train.py
@@ -2336,3 +2336,3 @@
                 self._fit_feature_artifacts(df_train, problem_copy)
-                save_inference_artifacts(self, problem_name)
+                save_inference_artifacts(self, problem_name, problem_copy)
 
apply_patch(auto_approved=true) exited 0 in 380ms:
Success. Updated the following files:
M pipeline/train.py
file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..165d6021220f3bfc271efa4080b2d5ec1fe9abd8
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..9e06ebfd37ff5aa9bd4e673065efd9431a5fe76a
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1368,28 +1374,6 @@
     ]
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
-
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
 
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
diff --git a/pipeline/train.py b/pipeline/train.py
index 2e2508f5ee50bf4b1877b56465304ecac80dc0bb..30c70ab8292088cc8aad350882ef2c5e8cc7efa6
--- a/pipeline/train.py
+++ b/pipeline/train.py
@@ -2073,7 +2073,7 @@
 
         # --- Save inference artifacts AFTER all models for the problem are trained ---
         # This ensures the state (imputation, categories) is from the pre-tuning/pre-holdout phase.
-        save_inference_artifacts(self, problem_name)
+        save_inference_artifacts(self, problem_name, problem_copy)
 
     def _unwrap_base_model(self, model):
         """Return the true fitted estimator, no matter how it's wrapped."""
@@ -2334,7 +2334,7 @@
                     logger.warning("Failed to initialise team total scaling for %s: %s", problem_name, exc)
             if not use_cached_for_problem:
                 self._fit_feature_artifacts(df_train, problem_copy)
-                save_inference_artifacts(self, problem_name)
+                save_inference_artifacts(self, problem_name, problem_copy)
 
             # Log final feature list used
             logger.info(f"--- Using {len(self.feature_columns)} features for {problem_name} ---")
@@ -2697,4 +2697,4 @@
             train(config_path=args.config, ordinal_only=args.ordinal_only, ordinal_ev=ordinal_ev_flag, **overrides)
     except Exception as e:
         logger.critical(f"The pipeline has failed with a critical error: {e}", exc_info=True)
-        sys.exit(1)
\ No newline at end of file
+        sys.exit(1)
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..eb5471f38ae1512ba5cabf81e6baf81aab0e986b
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -44,18 +44,31 @@
             formatted[k] = v
     return formatted
 
-def save_inference_artifacts(trainer, problem_name: str) -> None:
+def save_inference_artifacts(trainer, problem_name: str, problem_config: dict | None = None) -> None:
     # Versioned artifact copy
     v_dir = _vdir(trainer, problem_name, None, "artifacts") / "inference"
     v_dir.mkdir(parents=True, exist_ok=True)
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync

file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..165d6021220f3bfc271efa4080b2d5ec1fe9abd8
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..9e06ebfd37ff5aa9bd4e673065efd9431a5fe76a
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1368,28 +1374,6 @@
     ]
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
-
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
 
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
diff --git a/pipeline/train.py b/pipeline/train.py
index 2e2508f5ee50bf4b1877b56465304ecac80dc0bb..30c70ab8292088cc8aad350882ef2c5e8cc7efa6
--- a/pipeline/train.py
+++ b/pipeline/train.py
@@ -2073,7 +2073,7 @@
 
         # --- Save inference artifacts AFTER all models for the problem are trained ---
         # This ensures the state (imputation, categories) is from the pre-tuning/pre-holdout phase.
-        save_inference_artifacts(self, problem_name)
+        save_inference_artifacts(self, problem_name, problem_copy)
 
     def _unwrap_base_model(self, model):
         """Return the true fitted estimator, no matter how it's wrapped."""
@@ -2334,7 +2334,7 @@
                     logger.warning("Failed to initialise team total scaling for %s: %s", problem_name, exc)
             if not use_cached_for_problem:
                 self._fit_feature_artifacts(df_train, problem_copy)
-                save_inference_artifacts(self, problem_name)
+                save_inference_artifacts(self, problem_name, problem_copy)
 
             # Log final feature list used
             logger.info(f"--- Using {len(self.feature_columns)} features for {problem_name} ---")
@@ -2697,4 +2697,4 @@
             train(config_path=args.config, ordinal_only=args.ordinal_only, ordinal_ev=ordinal_ev_flag, **overrides)
     except Exception as e:
         logger.critical(f"The pipeline has failed with a critical error: {e}", exc_info=True)
-        sys.exit(1)
\ No newline at end of file
+        sys.exit(1)
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..eb5471f38ae1512ba5cabf81e6baf81aab0e986b
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -44,18 +44,31 @@
             formatted[k] = v
     return formatted
 
-def save_inference_artifacts(trainer, problem_name: str) -> None:
+def save_inference_artifacts(trainer, problem_name: str, problem_config: dict | None = None) -> None:
     # Versioned artifact copy
     v_dir = _vdir(trainer, problem_name, None, "artifacts") / "inference"
     v_dir.mkdir(parents=True, exist_ok=True)
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync


thinking
**Updating prediction function with metadata support**

I'm revising the `_predict_for_problem` function to accept `problem_config` alongside artifacts, enabling better use of metadata like task type and output mode. I'll add logic to identify classification tasks reliably, handle probabilities when available, and retain threshold and feature preparation as before. This should make prediction more flexible and accurate.

thinking
**Updating _predict_for_problem signature**
file update
M /Users/jameswest/Desktop/nfl_predict/pipeline/predict.py
@@ -2317,23 +2317,32 @@
 
-def _predict_for_problem(features: pd.DataFrame, problem_name: str, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+def _predict_for_problem(features: pd.DataFrame, problem_config: dict, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+    """Load the trained model and return probability or point forecasts based on task metadata."""
+    problem_name = problem_config.get("name", "<unknown>")
+    task_type = str(
+        problem_config.get("task_type")
+        or artifacts.get("task_type")
+        or ""
+    ).lower()
+    output_mode = artifacts.get("output_mode") or problem_config.get("output_mode")
+
     X, _ = _prepare_feature_matrix(features, artifacts)
-    
     model = joblib.load(_latest_model_path(problem_name))
-    
-    # Assuming XGBoost or similar with predict_proba for classification and predict for regression
-    # But for simplicity and compatibility with regression, check model type or problem definition?
-    # Actually, regression models in sklearn/xgb return values directly on predict().
-    # Classification models return class labels on predict(), and probas on predict_proba().
-    
-    try:
-        # Heuristic: Try predict_proba first if it looks like a classifier (anytime_td)
-        # But we need to know task type.
-        if "anytime_td" in problem_name:
-             proba = model.predict_proba(X)[:, 1]
+
+    is_classification = task_type in {"classification", "binary", "multiclass"}
+    if is_classification:
+        if hasattr(model, "predict_proba"):
+            preds = model.predict_proba(X)
+            if preds.ndim > 1 and preds.shape[1] > 1:
+                preds = preds[:, 1]
         else:
-             proba = model.predict(X)
-    except AttributeError:
-        proba = model.predict(X)
-        
-    return proba
+            preds = model.predict(X)
+        preds = np.asarray(preds, dtype=float)
+        preds = np.clip(preds, 0.0, 1.0)
+    else:
+        preds = np.asarray(model.predict(X), dtype=float)
+
+    if output_mode and output_mode == "logit":
+        preds = 1.0 / (1.0 + np.exp(-preds))
+
+    return preds
 
apply_patch(auto_approved=true) exited 0 in 109ms:
Success. Updated the following files:
M pipeline/predict.py
file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..165d6021220f3bfc271efa4080b2d5ec1fe9abd8
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..528fd27a664ef34ecf88091e5becaafa39402802
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1369,28 +1375,6 @@
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
 
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
-
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
     if "decision_cutoff_ts" in enriched.columns:
@@ -2331,27 +2315,36 @@
              
     return adj
 
-def _predict_for_problem(features: pd.DataFrame, problem_name: str, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+def _predict_for_problem(features: pd.DataFrame, problem_config: dict, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+    """Load the trained model and return probability or point forecasts based on task metadata."""
+    problem_name = problem_config.get("name", "<unknown>")
+    task_type = str(
+        problem_config.get("task_type")
+        or artifacts.get("task_type")
+        or ""
+    ).lower()
+    output_mode = artifacts.get("output_mode") or problem_config.get("output_mode")
+
     X, _ = _prepare_feature_matrix(features, artifacts)
-    
     model = joblib.load(_latest_model_path(problem_name))
-    
-    # Assuming XGBoost or similar with predict_proba for classification and predict for regression
-    # But for simplicity and compatibility with regression, check model type or problem definition?
-    # Actually, regression models in sklearn/xgb return values directly on predict().
-    # Classification models return class labels on predict(), and probas on predict_proba().
-    
-    try:
-        # Heuristic: Try predict_proba first if it looks like a classifier (anytime_td)
-        # But we need to know task type.
-        if "anytime_td" in problem_name:
-             proba = model.predict_proba(X)[:, 1]
+
+    is_classification = task_type in {"classification", "binary", "multiclass"}
+    if is_classification:
+        if hasattr(model, "predict_proba"):
+            preds = model.predict_proba(X)
+            if preds.ndim > 1 and preds.shape[1] > 1:
+                preds = preds[:, 1]
         else:
-             proba = model.predict(X)
-    except AttributeError:
-        proba = model.predict(X)
-        
-    return proba
+            preds = model.predict(X)
+        preds = np.asarray(preds, dtype=float)
+        preds = np.clip(preds, 0.0, 1.0)
+    else:
+        preds = np.asarray(model.predict(X), dtype=float)
+
+    if output_mode and output_mode == "logit":
+        preds = 1.0 / (1.0 + np.exp(-preds))
+
+    return preds
 
 def main() -> None:
     _ensure_imports_ready()
diff --git a/pipeline/train.py b/pipeline/train.py
index 2e2508f5ee50bf4b1877b56465304ecac80dc0bb..30c70ab8292088cc8aad350882ef2c5e8cc7efa6
--- a/pipeline/train.py
+++ b/pipeline/train.py
@@ -2073,7 +2073,7 @@
 
         # --- Save inference artifacts AFTER all models for the problem are trained ---
         # This ensures the state (imputation, categories) is from the pre-tuning/pre-holdout phase.
-        save_inference_artifacts(self, problem_name)
+        save_inference_artifacts(self, problem_name, problem_copy)
 
     def _unwrap_base_model(self, model):
         """Return the true fitted estimator, no matter how it's wrapped."""
@@ -2334,7 +2334,7 @@
                     logger.warning("Failed to initialise team total scaling for %s: %s", problem_name, exc)
             if not use_cached_for_problem:
                 self._fit_feature_artifacts(df_train, problem_copy)
-                save_inference_artifacts(self, problem_name)
+                save_inference_artifacts(self, problem_name, problem_copy)
 
             # Log final feature list used
             logger.info(f"--- Using {len(self.feature_columns)} features for {problem_name} ---")
@@ -2697,4 +2697,4 @@
             train(config_path=args.config, ordinal_only=args.ordinal_only, ordinal_ev=ordinal_ev_flag, **overrides)
     except Exception as e:
         logger.critical(f"The pipeline has failed with a critical error: {e}", exc_info=True)
-        sys.exit(1)
\ No newline at end of file
+        sys.exit(1)
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..eb5471f38ae1512ba5cabf81e6baf81aab0e986b
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -44,18 +44,31 @@
             formatted[k] = v
     return formatted
 
-def save_inference_artifacts(trainer, problem_name: str) -> None:
+def save_inference_artifacts(trainer, problem_name: str, problem_config: dict | None = None) -> None:
     # Versioned artifact copy
     v_dir = _vdir(trainer, problem_name, None, "artifacts") / "inference"
     v_dir.mkdir(parents=True, exist_ok=True)
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync

file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..165d6021220f3bfc271efa4080b2d5ec1fe9abd8
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..528fd27a664ef34ecf88091e5becaafa39402802
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1369,28 +1375,6 @@
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
 
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
-
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
     if "decision_cutoff_ts" in enriched.columns:
@@ -2331,27 +2315,36 @@
              
     return adj
 
-def _predict_for_problem(features: pd.DataFrame, problem_name: str, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+def _predict_for_problem(features: pd.DataFrame, problem_config: dict, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+    """Load the trained model and return probability or point forecasts based on task metadata."""
+    problem_name = problem_config.get("name", "<unknown>")
+    task_type = str(
+        problem_config.get("task_type")
+        or artifacts.get("task_type")
+        or ""
+    ).lower()
+    output_mode = artifacts.get("output_mode") or problem_config.get("output_mode")
+
     X, _ = _prepare_feature_matrix(features, artifacts)
-    
     model = joblib.load(_latest_model_path(problem_name))
-    
-    # Assuming XGBoost or similar with predict_proba for classification and predict for regression
-    # But for simplicity and compatibility with regression, check model type or problem definition?
-    # Actually, regression models in sklearn/xgb return values directly on predict().
-    # Classification models return class labels on predict(), and probas on predict_proba().
-    
-    try:
-        # Heuristic: Try predict_proba first if it looks like a classifier (anytime_td)
-        # But we need to know task type.
-        if "anytime_td" in problem_name:
-             proba = model.predict_proba(X)[:, 1]
+
+    is_classification = task_type in {"classification", "binary", "multiclass"}
+    if is_classification:
+        if hasattr(model, "predict_proba"):
+            preds = model.predict_proba(X)
+            if preds.ndim > 1 and preds.shape[1] > 1:
+                preds = preds[:, 1]
         else:
-             proba = model.predict(X)
-    except AttributeError:
-        proba = model.predict(X)
-        
-    return proba
+            preds = model.predict(X)
+        preds = np.asarray(preds, dtype=float)
+        preds = np.clip(preds, 0.0, 1.0)
+    else:
+        preds = np.asarray(model.predict(X), dtype=float)
+
+    if output_mode and output_mode == "logit":
+        preds = 1.0 / (1.0 + np.exp(-preds))
+
+    return preds
 
 def main() -> None:
     _ensure_imports_ready()
diff --git a/pipeline/train.py b/pipeline/train.py
index 2e2508f5ee50bf4b1877b56465304ecac80dc0bb..30c70ab8292088cc8aad350882ef2c5e8cc7efa6
--- a/pipeline/train.py
+++ b/pipeline/train.py
@@ -2073,7 +2073,7 @@
 
         # --- Save inference artifacts AFTER all models for the problem are trained ---
         # This ensures the state (imputation, categories) is from the pre-tuning/pre-holdout phase.
-        save_inference_artifacts(self, problem_name)
+        save_inference_artifacts(self, problem_name, problem_copy)
 
     def _unwrap_base_model(self, model):
         """Return the true fitted estimator, no matter how it's wrapped."""
@@ -2334,7 +2334,7 @@
                     logger.warning("Failed to initialise team total scaling for %s: %s", problem_name, exc)
             if not use_cached_for_problem:
                 self._fit_feature_artifacts(df_train, problem_copy)
-                save_inference_artifacts(self, problem_name)
+                save_inference_artifacts(self, problem_name, problem_copy)
 
             # Log final feature list used
             logger.info(f"--- Using {len(self.feature_columns)} features for {problem_name} ---")
@@ -2697,4 +2697,4 @@
             train(config_path=args.config, ordinal_only=args.ordinal_only, ordinal_ev=ordinal_ev_flag, **overrides)
     except Exception as e:
         logger.critical(f"The pipeline has failed with a critical error: {e}", exc_info=True)
-        sys.exit(1)
\ No newline at end of file
+        sys.exit(1)
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..eb5471f38ae1512ba5cabf81e6baf81aab0e986b
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -44,18 +44,31 @@
             formatted[k] = v
     return formatted
 
-def save_inference_artifacts(trainer, problem_name: str) -> None:
+def save_inference_artifacts(trainer, problem_name: str, problem_config: dict | None = None) -> None:
     # Versioned artifact copy
     v_dir = _vdir(trainer, problem_name, None, "artifacts") / "inference"
     v_dir.mkdir(parents=True, exist_ok=True)
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync


thinking
**Updating function call with problem config**
file update
M /Users/jameswest/Desktop/nfl_predict/pipeline/predict.py
@@ -2396,3 +2396,3 @@
 
-            preds = _predict_for_problem(features, p_name, artifacts)
+            preds = _predict_for_problem(features, problem, artifacts)
             
apply_patch(auto_approved=true) exited 0 in 94ms:
Success. Updated the following files:
M pipeline/predict.py
file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..165d6021220f3bfc271efa4080b2d5ec1fe9abd8
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..208733668f46e0f2359cf19bbfb0e59d9c7f2f7c
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1369,28 +1375,6 @@
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
 
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
-
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
     if "decision_cutoff_ts" in enriched.columns:
@@ -2331,28 +2315,37 @@
              
     return adj
 
-def _predict_for_problem(features: pd.DataFrame, problem_name: str, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+def _predict_for_problem(features: pd.DataFrame, problem_config: dict, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+    """Load the trained model and return probability or point forecasts based on task metadata."""
+    problem_name = problem_config.get("name", "<unknown>")
+    task_type = str(
+        problem_config.get("task_type")
+        or artifacts.get("task_type")
+        or ""
+    ).lower()
+    output_mode = artifacts.get("output_mode") or problem_config.get("output_mode")
+
     X, _ = _prepare_feature_matrix(features, artifacts)
-    
     model = joblib.load(_latest_model_path(problem_name))
-    
-    # Assuming XGBoost or similar with predict_proba for classification and predict for regression
-    # But for simplicity and compatibility with regression, check model type or problem definition?
-    # Actually, regression models in sklearn/xgb return values directly on predict().
-    # Classification models return class labels on predict(), and probas on predict_proba().
-    
-    try:
-        # Heuristic: Try predict_proba first if it looks like a classifier (anytime_td)
-        # But we need to know task type.
-        if "anytime_td" in problem_name:
-             proba = model.predict_proba(X)[:, 1]
+
+    is_classification = task_type in {"classification", "binary", "multiclass"}
+    if is_classification:
+        if hasattr(model, "predict_proba"):
+            preds = model.predict_proba(X)
+            if preds.ndim > 1 and preds.shape[1] > 1:
+                preds = preds[:, 1]
         else:
-             proba = model.predict(X)
-    except AttributeError:
-        proba = model.predict(X)
-        
-    return proba
+            preds = model.predict(X)
+        preds = np.asarray(preds, dtype=float)
+        preds = np.clip(preds, 0.0, 1.0)
+    else:
+        preds = np.asarray(model.predict(X), dtype=float)
 
+    if output_mode and output_mode == "logit":
+        preds = 1.0 / (1.0 + np.exp(-preds))
+
+    return preds
+
 def main() -> None:
     _ensure_imports_ready()
     args = _parse_args()
@@ -2401,7 +2394,7 @@
                 logger.warning("Skipping %s (artifacts not found).", p_name)
                 continue
 
-            preds = _predict_for_problem(features, p_name, artifacts)
+            preds = _predict_for_problem(features, problem, artifacts)
             
             # Apply guards for availability components immediately
             if p_name == "availability_active":
diff --git a/pipeline/train.py b/pipeline/train.py
index 2e2508f5ee50bf4b1877b56465304ecac80dc0bb..30c70ab8292088cc8aad350882ef2c5e8cc7efa6
--- a/pipeline/train.py
+++ b/pipeline/train.py
@@ -2073,7 +2073,7 @@
 
         # --- Save inference artifacts AFTER all models for the problem are trained ---
         # This ensures the state (imputation, categories) is from the pre-tuning/pre-holdout phase.
-        save_inference_artifacts(self, problem_name)
+        save_inference_artifacts(self, problem_name, problem_copy)
 
     def _unwrap_base_model(self, model):
         """Return the true fitted estimator, no matter how it's wrapped."""
@@ -2334,7 +2334,7 @@
                     logger.warning("Failed to initialise team total scaling for %s: %s", problem_name, exc)
             if not use_cached_for_problem:
                 self._fit_feature_artifacts(df_train, problem_copy)
-                save_inference_artifacts(self, problem_name)
+                save_inference_artifacts(self, problem_name, problem_copy)
 
             # Log final feature list used
             logger.info(f"--- Using {len(self.feature_columns)} features for {problem_name} ---")
@@ -2697,4 +2697,4 @@
             train(config_path=args.config, ordinal_only=args.ordinal_only, ordinal_ev=ordinal_ev_flag, **overrides)
     except Exception as e:
         logger.critical(f"The pipeline has failed with a critical error: {e}", exc_info=True)
-        sys.exit(1)
\ No newline at end of file
+        sys.exit(1)
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..eb5471f38ae1512ba5cabf81e6baf81aab0e986b
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -44,18 +44,31 @@
             formatted[k] = v
     return formatted
 
-def save_inference_artifacts(trainer, problem_name: str) -> None:
+def save_inference_artifacts(trainer, problem_name: str, problem_config: dict | None = None) -> None:
     # Versioned artifact copy
     v_dir = _vdir(trainer, problem_name, None, "artifacts") / "inference"
     v_dir.mkdir(parents=True, exist_ok=True)
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync

file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..165d6021220f3bfc271efa4080b2d5ec1fe9abd8
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..208733668f46e0f2359cf19bbfb0e59d9c7f2f7c
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1369,28 +1375,6 @@
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
 
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
-
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
     if "decision_cutoff_ts" in enriched.columns:
@@ -2331,28 +2315,37 @@
              
     return adj
 
-def _predict_for_problem(features: pd.DataFrame, problem_name: str, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+def _predict_for_problem(features: pd.DataFrame, problem_config: dict, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+    """Load the trained model and return probability or point forecasts based on task metadata."""
+    problem_name = problem_config.get("name", "<unknown>")
+    task_type = str(
+        problem_config.get("task_type")
+        or artifacts.get("task_type")
+        or ""
+    ).lower()
+    output_mode = artifacts.get("output_mode") or problem_config.get("output_mode")
+
     X, _ = _prepare_feature_matrix(features, artifacts)
-    
     model = joblib.load(_latest_model_path(problem_name))
-    
-    # Assuming XGBoost or similar with predict_proba for classification and predict for regression
-    # But for simplicity and compatibility with regression, check model type or problem definition?
-    # Actually, regression models in sklearn/xgb return values directly on predict().
-    # Classification models return class labels on predict(), and probas on predict_proba().
-    
-    try:
-        # Heuristic: Try predict_proba first if it looks like a classifier (anytime_td)
-        # But we need to know task type.
-        if "anytime_td" in problem_name:
-             proba = model.predict_proba(X)[:, 1]
+
+    is_classification = task_type in {"classification", "binary", "multiclass"}
+    if is_classification:
+        if hasattr(model, "predict_proba"):
+            preds = model.predict_proba(X)
+            if preds.ndim > 1 and preds.shape[1] > 1:
+                preds = preds[:, 1]
         else:
-             proba = model.predict(X)
-    except AttributeError:
-        proba = model.predict(X)
-        
-    return proba
+            preds = model.predict(X)
+        preds = np.asarray(preds, dtype=float)
+        preds = np.clip(preds, 0.0, 1.0)
+    else:
+        preds = np.asarray(model.predict(X), dtype=float)
 
+    if output_mode and output_mode == "logit":
+        preds = 1.0 / (1.0 + np.exp(-preds))
+
+    return preds
+
 def main() -> None:
     _ensure_imports_ready()
     args = _parse_args()
@@ -2401,7 +2394,7 @@
                 logger.warning("Skipping %s (artifacts not found).", p_name)
                 continue
 
-            preds = _predict_for_problem(features, p_name, artifacts)
+            preds = _predict_for_problem(features, problem, artifacts)
             
             # Apply guards for availability components immediately
             if p_name == "availability_active":
diff --git a/pipeline/train.py b/pipeline/train.py
index 2e2508f5ee50bf4b1877b56465304ecac80dc0bb..30c70ab8292088cc8aad350882ef2c5e8cc7efa6
--- a/pipeline/train.py
+++ b/pipeline/train.py
@@ -2073,7 +2073,7 @@
 
         # --- Save inference artifacts AFTER all models for the problem are trained ---
         # This ensures the state (imputation, categories) is from the pre-tuning/pre-holdout phase.
-        save_inference_artifacts(self, problem_name)
+        save_inference_artifacts(self, problem_name, problem_copy)
 
     def _unwrap_base_model(self, model):
         """Return the true fitted estimator, no matter how it's wrapped."""
@@ -2334,7 +2334,7 @@
                     logger.warning("Failed to initialise team total scaling for %s: %s", problem_name, exc)
             if not use_cached_for_problem:
                 self._fit_feature_artifacts(df_train, problem_copy)
-                save_inference_artifacts(self, problem_name)
+                save_inference_artifacts(self, problem_name, problem_copy)
 
             # Log final feature list used
             logger.info(f"--- Using {len(self.feature_columns)} features for {problem_name} ---")
@@ -2697,4 +2697,4 @@
             train(config_path=args.config, ordinal_only=args.ordinal_only, ordinal_ev=ordinal_ev_flag, **overrides)
     except Exception as e:
         logger.critical(f"The pipeline has failed with a critical error: {e}", exc_info=True)
-        sys.exit(1)
\ No newline at end of file
+        sys.exit(1)
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..eb5471f38ae1512ba5cabf81e6baf81aab0e986b
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -44,18 +44,31 @@
             formatted[k] = v
     return formatted
 
-def save_inference_artifacts(trainer, problem_name: str) -> None:
+def save_inference_artifacts(trainer, problem_name: str, problem_config: dict | None = None) -> None:
     # Versioned artifact copy
     v_dir = _vdir(trainer, problem_name, None, "artifacts") / "inference"
     v_dir.mkdir(parents=True, exist_ok=True)
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync


thinking
**Reviewing artifact loading and classification updates**

I'm making sure the `_load_artifacts` function properly supports the new output_mode and handles updated model paths with problem names. I’m also verifying threshold parameters and checking if classification inference outputs probabilities as expected. I’ll adjust the training config tests to include new leak-prone columns and confirm no conflicts with banned prefixes. Some steps like dedup in training config are planned for later, and I’m considering new tests to ensure classification predictions use probabilities correctly.

thinking
**Designing a test for predict_proba usage**

I'm thinking about how to test the `_predict_for_problem` function to confirm it uses `predict_proba` when available. I plan to use pytest's monkeypatch to replace the model loading step with a dummy model that tracks whether `predict_proba` or `predict` is called. I want to build a minimal test setup in a new test file that includes a dummy problem config and artifacts, ensuring the test avoids file I/O by patching `_latest_model_path` and joblib.load. This approach should verify the prediction behavior cleanly.

thinking
**Cleaning duplicate YAML keys**
exec
/bin/zsh -lc "sed -n '360,430p' config/training.yaml" in /Users/jameswest/Desktop/nfl_predict succeeded in 701ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
      group_cols: ['player_id']
      order_cols: ['game_date']
      shift: 0
    feature_prefixes_to_include:
      - 'pred_'
      - 'expected_'
      - 'hist_target_share_'
      - 'ps_hist_'
      - 'travel_'
      - 'opp_def_'
      - 'team_ctx_'
      - 'qb_profile_'
      - 'weather_'
    other_features_to_include:
      - 'week'
      - 'season'
      - 'position'
      - 'team_implied_total'
      - 'travel_rest_days'
file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..165d6021220f3bfc271efa4080b2d5ec1fe9abd8
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..208733668f46e0f2359cf19bbfb0e59d9c7f2f7c
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1369,28 +1375,6 @@
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
 
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
-
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
     if "decision_cutoff_ts" in enriched.columns:
@@ -2331,28 +2315,37 @@
              
     return adj
 
-def _predict_for_problem(features: pd.DataFrame, problem_name: str, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+def _predict_for_problem(features: pd.DataFrame, problem_config: dict, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+    """Load the trained model and return probability or point forecasts based on task metadata."""
+    problem_name = problem_config.get("name", "<unknown>")
+    task_type = str(
+        problem_config.get("task_type")
+        or artifacts.get("task_type")
+        or ""
+    ).lower()
+    output_mode = artifacts.get("output_mode") or problem_config.get("output_mode")
+
     X, _ = _prepare_feature_matrix(features, artifacts)
-    
     model = joblib.load(_latest_model_path(problem_name))
-    
-    # Assuming XGBoost or similar with predict_proba for classification and predict for regression
-    # But for simplicity and compatibility with regression, check model type or problem definition?
-    # Actually, regression models in sklearn/xgb return values directly on predict().
-    # Classification models return class labels on predict(), and probas on predict_proba().
-    
-    try:
-        # Heuristic: Try predict_proba first if it looks like a classifier (anytime_td)
-        # But we need to know task type.
-        if "anytime_td" in problem_name:
-             proba = model.predict_proba(X)[:, 1]
+
+    is_classification = task_type in {"classification", "binary", "multiclass"}
+    if is_classification:
+        if hasattr(model, "predict_proba"):
+            preds = model.predict_proba(X)
+            if preds.ndim > 1 and preds.shape[1] > 1:
+                preds = preds[:, 1]
         else:
-             proba = model.predict(X)
-    except AttributeError:
-        proba = model.predict(X)
-        
-    return proba
+            preds = model.predict(X)
+        preds = np.asarray(preds, dtype=float)
+        preds = np.clip(preds, 0.0, 1.0)
+    else:
+        preds = np.asarray(model.predict(X), dtype=float)
 
+    if output_mode and output_mode == "logit":
+        preds = 1.0 / (1.0 + np.exp(-preds))
+
+    return preds
+
 def main() -> None:
     _ensure_imports_ready()
     args = _parse_args()
@@ -2401,7 +2394,7 @@
                 logger.warning("Skipping %s (artifacts not found).", p_name)
                 continue
 
-            preds = _predict_for_problem(features, p_name, artifacts)
+            preds = _predict_for_problem(features, problem, artifacts)
             
             # Apply guards for availability components immediately
             if p_name == "availability_active":
diff --git a/pipeline/train.py b/pipeline/train.py
index 2e2508f5ee50bf4b1877b56465304ecac80dc0bb..30c70ab8292088cc8aad350882ef2c5e8cc7efa6
--- a/pipeline/train.py
+++ b/pipeline/train.py
@@ -2073,7 +2073,7 @@
 
         # --- Save inference artifacts AFTER all models for the problem are trained ---
         # This ensures the state (imputation, categories) is from the pre-tuning/pre-holdout phase.
-        save_inference_artifacts(self, problem_name)
+        save_inference_artifacts(self, problem_name, problem_copy)
 
     def _unwrap_base_model(self, model):
         """Return the true fitted estimator, no matter how it's wrapped."""
@@ -2334,7 +2334,7 @@
                     logger.warning("Failed to initialise team total scaling for %s: %s", problem_name, exc)
             if not use_cached_for_problem:
                 self._fit_feature_artifacts(df_train, problem_copy)
-                save_inference_artifacts(self, problem_name)
+                save_inference_artifacts(self, problem_name, problem_copy)
 
             # Log final feature list used
             logger.info(f"--- Using {len(self.feature_columns)} features for {problem_name} ---")
@@ -2697,4 +2697,4 @@
             train(config_path=args.config, ordinal_only=args.ordinal_only, ordinal_ev=ordinal_ev_flag, **overrides)
     except Exception as e:
         logger.critical(f"The pipeline has failed with a critical error: {e}", exc_info=True)
-        sys.exit(1)
\ No newline at end of file
+        sys.exit(1)
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..eb5471f38ae1512ba5cabf81e6baf81aab0e986b
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -44,18 +44,31 @@
             formatted[k] = v
     return formatted
 
-def save_inference_artifacts(trainer, problem_name: str) -> None:
+def save_inference_artifacts(trainer, problem_name: str, problem_config: dict | None = None) -> None:
     # Versioned artifact copy
     v_dir = _vdir(trainer, problem_name, None, "artifacts") / "inference"
     v_dir.mkdir(parents=True, exist_ok=True)
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync

exec
/bin/zsh -lc "sed -n '430,510p' config/training.yaml" in /Users/jameswest/Desktop/nfl_predict succeeded in 659ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
    input_predictions:
      - 'availability_active'
      - 'availability_snapshare'
      - 'usage_targets'
      - 'usage_carries'
      - 'efficiency_rec_yards'
      - 'efficiency_rush_yards'
    feature_prefixes_to_include:
      - 'pred_'
      - 'expected_'
      - 'opp_def_'
      - 'red_zone_'
      - 'goal_to_go_'
      - 'off_ctx_'
      - 'qb_profile_'
      - 'drive_hist_'
      - 'weather_'
      - 'travel_'
    other_features_to_include:
file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..165d6021220f3bfc271efa4080b2d5ec1fe9abd8
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..208733668f46e0f2359cf19bbfb0e59d9c7f2f7c
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1369,28 +1375,6 @@
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
 
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
-
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
     if "decision_cutoff_ts" in enriched.columns:
@@ -2331,28 +2315,37 @@
              
     return adj
 
-def _predict_for_problem(features: pd.DataFrame, problem_name: str, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+def _predict_for_problem(features: pd.DataFrame, problem_config: dict, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+    """Load the trained model and return probability or point forecasts based on task metadata."""
+    problem_name = problem_config.get("name", "<unknown>")
+    task_type = str(
+        problem_config.get("task_type")
+        or artifacts.get("task_type")
+        or ""
+    ).lower()
+    output_mode = artifacts.get("output_mode") or problem_config.get("output_mode")
+
     X, _ = _prepare_feature_matrix(features, artifacts)
-    
     model = joblib.load(_latest_model_path(problem_name))
-    
-    # Assuming XGBoost or similar with predict_proba for classification and predict for regression
-    # But for simplicity and compatibility with regression, check model type or problem definition?
-    # Actually, regression models in sklearn/xgb return values directly on predict().
-    # Classification models return class labels on predict(), and probas on predict_proba().
-    
-    try:
-        # Heuristic: Try predict_proba first if it looks like a classifier (anytime_td)
-        # But we need to know task type.
-        if "anytime_td" in problem_name:
-             proba = model.predict_proba(X)[:, 1]
+
+    is_classification = task_type in {"classification", "binary", "multiclass"}
+    if is_classification:
+        if hasattr(model, "predict_proba"):
+            preds = model.predict_proba(X)
+            if preds.ndim > 1 and preds.shape[1] > 1:
+                preds = preds[:, 1]
         else:
-             proba = model.predict(X)
-    except AttributeError:
-        proba = model.predict(X)
-        
-    return proba
+            preds = model.predict(X)
+        preds = np.asarray(preds, dtype=float)
+        preds = np.clip(preds, 0.0, 1.0)
+    else:
+        preds = np.asarray(model.predict(X), dtype=float)
 
+    if output_mode and output_mode == "logit":
+        preds = 1.0 / (1.0 + np.exp(-preds))
+
+    return preds
+
 def main() -> None:
     _ensure_imports_ready()
     args = _parse_args()
@@ -2401,7 +2394,7 @@
                 logger.warning("Skipping %s (artifacts not found).", p_name)
                 continue
 
-            preds = _predict_for_problem(features, p_name, artifacts)
+            preds = _predict_for_problem(features, problem, artifacts)
             
             # Apply guards for availability components immediately
             if p_name == "availability_active":
diff --git a/pipeline/train.py b/pipeline/train.py
index 2e2508f5ee50bf4b1877b56465304ecac80dc0bb..30c70ab8292088cc8aad350882ef2c5e8cc7efa6
--- a/pipeline/train.py
+++ b/pipeline/train.py
@@ -2073,7 +2073,7 @@
 
         # --- Save inference artifacts AFTER all models for the problem are trained ---
         # This ensures the state (imputation, categories) is from the pre-tuning/pre-holdout phase.
-        save_inference_artifacts(self, problem_name)
+        save_inference_artifacts(self, problem_name, problem_copy)
 
     def _unwrap_base_model(self, model):
         """Return the true fitted estimator, no matter how it's wrapped."""
@@ -2334,7 +2334,7 @@
                     logger.warning("Failed to initialise team total scaling for %s: %s", problem_name, exc)
             if not use_cached_for_problem:
                 self._fit_feature_artifacts(df_train, problem_copy)
-                save_inference_artifacts(self, problem_name)
+                save_inference_artifacts(self, problem_name, problem_copy)
 
             # Log final feature list used
             logger.info(f"--- Using {len(self.feature_columns)} features for {problem_name} ---")
@@ -2697,4 +2697,4 @@
             train(config_path=args.config, ordinal_only=args.ordinal_only, ordinal_ev=ordinal_ev_flag, **overrides)
     except Exception as e:
         logger.critical(f"The pipeline has failed with a critical error: {e}", exc_info=True)
-        sys.exit(1)
\ No newline at end of file
+        sys.exit(1)
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..eb5471f38ae1512ba5cabf81e6baf81aab0e986b
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -44,18 +44,31 @@
             formatted[k] = v
     return formatted
 
-def save_inference_artifacts(trainer, problem_name: str) -> None:
+def save_inference_artifacts(trainer, problem_name: str, problem_config: dict | None = None) -> None:
     # Versioned artifact copy
     v_dir = _vdir(trainer, problem_name, None, "artifacts") / "inference"
     v_dir.mkdir(parents=True, exist_ok=True)
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync


thinking
**Removing duplicate configuration block**
file update
M /Users/jameswest/Desktop/nfl_predict/config/training.yaml
@@ -462,23 +462,2 @@
     columns_to_discard: *columns_to_discard
-    feature_prefixes_to_include:
-      - 'pred_'
-      - 'expected_'
-      - 'opp_def_'
-      - 'red_zone_'
-      - 'goal_to_go_'
-      - 'off_ctx_'
-      - 'qb_profile_'
-      - 'weather_'
-    other_features_to_include:
-      - 'week'
-      - 'season'
-      - 'position'
-      - 'total_line'
-      - 'team_implied_total'
-      - 'team_red_zone_'
-      - 'team_goal_to_go_'
-      - 'player_red_zone_'
-      - 'player_goal_to_go_'
-      - 'weather_bad_passing_flag'
-    columns_to_discard: *columns_to_discard
 
apply_patch(auto_approved=true) exited 0 in 113ms:
Success. Updated the following files:
M config/training.yaml
file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..dc5fa3ecfb113878ba721fd47fdf8337d4c2abd2
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -398,27 +454,6 @@
       - 'travel_rest_days'
       - 'travel_rest_days_l3'
       - 'rest_days_since_last_game'
-      - 'team_red_zone_'
-      - 'team_goal_to_go_'
-      - 'player_red_zone_'
-      - 'player_goal_to_go_'
-      - 'weather_bad_passing_flag'
-    columns_to_discard: *columns_to_discard
-    feature_prefixes_to_include:
-      - 'pred_'
-      - 'expected_'
-      - 'opp_def_'
-      - 'red_zone_'
-      - 'goal_to_go_'
-      - 'off_ctx_'
-      - 'qb_profile_'
-      - 'weather_'
-    other_features_to_include:
-      - 'week'
-      - 'season'
-      - 'position'
-      - 'total_line'
-      - 'team_implied_total'
       - 'team_red_zone_'
       - 'team_goal_to_go_'
       - 'player_red_zone_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..208733668f46e0f2359cf19bbfb0e59d9c7f2f7c
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1369,28 +1375,6 @@
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
 
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
-
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
     if "decision_cutoff_ts" in enriched.columns:
@@ -2331,28 +2315,37 @@
              
     return adj
 
-def _predict_for_problem(features: pd.DataFrame, problem_name: str, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+def _predict_for_problem(features: pd.DataFrame, problem_config: dict, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+    """Load the trained model and return probability or point forecasts based on task metadata."""
+    problem_name = problem_config.get("name", "<unknown>")
+    task_type = str(
+        problem_config.get("task_type")
+        or artifacts.get("task_type")
+        or ""
+    ).lower()
+    output_mode = artifacts.get("output_mode") or problem_config.get("output_mode")
+
     X, _ = _prepare_feature_matrix(features, artifacts)
-    
     model = joblib.load(_latest_model_path(problem_name))
-    
-    # Assuming XGBoost or similar with predict_proba for classification and predict for regression
-    # But for simplicity and compatibility with regression, check model type or problem definition?
-    # Actually, regression models in sklearn/xgb return values directly on predict().
-    # Classification models return class labels on predict(), and probas on predict_proba().
-    
-    try:
-        # Heuristic: Try predict_proba first if it looks like a classifier (anytime_td)
-        # But we need to know task type.
-        if "anytime_td" in problem_name:
-             proba = model.predict_proba(X)[:, 1]
+
+    is_classification = task_type in {"classification", "binary", "multiclass"}
+    if is_classification:
+        if hasattr(model, "predict_proba"):
+            preds = model.predict_proba(X)
+            if preds.ndim > 1 and preds.shape[1] > 1:
+                preds = preds[:, 1]
         else:
-             proba = model.predict(X)
-    except AttributeError:
-        proba = model.predict(X)
-        
-    return proba
+            preds = model.predict(X)
+        preds = np.asarray(preds, dtype=float)
+        preds = np.clip(preds, 0.0, 1.0)
+    else:
+        preds = np.asarray(model.predict(X), dtype=float)
 
+    if output_mode and output_mode == "logit":
+        preds = 1.0 / (1.0 + np.exp(-preds))
+
+    return preds
+
 def main() -> None:
     _ensure_imports_ready()
     args = _parse_args()
@@ -2401,7 +2394,7 @@
                 logger.warning("Skipping %s (artifacts not found).", p_name)
                 continue
 
-            preds = _predict_for_problem(features, p_name, artifacts)
+            preds = _predict_for_problem(features, problem, artifacts)
             
             # Apply guards for availability components immediately
             if p_name == "availability_active":
diff --git a/pipeline/train.py b/pipeline/train.py
index 2e2508f5ee50bf4b1877b56465304ecac80dc0bb..30c70ab8292088cc8aad350882ef2c5e8cc7efa6
--- a/pipeline/train.py
+++ b/pipeline/train.py
@@ -2073,7 +2073,7 @@
 
         # --- Save inference artifacts AFTER all models for the problem are trained ---
         # This ensures the state (imputation, categories) is from the pre-tuning/pre-holdout phase.
-        save_inference_artifacts(self, problem_name)
+        save_inference_artifacts(self, problem_name, problem_copy)
 
     def _unwrap_base_model(self, model):
         """Return the true fitted estimator, no matter how it's wrapped."""
@@ -2334,7 +2334,7 @@
                     logger.warning("Failed to initialise team total scaling for %s: %s", problem_name, exc)
             if not use_cached_for_problem:
                 self._fit_feature_artifacts(df_train, problem_copy)
-                save_inference_artifacts(self, problem_name)
+                save_inference_artifacts(self, problem_name, problem_copy)
 
             # Log final feature list used
             logger.info(f"--- Using {len(self.feature_columns)} features for {problem_name} ---")
@@ -2697,4 +2697,4 @@
             train(config_path=args.config, ordinal_only=args.ordinal_only, ordinal_ev=ordinal_ev_flag, **overrides)
     except Exception as e:
         logger.critical(f"The pipeline has failed with a critical error: {e}", exc_info=True)
-        sys.exit(1)
\ No newline at end of file
+        sys.exit(1)
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..eb5471f38ae1512ba5cabf81e6baf81aab0e986b
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -44,18 +44,31 @@
             formatted[k] = v
     return formatted
 
-def save_inference_artifacts(trainer, problem_name: str) -> None:
+def save_inference_artifacts(trainer, problem_name: str, problem_config: dict | None = None) -> None:
     # Versioned artifact copy
     v_dir = _vdir(trainer, problem_name, None, "artifacts") / "inference"
     v_dir.mkdir(parents=True, exist_ok=True)
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync

file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..dc5fa3ecfb113878ba721fd47fdf8337d4c2abd2
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -398,27 +454,6 @@
       - 'travel_rest_days'
       - 'travel_rest_days_l3'
       - 'rest_days_since_last_game'
-      - 'team_red_zone_'
-      - 'team_goal_to_go_'
-      - 'player_red_zone_'
-      - 'player_goal_to_go_'
-      - 'weather_bad_passing_flag'
-    columns_to_discard: *columns_to_discard
-    feature_prefixes_to_include:
-      - 'pred_'
-      - 'expected_'
-      - 'opp_def_'
-      - 'red_zone_'
-      - 'goal_to_go_'
-      - 'off_ctx_'
-      - 'qb_profile_'
-      - 'weather_'
-    other_features_to_include:
-      - 'week'
-      - 'season'
-      - 'position'
-      - 'total_line'
-      - 'team_implied_total'
       - 'team_red_zone_'
       - 'team_goal_to_go_'
       - 'player_red_zone_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..208733668f46e0f2359cf19bbfb0e59d9c7f2f7c
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1369,28 +1375,6 @@
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
 
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
-
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
     if "decision_cutoff_ts" in enriched.columns:
@@ -2331,28 +2315,37 @@
              
     return adj
 
-def _predict_for_problem(features: pd.DataFrame, problem_name: str, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+def _predict_for_problem(features: pd.DataFrame, problem_config: dict, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+    """Load the trained model and return probability or point forecasts based on task metadata."""
+    problem_name = problem_config.get("name", "<unknown>")
+    task_type = str(
+        problem_config.get("task_type")
+        or artifacts.get("task_type")
+        or ""
+    ).lower()
+    output_mode = artifacts.get("output_mode") or problem_config.get("output_mode")
+
     X, _ = _prepare_feature_matrix(features, artifacts)
-    
     model = joblib.load(_latest_model_path(problem_name))
-    
-    # Assuming XGBoost or similar with predict_proba for classification and predict for regression
-    # But for simplicity and compatibility with regression, check model type or problem definition?
-    # Actually, regression models in sklearn/xgb return values directly on predict().
-    # Classification models return class labels on predict(), and probas on predict_proba().
-    
-    try:
-        # Heuristic: Try predict_proba first if it looks like a classifier (anytime_td)
-        # But we need to know task type.
-        if "anytime_td" in problem_name:
-             proba = model.predict_proba(X)[:, 1]
+
+    is_classification = task_type in {"classification", "binary", "multiclass"}
+    if is_classification:
+        if hasattr(model, "predict_proba"):
+            preds = model.predict_proba(X)
+            if preds.ndim > 1 and preds.shape[1] > 1:
+                preds = preds[:, 1]
         else:
-             proba = model.predict(X)
-    except AttributeError:
-        proba = model.predict(X)
-        
-    return proba
+            preds = model.predict(X)
+        preds = np.asarray(preds, dtype=float)
+        preds = np.clip(preds, 0.0, 1.0)
+    else:
+        preds = np.asarray(model.predict(X), dtype=float)
 
+    if output_mode and output_mode == "logit":
+        preds = 1.0 / (1.0 + np.exp(-preds))
+
+    return preds
+
 def main() -> None:
     _ensure_imports_ready()
     args = _parse_args()
@@ -2401,7 +2394,7 @@
                 logger.warning("Skipping %s (artifacts not found).", p_name)
                 continue
 
-            preds = _predict_for_problem(features, p_name, artifacts)
+            preds = _predict_for_problem(features, problem, artifacts)
             
             # Apply guards for availability components immediately
             if p_name == "availability_active":
diff --git a/pipeline/train.py b/pipeline/train.py
index 2e2508f5ee50bf4b1877b56465304ecac80dc0bb..30c70ab8292088cc8aad350882ef2c5e8cc7efa6
--- a/pipeline/train.py
+++ b/pipeline/train.py
@@ -2073,7 +2073,7 @@
 
         # --- Save inference artifacts AFTER all models for the problem are trained ---
         # This ensures the state (imputation, categories) is from the pre-tuning/pre-holdout phase.
-        save_inference_artifacts(self, problem_name)
+        save_inference_artifacts(self, problem_name, problem_copy)
 
     def _unwrap_base_model(self, model):
         """Return the true fitted estimator, no matter how it's wrapped."""
@@ -2334,7 +2334,7 @@
                     logger.warning("Failed to initialise team total scaling for %s: %s", problem_name, exc)
             if not use_cached_for_problem:
                 self._fit_feature_artifacts(df_train, problem_copy)
-                save_inference_artifacts(self, problem_name)
+                save_inference_artifacts(self, problem_name, problem_copy)
 
             # Log final feature list used
             logger.info(f"--- Using {len(self.feature_columns)} features for {problem_name} ---")
@@ -2697,4 +2697,4 @@
             train(config_path=args.config, ordinal_only=args.ordinal_only, ordinal_ev=ordinal_ev_flag, **overrides)
     except Exception as e:
         logger.critical(f"The pipeline has failed with a critical error: {e}", exc_info=True)
-        sys.exit(1)
\ No newline at end of file
+        sys.exit(1)
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..eb5471f38ae1512ba5cabf81e6baf81aab0e986b
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -44,18 +44,31 @@
             formatted[k] = v
     return formatted
 
-def save_inference_artifacts(trainer, problem_name: str) -> None:
+def save_inference_artifacts(trainer, problem_name: str, problem_config: dict | None = None) -> None:
     # Versioned artifact copy
     v_dir = _vdir(trainer, problem_name, None, "artifacts") / "inference"
     v_dir.mkdir(parents=True, exist_ok=True)
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync


thinking
**Adding test for unique problem names**
file update
M /Users/jameswest/Desktop/nfl_predict/tests/test_training_config_features.py
@@ -16,2 +16,15 @@
 
+def test_problem_names_unique():
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    names = [p.get("name") for p in problems]
+    seen = {}
+    duplicates = set()
+    for name in names:
+        if name in seen:
+            duplicates.add(name)
+        seen[name] = True
+    assert not duplicates, f"Duplicate problem names in config: {sorted(duplicates)}"
+
+
 def test_training_config_feature_guards():
@@ -152,2 +165 @@
     )
-
apply_patch(auto_approved=true) exited 0 in 109ms:
Success. Updated the following files:
M tests/test_training_config_features.py
file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..dc5fa3ecfb113878ba721fd47fdf8337d4c2abd2
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -398,27 +454,6 @@
       - 'travel_rest_days'
       - 'travel_rest_days_l3'
       - 'rest_days_since_last_game'
-      - 'team_red_zone_'
-      - 'team_goal_to_go_'
-      - 'player_red_zone_'
-      - 'player_goal_to_go_'
-      - 'weather_bad_passing_flag'
-    columns_to_discard: *columns_to_discard
-    feature_prefixes_to_include:
-      - 'pred_'
-      - 'expected_'
-      - 'opp_def_'
-      - 'red_zone_'
-      - 'goal_to_go_'
-      - 'off_ctx_'
-      - 'qb_profile_'
-      - 'weather_'
-    other_features_to_include:
-      - 'week'
-      - 'season'
-      - 'position'
-      - 'total_line'
-      - 'team_implied_total'
       - 'team_red_zone_'
       - 'team_goal_to_go_'
       - 'player_red_zone_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..208733668f46e0f2359cf19bbfb0e59d9c7f2f7c
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1369,28 +1375,6 @@
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
 
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
-
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
     if "decision_cutoff_ts" in enriched.columns:
@@ -2331,28 +2315,37 @@
              
     return adj
 
-def _predict_for_problem(features: pd.DataFrame, problem_name: str, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+def _predict_for_problem(features: pd.DataFrame, problem_config: dict, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+    """Load the trained model and return probability or point forecasts based on task metadata."""
+    problem_name = problem_config.get("name", "<unknown>")
+    task_type = str(
+        problem_config.get("task_type")
+        or artifacts.get("task_type")
+        or ""
+    ).lower()
+    output_mode = artifacts.get("output_mode") or problem_config.get("output_mode")
+
     X, _ = _prepare_feature_matrix(features, artifacts)
-    
     model = joblib.load(_latest_model_path(problem_name))
-    
-    # Assuming XGBoost or similar with predict_proba for classification and predict for regression
-    # But for simplicity and compatibility with regression, check model type or problem definition?
-    # Actually, regression models in sklearn/xgb return values directly on predict().
-    # Classification models return class labels on predict(), and probas on predict_proba().
-    
-    try:
-        # Heuristic: Try predict_proba first if it looks like a classifier (anytime_td)
-        # But we need to know task type.
-        if "anytime_td" in problem_name:
-             proba = model.predict_proba(X)[:, 1]
+
+    is_classification = task_type in {"classification", "binary", "multiclass"}
+    if is_classification:
+        if hasattr(model, "predict_proba"):
+            preds = model.predict_proba(X)
+            if preds.ndim > 1 and preds.shape[1] > 1:
+                preds = preds[:, 1]
         else:
-             proba = model.predict(X)
-    except AttributeError:
-        proba = model.predict(X)
-        
-    return proba
+            preds = model.predict(X)
+        preds = np.asarray(preds, dtype=float)
+        preds = np.clip(preds, 0.0, 1.0)
+    else:
+        preds = np.asarray(model.predict(X), dtype=float)
 
+    if output_mode and output_mode == "logit":
+        preds = 1.0 / (1.0 + np.exp(-preds))
+
+    return preds
+
 def main() -> None:
     _ensure_imports_ready()
     args = _parse_args()
@@ -2401,7 +2394,7 @@
                 logger.warning("Skipping %s (artifacts not found).", p_name)
                 continue
 
-            preds = _predict_for_problem(features, p_name, artifacts)
+            preds = _predict_for_problem(features, problem, artifacts)
             
             # Apply guards for availability components immediately
             if p_name == "availability_active":
diff --git a/pipeline/train.py b/pipeline/train.py
index 2e2508f5ee50bf4b1877b56465304ecac80dc0bb..30c70ab8292088cc8aad350882ef2c5e8cc7efa6
--- a/pipeline/train.py
+++ b/pipeline/train.py
@@ -2073,7 +2073,7 @@
 
         # --- Save inference artifacts AFTER all models for the problem are trained ---
         # This ensures the state (imputation, categories) is from the pre-tuning/pre-holdout phase.
-        save_inference_artifacts(self, problem_name)
+        save_inference_artifacts(self, problem_name, problem_copy)
 
     def _unwrap_base_model(self, model):
         """Return the true fitted estimator, no matter how it's wrapped."""
@@ -2334,7 +2334,7 @@
                     logger.warning("Failed to initialise team total scaling for %s: %s", problem_name, exc)
             if not use_cached_for_problem:
                 self._fit_feature_artifacts(df_train, problem_copy)
-                save_inference_artifacts(self, problem_name)
+                save_inference_artifacts(self, problem_name, problem_copy)
 
             # Log final feature list used
             logger.info(f"--- Using {len(self.feature_columns)} features for {problem_name} ---")
@@ -2697,4 +2697,4 @@
             train(config_path=args.config, ordinal_only=args.ordinal_only, ordinal_ev=ordinal_ev_flag, **overrides)
     except Exception as e:
         logger.critical(f"The pipeline has failed with a critical error: {e}", exc_info=True)
-        sys.exit(1)
\ No newline at end of file
+        sys.exit(1)
diff --git a/tests/test_training_config_features.py b/tests/test_training_config_features.py
index c8dc5f3391185bd24a48956183ded4d5174f984d..dd8c776865d65c634372027b6214bcb5226dc70a
--- a/tests/test_training_config_features.py
+++ b/tests/test_training_config_features.py
@@ -14,6 +14,19 @@
         return yaml.safe_load(fh)
 
 
+def test_problem_names_unique():
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    names = [p.get("name") for p in problems]
+    seen = {}
+    duplicates = set()
+    for name in names:
+        if name in seen:
+            duplicates.add(name)
+        seen[name] = True
+    assert not duplicates, f"Duplicate problem names in config: {sorted(duplicates)}"
+
+
 def test_training_config_feature_guards():
     """Ensure columns_to_discard and other_features_to_include don't overlap."""
     training_cfg = _load_training_config()
@@ -150,4 +163,3 @@
         "As-of snapshot coverage dropped below expected thresholds: "
         f"{coverage_failures}"
     )
-
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..eb5471f38ae1512ba5cabf81e6baf81aab0e986b
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -44,18 +44,31 @@
             formatted[k] = v
     return formatted
 
-def save_inference_artifacts(trainer, problem_name: str) -> None:
+def save_inference_artifacts(trainer, problem_name: str, problem_config: dict | None = None) -> None:
     # Versioned artifact copy
     v_dir = _vdir(trainer, problem_name, None, "artifacts") / "inference"
     v_dir.mkdir(parents=True, exist_ok=True)
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync

file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..dc5fa3ecfb113878ba721fd47fdf8337d4c2abd2
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -398,27 +454,6 @@
       - 'travel_rest_days'
       - 'travel_rest_days_l3'
       - 'rest_days_since_last_game'
-      - 'team_red_zone_'
-      - 'team_goal_to_go_'
-      - 'player_red_zone_'
-      - 'player_goal_to_go_'
-      - 'weather_bad_passing_flag'
-    columns_to_discard: *columns_to_discard
-    feature_prefixes_to_include:
-      - 'pred_'
-      - 'expected_'
-      - 'opp_def_'
-      - 'red_zone_'
-      - 'goal_to_go_'
-      - 'off_ctx_'
-      - 'qb_profile_'
-      - 'weather_'
-    other_features_to_include:
-      - 'week'
-      - 'season'
-      - 'position'
-      - 'total_line'
-      - 'team_implied_total'
       - 'team_red_zone_'
       - 'team_goal_to_go_'
       - 'player_red_zone_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..208733668f46e0f2359cf19bbfb0e59d9c7f2f7c
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1369,28 +1375,6 @@
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
 
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
-
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
     if "decision_cutoff_ts" in enriched.columns:
@@ -2331,28 +2315,37 @@
              
     return adj
 
-def _predict_for_problem(features: pd.DataFrame, problem_name: str, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+def _predict_for_problem(features: pd.DataFrame, problem_config: dict, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+    """Load the trained model and return probability or point forecasts based on task metadata."""
+    problem_name = problem_config.get("name", "<unknown>")
+    task_type = str(
+        problem_config.get("task_type")
+        or artifacts.get("task_type")
+        or ""
+    ).lower()
+    output_mode = artifacts.get("output_mode") or problem_config.get("output_mode")
+
     X, _ = _prepare_feature_matrix(features, artifacts)
-    
     model = joblib.load(_latest_model_path(problem_name))
-    
-    # Assuming XGBoost or similar with predict_proba for classification and predict for regression
-    # But for simplicity and compatibility with regression, check model type or problem definition?
-    # Actually, regression models in sklearn/xgb return values directly on predict().
-    # Classification models return class labels on predict(), and probas on predict_proba().
-    
-    try:
-        # Heuristic: Try predict_proba first if it looks like a classifier (anytime_td)
-        # But we need to know task type.
-        if "anytime_td" in problem_name:
-             proba = model.predict_proba(X)[:, 1]
+
+    is_classification = task_type in {"classification", "binary", "multiclass"}
+    if is_classification:
+        if hasattr(model, "predict_proba"):
+            preds = model.predict_proba(X)
+            if preds.ndim > 1 and preds.shape[1] > 1:
+                preds = preds[:, 1]
         else:
-             proba = model.predict(X)
-    except AttributeError:
-        proba = model.predict(X)
-        
-    return proba
+            preds = model.predict(X)
+        preds = np.asarray(preds, dtype=float)
+        preds = np.clip(preds, 0.0, 1.0)
+    else:
+        preds = np.asarray(model.predict(X), dtype=float)
 
+    if output_mode and output_mode == "logit":
+        preds = 1.0 / (1.0 + np.exp(-preds))
+
+    return preds
+
 def main() -> None:
     _ensure_imports_ready()
     args = _parse_args()
@@ -2401,7 +2394,7 @@
                 logger.warning("Skipping %s (artifacts not found).", p_name)
                 continue
 
-            preds = _predict_for_problem(features, p_name, artifacts)
+            preds = _predict_for_problem(features, problem, artifacts)
             
             # Apply guards for availability components immediately
             if p_name == "availability_active":
diff --git a/pipeline/train.py b/pipeline/train.py
index 2e2508f5ee50bf4b1877b56465304ecac80dc0bb..30c70ab8292088cc8aad350882ef2c5e8cc7efa6
--- a/pipeline/train.py
+++ b/pipeline/train.py
@@ -2073,7 +2073,7 @@
 
         # --- Save inference artifacts AFTER all models for the problem are trained ---
         # This ensures the state (imputation, categories) is from the pre-tuning/pre-holdout phase.
-        save_inference_artifacts(self, problem_name)
+        save_inference_artifacts(self, problem_name, problem_copy)
 
     def _unwrap_base_model(self, model):
         """Return the true fitted estimator, no matter how it's wrapped."""
@@ -2334,7 +2334,7 @@
                     logger.warning("Failed to initialise team total scaling for %s: %s", problem_name, exc)
             if not use_cached_for_problem:
                 self._fit_feature_artifacts(df_train, problem_copy)
-                save_inference_artifacts(self, problem_name)
+                save_inference_artifacts(self, problem_name, problem_copy)
 
             # Log final feature list used
             logger.info(f"--- Using {len(self.feature_columns)} features for {problem_name} ---")
@@ -2697,4 +2697,4 @@
             train(config_path=args.config, ordinal_only=args.ordinal_only, ordinal_ev=ordinal_ev_flag, **overrides)
     except Exception as e:
         logger.critical(f"The pipeline has failed with a critical error: {e}", exc_info=True)
-        sys.exit(1)
\ No newline at end of file
+        sys.exit(1)
diff --git a/tests/test_training_config_features.py b/tests/test_training_config_features.py
index c8dc5f3391185bd24a48956183ded4d5174f984d..dd8c776865d65c634372027b6214bcb5226dc70a
--- a/tests/test_training_config_features.py
+++ b/tests/test_training_config_features.py
@@ -14,6 +14,19 @@
         return yaml.safe_load(fh)
 
 
+def test_problem_names_unique():
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    names = [p.get("name") for p in problems]
+    seen = {}
+    duplicates = set()
+    for name in names:
+        if name in seen:
+            duplicates.add(name)
+        seen[name] = True
+    assert not duplicates, f"Duplicate problem names in config: {sorted(duplicates)}"
+
+
 def test_training_config_feature_guards():
     """Ensure columns_to_discard and other_features_to_include don't overlap."""
     training_cfg = _load_training_config()
@@ -150,4 +163,3 @@
         "As-of snapshot coverage dropped below expected thresholds: "
         f"{coverage_failures}"
     )
-
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..eb5471f38ae1512ba5cabf81e6baf81aab0e986b
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -44,18 +44,31 @@
             formatted[k] = v
     return formatted
 
-def save_inference_artifacts(trainer, problem_name: str) -> None:
+def save_inference_artifacts(trainer, problem_name: str, problem_config: dict | None = None) -> None:
     # Versioned artifact copy
     v_dir = _vdir(trainer, problem_name, None, "artifacts") / "inference"
     v_dir.mkdir(parents=True, exist_ok=True)
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync


thinking
**Adding test for classification probabilities**

I’m creating a new test file to verify that classification prediction uses `predict_proba` correctly. I’ll mock the model and loading functions with monkeypatch, check calls to `predict_proba` vs `predict`, and ensure the predicted probabilities are correct type and values. I’ll also ensure feature matrix preparation tolerates missing meta columns without errors by filling with None. This will go in `tests/test_predict_probabilities.py`.
file update
A /Users/jameswest/Desktop/nfl_predict/tests/test_predict_probabilities.py
from pathlib import Path

import numpy as np
import pandas as pd

import pipeline.predict as predict


def test_predict_for_problem_uses_predict_proba(monkeypatch):
    calls = {"proba": 0, "predict": 0}

    class DummyModel:
        def predict_proba(self, X):
            calls["proba"] += 1
            return np.column_stack([np.zeros(len(X)), np.full(len(X), 0.7)])

        def predict(self, X):
            calls["predict"] += 1
            return np.full(len(X), 0.2)

    monkeypatch.setattr(predict.joblib, "load", lambda path: DummyModel())
    monkeypatch.setattr(predict, "_latest_model_path", lambda name: Path("dummy"))

    artifacts = {"feature_columns": ["a"], "task_type": "classification"}
    df = pd.DataFrame({"a": [0, 1]})

    preds = predict._predict_for_problem(df, {"name": "any", "task_type": "classification"}, artifacts)

    assert calls["proba"] == 1
    assert calls["predict"] == 0
    assert np.allclose(preds, 0.7)
    assert preds.dtype.kind == "f"
apply_patch(auto_approved=true) exited 0 in 121ms:
Success. Updated the following files:
A tests/test_predict_probabilities.py
file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..dc5fa3ecfb113878ba721fd47fdf8337d4c2abd2
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -398,27 +454,6 @@
       - 'travel_rest_days'
       - 'travel_rest_days_l3'
       - 'rest_days_since_last_game'
-      - 'team_red_zone_'
-      - 'team_goal_to_go_'
-      - 'player_red_zone_'
-      - 'player_goal_to_go_'
-      - 'weather_bad_passing_flag'
-    columns_to_discard: *columns_to_discard
-    feature_prefixes_to_include:
-      - 'pred_'
-      - 'expected_'
-      - 'opp_def_'
-      - 'red_zone_'
-      - 'goal_to_go_'
-      - 'off_ctx_'
-      - 'qb_profile_'
-      - 'weather_'
-    other_features_to_include:
-      - 'week'
-      - 'season'
-      - 'position'
-      - 'total_line'
-      - 'team_implied_total'
       - 'team_red_zone_'
       - 'team_goal_to_go_'
       - 'player_red_zone_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..208733668f46e0f2359cf19bbfb0e59d9c7f2f7c
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1369,28 +1375,6 @@
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
 
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
-
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
     if "decision_cutoff_ts" in enriched.columns:
@@ -2331,28 +2315,37 @@
              
     return adj
 
-def _predict_for_problem(features: pd.DataFrame, problem_name: str, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+def _predict_for_problem(features: pd.DataFrame, problem_config: dict, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+    """Load the trained model and return probability or point forecasts based on task metadata."""
+    problem_name = problem_config.get("name", "<unknown>")
+    task_type = str(
+        problem_config.get("task_type")
+        or artifacts.get("task_type")
+        or ""
+    ).lower()
+    output_mode = artifacts.get("output_mode") or problem_config.get("output_mode")
+
     X, _ = _prepare_feature_matrix(features, artifacts)
-    
     model = joblib.load(_latest_model_path(problem_name))
-    
-    # Assuming XGBoost or similar with predict_proba for classification and predict for regression
-    # But for simplicity and compatibility with regression, check model type or problem definition?
-    # Actually, regression models in sklearn/xgb return values directly on predict().
-    # Classification models return class labels on predict(), and probas on predict_proba().
-    
-    try:
-        # Heuristic: Try predict_proba first if it looks like a classifier (anytime_td)
-        # But we need to know task type.
-        if "anytime_td" in problem_name:
-             proba = model.predict_proba(X)[:, 1]
+
+    is_classification = task_type in {"classification", "binary", "multiclass"}
+    if is_classification:
+        if hasattr(model, "predict_proba"):
+            preds = model.predict_proba(X)
+            if preds.ndim > 1 and preds.shape[1] > 1:
+                preds = preds[:, 1]
         else:
-             proba = model.predict(X)
-    except AttributeError:
-        proba = model.predict(X)
-        
-    return proba
+            preds = model.predict(X)
+        preds = np.asarray(preds, dtype=float)
+        preds = np.clip(preds, 0.0, 1.0)
+    else:
+        preds = np.asarray(model.predict(X), dtype=float)
 
+    if output_mode and output_mode == "logit":
+        preds = 1.0 / (1.0 + np.exp(-preds))
+
+    return preds
+
 def main() -> None:
     _ensure_imports_ready()
     args = _parse_args()
@@ -2401,7 +2394,7 @@
                 logger.warning("Skipping %s (artifacts not found).", p_name)
                 continue
 
-            preds = _predict_for_problem(features, p_name, artifacts)
+            preds = _predict_for_problem(features, problem, artifacts)
             
             # Apply guards for availability components immediately
             if p_name == "availability_active":
diff --git a/pipeline/train.py b/pipeline/train.py
index 2e2508f5ee50bf4b1877b56465304ecac80dc0bb..30c70ab8292088cc8aad350882ef2c5e8cc7efa6
--- a/pipeline/train.py
+++ b/pipeline/train.py
@@ -2073,7 +2073,7 @@
 
         # --- Save inference artifacts AFTER all models for the problem are trained ---
         # This ensures the state (imputation, categories) is from the pre-tuning/pre-holdout phase.
-        save_inference_artifacts(self, problem_name)
+        save_inference_artifacts(self, problem_name, problem_copy)
 
     def _unwrap_base_model(self, model):
         """Return the true fitted estimator, no matter how it's wrapped."""
@@ -2334,7 +2334,7 @@
                     logger.warning("Failed to initialise team total scaling for %s: %s", problem_name, exc)
             if not use_cached_for_problem:
                 self._fit_feature_artifacts(df_train, problem_copy)
-                save_inference_artifacts(self, problem_name)
+                save_inference_artifacts(self, problem_name, problem_copy)
 
             # Log final feature list used
             logger.info(f"--- Using {len(self.feature_columns)} features for {problem_name} ---")
@@ -2697,4 +2697,4 @@
             train(config_path=args.config, ordinal_only=args.ordinal_only, ordinal_ev=ordinal_ev_flag, **overrides)
     except Exception as e:
         logger.critical(f"The pipeline has failed with a critical error: {e}", exc_info=True)
-        sys.exit(1)
\ No newline at end of file
+        sys.exit(1)
diff --git a/tests/test_predict_probabilities.py b/tests/test_predict_probabilities.py
new file mode 100644
index 0000000000000000000000000000000000000000..bd68c2fa4ae83bf2ab6533daea100378f36d07f3
--- /dev/null
+++ b/tests/test_predict_probabilities.py
@@ -0,0 +1,32 @@
+from pathlib import Path
+
+import numpy as np
+import pandas as pd
+
+import pipeline.predict as predict
+
+
+def test_predict_for_problem_uses_predict_proba(monkeypatch):
+    calls = {"proba": 0, "predict": 0}
+
+    class DummyModel:
+        def predict_proba(self, X):
+            calls["proba"] += 1
+            return np.column_stack([np.zeros(len(X)), np.full(len(X), 0.7)])
+
+        def predict(self, X):
+            calls["predict"] += 1
+            return np.full(len(X), 0.2)
+
+    monkeypatch.setattr(predict.joblib, "load", lambda path: DummyModel())
+    monkeypatch.setattr(predict, "_latest_model_path", lambda name: Path("dummy"))
+
+    artifacts = {"feature_columns": ["a"], "task_type": "classification"}
+    df = pd.DataFrame({"a": [0, 1]})
+
+    preds = predict._predict_for_problem(df, {"name": "any", "task_type": "classification"}, artifacts)
+
+    assert calls["proba"] == 1
+    assert calls["predict"] == 0
+    assert np.allclose(preds, 0.7)
+    assert preds.dtype.kind == "f"
diff --git a/tests/test_training_config_features.py b/tests/test_training_config_features.py
index c8dc5f3391185bd24a48956183ded4d5174f984d..dd8c776865d65c634372027b6214bcb5226dc70a
--- a/tests/test_training_config_features.py
+++ b/tests/test_training_config_features.py
@@ -14,6 +14,19 @@
         return yaml.safe_load(fh)
 
 
+def test_problem_names_unique():
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    names = [p.get("name") for p in problems]
+    seen = {}
+    duplicates = set()
+    for name in names:
+        if name in seen:
+            duplicates.add(name)
+        seen[name] = True
+    assert not duplicates, f"Duplicate problem names in config: {sorted(duplicates)}"
+
+
 def test_training_config_feature_guards():
     """Ensure columns_to_discard and other_features_to_include don't overlap."""
     training_cfg = _load_training_config()
@@ -150,4 +163,3 @@
         "As-of snapshot coverage dropped below expected thresholds: "
         f"{coverage_failures}"
     )
-
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..eb5471f38ae1512ba5cabf81e6baf81aab0e986b
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -44,18 +44,31 @@
             formatted[k] = v
     return formatted
 
-def save_inference_artifacts(trainer, problem_name: str) -> None:
+def save_inference_artifacts(trainer, problem_name: str, problem_config: dict | None = None) -> None:
     # Versioned artifact copy
     v_dir = _vdir(trainer, problem_name, None, "artifacts") / "inference"
     v_dir.mkdir(parents=True, exist_ok=True)
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync

file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..dc5fa3ecfb113878ba721fd47fdf8337d4c2abd2
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -398,27 +454,6 @@
       - 'travel_rest_days'
       - 'travel_rest_days_l3'
       - 'rest_days_since_last_game'
-      - 'team_red_zone_'
-      - 'team_goal_to_go_'
-      - 'player_red_zone_'
-      - 'player_goal_to_go_'
-      - 'weather_bad_passing_flag'
-    columns_to_discard: *columns_to_discard
-    feature_prefixes_to_include:
-      - 'pred_'
-      - 'expected_'
-      - 'opp_def_'
-      - 'red_zone_'
-      - 'goal_to_go_'
-      - 'off_ctx_'
-      - 'qb_profile_'
-      - 'weather_'
-    other_features_to_include:
-      - 'week'
-      - 'season'
-      - 'position'
-      - 'total_line'
-      - 'team_implied_total'
       - 'team_red_zone_'
       - 'team_goal_to_go_'
       - 'player_red_zone_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..208733668f46e0f2359cf19bbfb0e59d9c7f2f7c
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1369,28 +1375,6 @@
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
 
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
-
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
     if "decision_cutoff_ts" in enriched.columns:
@@ -2331,28 +2315,37 @@
              
     return adj
 
-def _predict_for_problem(features: pd.DataFrame, problem_name: str, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+def _predict_for_problem(features: pd.DataFrame, problem_config: dict, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+    """Load the trained model and return probability or point forecasts based on task metadata."""
+    problem_name = problem_config.get("name", "<unknown>")
+    task_type = str(
+        problem_config.get("task_type")
+        or artifacts.get("task_type")
+        or ""
+    ).lower()
+    output_mode = artifacts.get("output_mode") or problem_config.get("output_mode")
+
     X, _ = _prepare_feature_matrix(features, artifacts)
-    
     model = joblib.load(_latest_model_path(problem_name))
-    
-    # Assuming XGBoost or similar with predict_proba for classification and predict for regression
-    # But for simplicity and compatibility with regression, check model type or problem definition?
-    # Actually, regression models in sklearn/xgb return values directly on predict().
-    # Classification models return class labels on predict(), and probas on predict_proba().
-    
-    try:
-        # Heuristic: Try predict_proba first if it looks like a classifier (anytime_td)
-        # But we need to know task type.
-        if "anytime_td" in problem_name:
-             proba = model.predict_proba(X)[:, 1]
+
+    is_classification = task_type in {"classification", "binary", "multiclass"}
+    if is_classification:
+        if hasattr(model, "predict_proba"):
+            preds = model.predict_proba(X)
+            if preds.ndim > 1 and preds.shape[1] > 1:
+                preds = preds[:, 1]
         else:
-             proba = model.predict(X)
-    except AttributeError:
-        proba = model.predict(X)
-        
-    return proba
+            preds = model.predict(X)
+        preds = np.asarray(preds, dtype=float)
+        preds = np.clip(preds, 0.0, 1.0)
+    else:
+        preds = np.asarray(model.predict(X), dtype=float)
 
+    if output_mode and output_mode == "logit":
+        preds = 1.0 / (1.0 + np.exp(-preds))
+
+    return preds
+
 def main() -> None:
     _ensure_imports_ready()
     args = _parse_args()
@@ -2401,7 +2394,7 @@
                 logger.warning("Skipping %s (artifacts not found).", p_name)
                 continue
 
-            preds = _predict_for_problem(features, p_name, artifacts)
+            preds = _predict_for_problem(features, problem, artifacts)
             
             # Apply guards for availability components immediately
             if p_name == "availability_active":
diff --git a/pipeline/train.py b/pipeline/train.py
index 2e2508f5ee50bf4b1877b56465304ecac80dc0bb..30c70ab8292088cc8aad350882ef2c5e8cc7efa6
--- a/pipeline/train.py
+++ b/pipeline/train.py
@@ -2073,7 +2073,7 @@
 
         # --- Save inference artifacts AFTER all models for the problem are trained ---
         # This ensures the state (imputation, categories) is from the pre-tuning/pre-holdout phase.
-        save_inference_artifacts(self, problem_name)
+        save_inference_artifacts(self, problem_name, problem_copy)
 
     def _unwrap_base_model(self, model):
         """Return the true fitted estimator, no matter how it's wrapped."""
@@ -2334,7 +2334,7 @@
                     logger.warning("Failed to initialise team total scaling for %s: %s", problem_name, exc)
             if not use_cached_for_problem:
                 self._fit_feature_artifacts(df_train, problem_copy)
-                save_inference_artifacts(self, problem_name)
+                save_inference_artifacts(self, problem_name, problem_copy)
 
             # Log final feature list used
             logger.info(f"--- Using {len(self.feature_columns)} features for {problem_name} ---")
@@ -2697,4 +2697,4 @@
             train(config_path=args.config, ordinal_only=args.ordinal_only, ordinal_ev=ordinal_ev_flag, **overrides)
     except Exception as e:
         logger.critical(f"The pipeline has failed with a critical error: {e}", exc_info=True)
-        sys.exit(1)
\ No newline at end of file
+        sys.exit(1)
diff --git a/tests/test_predict_probabilities.py b/tests/test_predict_probabilities.py
new file mode 100644
index 0000000000000000000000000000000000000000..bd68c2fa4ae83bf2ab6533daea100378f36d07f3
--- /dev/null
+++ b/tests/test_predict_probabilities.py
@@ -0,0 +1,32 @@
+from pathlib import Path
+
+import numpy as np
+import pandas as pd
+
+import pipeline.predict as predict
+
+
+def test_predict_for_problem_uses_predict_proba(monkeypatch):
+    calls = {"proba": 0, "predict": 0}
+
+    class DummyModel:
+        def predict_proba(self, X):
+            calls["proba"] += 1
+            return np.column_stack([np.zeros(len(X)), np.full(len(X), 0.7)])
+
+        def predict(self, X):
+            calls["predict"] += 1
+            return np.full(len(X), 0.2)
+
+    monkeypatch.setattr(predict.joblib, "load", lambda path: DummyModel())
+    monkeypatch.setattr(predict, "_latest_model_path", lambda name: Path("dummy"))
+
+    artifacts = {"feature_columns": ["a"], "task_type": "classification"}
+    df = pd.DataFrame({"a": [0, 1]})
+
+    preds = predict._predict_for_problem(df, {"name": "any", "task_type": "classification"}, artifacts)
+
+    assert calls["proba"] == 1
+    assert calls["predict"] == 0
+    assert np.allclose(preds, 0.7)
+    assert preds.dtype.kind == "f"
diff --git a/tests/test_training_config_features.py b/tests/test_training_config_features.py
index c8dc5f3391185bd24a48956183ded4d5174f984d..dd8c776865d65c634372027b6214bcb5226dc70a
--- a/tests/test_training_config_features.py
+++ b/tests/test_training_config_features.py
@@ -14,6 +14,19 @@
         return yaml.safe_load(fh)
 
 
+def test_problem_names_unique():
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    names = [p.get("name") for p in problems]
+    seen = {}
+    duplicates = set()
+    for name in names:
+        if name in seen:
+            duplicates.add(name)
+        seen[name] = True
+    assert not duplicates, f"Duplicate problem names in config: {sorted(duplicates)}"
+
+
 def test_training_config_feature_guards():
     """Ensure columns_to_discard and other_features_to_include don't overlap."""
     training_cfg = _load_training_config()
@@ -150,4 +163,3 @@
         "As-of snapshot coverage dropped below expected thresholds: "
         f"{coverage_failures}"
     )
-
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..eb5471f38ae1512ba5cabf81e6baf81aab0e986b
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -44,18 +44,31 @@
             formatted[k] = v
     return formatted
 
-def save_inference_artifacts(trainer, problem_name: str) -> None:
+def save_inference_artifacts(trainer, problem_name: str, problem_config: dict | None = None) -> None:
     # Versioned artifact copy
     v_dir = _vdir(trainer, problem_name, None, "artifacts") / "inference"
     v_dir.mkdir(parents=True, exist_ok=True)
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync


thinking
**Reviewing column handling and fallback logic**

I'm working through whether new ps_game_ columns need to be included in baseline columns or fallback logic, considering how aliases are created and used in training versus inference pipelines. It seems inference can skip ps_game_ columns since they're targets, but I want to confirm no errors happen and that the fallback and aliasing logic lines up properly with the training setup.

thinking
**Reviewing artifact compatibility and test impacts**
exec
/bin/zsh -lc "sed -n '1,120p' tests/test_rolling_window_extended.py" in /Users/jameswest/Desktop/nfl_predict succeeded in 767ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
# tests/test_rolling_window_extended.py
from __future__ import annotations
import pytest, polars as pl, pandas as pd, numpy as np, random
from datetime import date, timedelta, datetime
from pathlib import Path

from utils.feature import rolling_window as rwmod

pytestmark = pytest.mark.mlb
from utils.feature.pitch_level import RAW_ROOT, PITCH_DIR
from utils.feature.pa_level   import PITCH_SRC, PA_DIR
from utils.feature.game_level import PA_SRC,   GAME_DIR
from pipeline.feature import build_feature_matrix, FINAL_OUT


# ----------------------------------------------------------------------
# Constants that mirror the **pipeline** -------------------------------
# ----------------------------------------------------------------------
WINDOWS          = ["3d", "7d", "30d", "season", "lifetime"]
file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..dc5fa3ecfb113878ba721fd47fdf8337d4c2abd2
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -398,27 +454,6 @@
       - 'travel_rest_days'
       - 'travel_rest_days_l3'
       - 'rest_days_since_last_game'
-      - 'team_red_zone_'
-      - 'team_goal_to_go_'
-      - 'player_red_zone_'
-      - 'player_goal_to_go_'
-      - 'weather_bad_passing_flag'
-    columns_to_discard: *columns_to_discard
-    feature_prefixes_to_include:
-      - 'pred_'
-      - 'expected_'
-      - 'opp_def_'
-      - 'red_zone_'
-      - 'goal_to_go_'
-      - 'off_ctx_'
-      - 'qb_profile_'
-      - 'weather_'
-    other_features_to_include:
-      - 'week'
-      - 'season'
-      - 'position'
-      - 'total_line'
-      - 'team_implied_total'
       - 'team_red_zone_'
       - 'team_goal_to_go_'
       - 'player_red_zone_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..208733668f46e0f2359cf19bbfb0e59d9c7f2f7c
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1369,28 +1375,6 @@
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
 
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
-
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
     if "decision_cutoff_ts" in enriched.columns:
@@ -2331,28 +2315,37 @@
              
     return adj
 
-def _predict_for_problem(features: pd.DataFrame, problem_name: str, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+def _predict_for_problem(features: pd.DataFrame, problem_config: dict, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+    """Load the trained model and return probability or point forecasts based on task metadata."""
+    problem_name = problem_config.get("name", "<unknown>")
+    task_type = str(
+        problem_config.get("task_type")
+        or artifacts.get("task_type")
+        or ""
+    ).lower()
+    output_mode = artifacts.get("output_mode") or problem_config.get("output_mode")
+
     X, _ = _prepare_feature_matrix(features, artifacts)
-    
     model = joblib.load(_latest_model_path(problem_name))
-    
-    # Assuming XGBoost or similar with predict_proba for classification and predict for regression
-    # But for simplicity and compatibility with regression, check model type or problem definition?
-    # Actually, regression models in sklearn/xgb return values directly on predict().
-    # Classification models return class labels on predict(), and probas on predict_proba().
-    
-    try:
-        # Heuristic: Try predict_proba first if it looks like a classifier (anytime_td)
-        # But we need to know task type.
-        if "anytime_td" in problem_name:
-             proba = model.predict_proba(X)[:, 1]
+
+    is_classification = task_type in {"classification", "binary", "multiclass"}
+    if is_classification:
+        if hasattr(model, "predict_proba"):
+            preds = model.predict_proba(X)
+            if preds.ndim > 1 and preds.shape[1] > 1:
+                preds = preds[:, 1]
         else:
-             proba = model.predict(X)
-    except AttributeError:
-        proba = model.predict(X)
-        
-    return proba
+            preds = model.predict(X)
+        preds = np.asarray(preds, dtype=float)
+        preds = np.clip(preds, 0.0, 1.0)
+    else:
+        preds = np.asarray(model.predict(X), dtype=float)
 
+    if output_mode and output_mode == "logit":
+        preds = 1.0 / (1.0 + np.exp(-preds))
+
+    return preds
+
 def main() -> None:
     _ensure_imports_ready()
     args = _parse_args()
@@ -2401,7 +2394,7 @@
                 logger.warning("Skipping %s (artifacts not found).", p_name)
                 continue
 
-            preds = _predict_for_problem(features, p_name, artifacts)
+            preds = _predict_for_problem(features, problem, artifacts)
             
             # Apply guards for availability components immediately
             if p_name == "availability_active":
diff --git a/pipeline/train.py b/pipeline/train.py
index 2e2508f5ee50bf4b1877b56465304ecac80dc0bb..30c70ab8292088cc8aad350882ef2c5e8cc7efa6
--- a/pipeline/train.py
+++ b/pipeline/train.py
@@ -2073,7 +2073,7 @@
 
         # --- Save inference artifacts AFTER all models for the problem are trained ---
         # This ensures the state (imputation, categories) is from the pre-tuning/pre-holdout phase.
-        save_inference_artifacts(self, problem_name)
+        save_inference_artifacts(self, problem_name, problem_copy)
 
     def _unwrap_base_model(self, model):
         """Return the true fitted estimator, no matter how it's wrapped."""
@@ -2334,7 +2334,7 @@
                     logger.warning("Failed to initialise team total scaling for %s: %s", problem_name, exc)
             if not use_cached_for_problem:
                 self._fit_feature_artifacts(df_train, problem_copy)
-                save_inference_artifacts(self, problem_name)
+                save_inference_artifacts(self, problem_name, problem_copy)
 
             # Log final feature list used
             logger.info(f"--- Using {len(self.feature_columns)} features for {problem_name} ---")
@@ -2697,4 +2697,4 @@
             train(config_path=args.config, ordinal_only=args.ordinal_only, ordinal_ev=ordinal_ev_flag, **overrides)
     except Exception as e:
         logger.critical(f"The pipeline has failed with a critical error: {e}", exc_info=True)
-        sys.exit(1)
\ No newline at end of file
+        sys.exit(1)
diff --git a/tests/test_predict_probabilities.py b/tests/test_predict_probabilities.py
new file mode 100644
index 0000000000000000000000000000000000000000..bd68c2fa4ae83bf2ab6533daea100378f36d07f3
--- /dev/null
+++ b/tests/test_predict_probabilities.py
@@ -0,0 +1,32 @@
+from pathlib import Path
+
+import numpy as np
+import pandas as pd
+
+import pipeline.predict as predict
+
+
+def test_predict_for_problem_uses_predict_proba(monkeypatch):
+    calls = {"proba": 0, "predict": 0}
+
+    class DummyModel:
+        def predict_proba(self, X):
+            calls["proba"] += 1
+            return np.column_stack([np.zeros(len(X)), np.full(len(X), 0.7)])
+
+        def predict(self, X):
+            calls["predict"] += 1
+            return np.full(len(X), 0.2)
+
+    monkeypatch.setattr(predict.joblib, "load", lambda path: DummyModel())
+    monkeypatch.setattr(predict, "_latest_model_path", lambda name: Path("dummy"))
+
+    artifacts = {"feature_columns": ["a"], "task_type": "classification"}
+    df = pd.DataFrame({"a": [0, 1]})
+
+    preds = predict._predict_for_problem(df, {"name": "any", "task_type": "classification"}, artifacts)
+
+    assert calls["proba"] == 1
+    assert calls["predict"] == 0
+    assert np.allclose(preds, 0.7)
+    assert preds.dtype.kind == "f"
diff --git a/tests/test_training_config_features.py b/tests/test_training_config_features.py
index c8dc5f3391185bd24a48956183ded4d5174f984d..dd8c776865d65c634372027b6214bcb5226dc70a
--- a/tests/test_training_config_features.py
+++ b/tests/test_training_config_features.py
@@ -14,6 +14,19 @@
         return yaml.safe_load(fh)
 
 
+def test_problem_names_unique():
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    names = [p.get("name") for p in problems]
+    seen = {}
+    duplicates = set()
+    for name in names:
+        if name in seen:
+            duplicates.add(name)
+        seen[name] = True
+    assert not duplicates, f"Duplicate problem names in config: {sorted(duplicates)}"
+
+
 def test_training_config_feature_guards():
     """Ensure columns_to_discard and other_features_to_include don't overlap."""
     training_cfg = _load_training_config()
@@ -150,4 +163,3 @@
         "As-of snapshot coverage dropped below expected thresholds: "
         f"{coverage_failures}"
     )
-
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..eb5471f38ae1512ba5cabf81e6baf81aab0e986b
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -44,18 +44,31 @@
             formatted[k] = v
     return formatted
 
-def save_inference_artifacts(trainer, problem_name: str) -> None:
+def save_inference_artifacts(trainer, problem_name: str, problem_config: dict | None = None) -> None:
     # Versioned artifact copy
     v_dir = _vdir(trainer, problem_name, None, "artifacts") / "inference"
     v_dir.mkdir(parents=True, exist_ok=True)
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync


thinking
**Reviewing feature and test adjustments**
exec
/bin/zsh -lc "sed -n '1,200p' tests/test_data_leak_guard.py" in /Users/jameswest/Desktop/nfl_predict succeeded in 666ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
from __future__ import annotations

import yaml
from pathlib import Path


PROJECT_ROOT = Path(__file__).resolve().parents[1]
TRAINING_CONFIG = PROJECT_ROOT / "config" / "training.yaml"
BANNED_FEATURES = {
    "status",
    "injury_game_status",
    "injury_is_inactive_designation",
    "injury_is_inactive_prob",
    "touchdown_player_id",
}


def _load_training_problem(name: str) -> dict:
    with TRAINING_CONFIG.open("r") as fp:
file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..dc5fa3ecfb113878ba721fd47fdf8337d4c2abd2
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -398,27 +454,6 @@
       - 'travel_rest_days'
       - 'travel_rest_days_l3'
       - 'rest_days_since_last_game'
-      - 'team_red_zone_'
-      - 'team_goal_to_go_'
-      - 'player_red_zone_'
-      - 'player_goal_to_go_'
-      - 'weather_bad_passing_flag'
-    columns_to_discard: *columns_to_discard
-    feature_prefixes_to_include:
-      - 'pred_'
-      - 'expected_'
-      - 'opp_def_'
-      - 'red_zone_'
-      - 'goal_to_go_'
-      - 'off_ctx_'
-      - 'qb_profile_'
-      - 'weather_'
-    other_features_to_include:
-      - 'week'
-      - 'season'
-      - 'position'
-      - 'total_line'
-      - 'team_implied_total'
       - 'team_red_zone_'
       - 'team_goal_to_go_'
       - 'player_red_zone_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..208733668f46e0f2359cf19bbfb0e59d9c7f2f7c
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1369,28 +1375,6 @@
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
 
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
-
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
     if "decision_cutoff_ts" in enriched.columns:
@@ -2331,28 +2315,37 @@
              
     return adj
 
-def _predict_for_problem(features: pd.DataFrame, problem_name: str, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+def _predict_for_problem(features: pd.DataFrame, problem_config: dict, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+    """Load the trained model and return probability or point forecasts based on task metadata."""
+    problem_name = problem_config.get("name", "<unknown>")
+    task_type = str(
+        problem_config.get("task_type")
+        or artifacts.get("task_type")
+        or ""
+    ).lower()
+    output_mode = artifacts.get("output_mode") or problem_config.get("output_mode")
+
     X, _ = _prepare_feature_matrix(features, artifacts)
-    
     model = joblib.load(_latest_model_path(problem_name))
-    
-    # Assuming XGBoost or similar with predict_proba for classification and predict for regression
-    # But for simplicity and compatibility with regression, check model type or problem definition?
-    # Actually, regression models in sklearn/xgb return values directly on predict().
-    # Classification models return class labels on predict(), and probas on predict_proba().
-    
-    try:
-        # Heuristic: Try predict_proba first if it looks like a classifier (anytime_td)
-        # But we need to know task type.
-        if "anytime_td" in problem_name:
-             proba = model.predict_proba(X)[:, 1]
+
+    is_classification = task_type in {"classification", "binary", "multiclass"}
+    if is_classification:
+        if hasattr(model, "predict_proba"):
+            preds = model.predict_proba(X)
+            if preds.ndim > 1 and preds.shape[1] > 1:
+                preds = preds[:, 1]
         else:
-             proba = model.predict(X)
-    except AttributeError:
-        proba = model.predict(X)
-        
-    return proba
+            preds = model.predict(X)
+        preds = np.asarray(preds, dtype=float)
+        preds = np.clip(preds, 0.0, 1.0)
+    else:
+        preds = np.asarray(model.predict(X), dtype=float)
 
+    if output_mode and output_mode == "logit":
+        preds = 1.0 / (1.0 + np.exp(-preds))
+
+    return preds
+
 def main() -> None:
     _ensure_imports_ready()
     args = _parse_args()
@@ -2401,7 +2394,7 @@
                 logger.warning("Skipping %s (artifacts not found).", p_name)
                 continue
 
-            preds = _predict_for_problem(features, p_name, artifacts)
+            preds = _predict_for_problem(features, problem, artifacts)
             
             # Apply guards for availability components immediately
             if p_name == "availability_active":
diff --git a/pipeline/train.py b/pipeline/train.py
index 2e2508f5ee50bf4b1877b56465304ecac80dc0bb..30c70ab8292088cc8aad350882ef2c5e8cc7efa6
--- a/pipeline/train.py
+++ b/pipeline/train.py
@@ -2073,7 +2073,7 @@
 
         # --- Save inference artifacts AFTER all models for the problem are trained ---
         # This ensures the state (imputation, categories) is from the pre-tuning/pre-holdout phase.
-        save_inference_artifacts(self, problem_name)
+        save_inference_artifacts(self, problem_name, problem_copy)
 
     def _unwrap_base_model(self, model):
         """Return the true fitted estimator, no matter how it's wrapped."""
@@ -2334,7 +2334,7 @@
                     logger.warning("Failed to initialise team total scaling for %s: %s", problem_name, exc)
             if not use_cached_for_problem:
                 self._fit_feature_artifacts(df_train, problem_copy)
-                save_inference_artifacts(self, problem_name)
+                save_inference_artifacts(self, problem_name, problem_copy)
 
             # Log final feature list used
             logger.info(f"--- Using {len(self.feature_columns)} features for {problem_name} ---")
@@ -2697,4 +2697,4 @@
             train(config_path=args.config, ordinal_only=args.ordinal_only, ordinal_ev=ordinal_ev_flag, **overrides)
     except Exception as e:
         logger.critical(f"The pipeline has failed with a critical error: {e}", exc_info=True)
-        sys.exit(1)
\ No newline at end of file
+        sys.exit(1)
diff --git a/tests/test_predict_probabilities.py b/tests/test_predict_probabilities.py
new file mode 100644
index 0000000000000000000000000000000000000000..bd68c2fa4ae83bf2ab6533daea100378f36d07f3
--- /dev/null
+++ b/tests/test_predict_probabilities.py
@@ -0,0 +1,32 @@
+from pathlib import Path
+
+import numpy as np
+import pandas as pd
+
+import pipeline.predict as predict
+
+
+def test_predict_for_problem_uses_predict_proba(monkeypatch):
+    calls = {"proba": 0, "predict": 0}
+
+    class DummyModel:
+        def predict_proba(self, X):
+            calls["proba"] += 1
+            return np.column_stack([np.zeros(len(X)), np.full(len(X), 0.7)])
+
+        def predict(self, X):
+            calls["predict"] += 1
+            return np.full(len(X), 0.2)
+
+    monkeypatch.setattr(predict.joblib, "load", lambda path: DummyModel())
+    monkeypatch.setattr(predict, "_latest_model_path", lambda name: Path("dummy"))
+
+    artifacts = {"feature_columns": ["a"], "task_type": "classification"}
+    df = pd.DataFrame({"a": [0, 1]})
+
+    preds = predict._predict_for_problem(df, {"name": "any", "task_type": "classification"}, artifacts)
+
+    assert calls["proba"] == 1
+    assert calls["predict"] == 0
+    assert np.allclose(preds, 0.7)
+    assert preds.dtype.kind == "f"
diff --git a/tests/test_training_config_features.py b/tests/test_training_config_features.py
index c8dc5f3391185bd24a48956183ded4d5174f984d..dd8c776865d65c634372027b6214bcb5226dc70a
--- a/tests/test_training_config_features.py
+++ b/tests/test_training_config_features.py
@@ -14,6 +14,19 @@
         return yaml.safe_load(fh)
 
 
+def test_problem_names_unique():
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    names = [p.get("name") for p in problems]
+    seen = {}
+    duplicates = set()
+    for name in names:
+        if name in seen:
+            duplicates.add(name)
+        seen[name] = True
+    assert not duplicates, f"Duplicate problem names in config: {sorted(duplicates)}"
+
+
 def test_training_config_feature_guards():
     """Ensure columns_to_discard and other_features_to_include don't overlap."""
     training_cfg = _load_training_config()
@@ -150,4 +163,3 @@
         "As-of snapshot coverage dropped below expected thresholds: "
         f"{coverage_failures}"
     )
-
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..eb5471f38ae1512ba5cabf81e6baf81aab0e986b
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -44,18 +44,31 @@
             formatted[k] = v
     return formatted
 
-def save_inference_artifacts(trainer, problem_name: str) -> None:
+def save_inference_artifacts(trainer, problem_name: str, problem_config: dict | None = None) -> None:
     # Versioned artifact copy
     v_dir = _vdir(trainer, problem_name, None, "artifacts") / "inference"
     v_dir.mkdir(parents=True, exist_ok=True)
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync


thinking
**Verifying target columns and pipeline updates**
exec
/bin/zsh -lc 'rg -n "validate_target_columns"' in /Users/jameswest/Desktop/nfl_predict succeeded in 700ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
pipeline/feature.py:29:from utils.feature.targets import validate_target_columns
pipeline/feature.py:815:    df_player_game_all = validate_target_columns(df_player_game_all, strict=False)
codex_output.md:6722: from utils.feature.targets import validate_target_columns
codex_output.md:6826: from utils.feature.targets import validate_target_columns
codex_output.md:6953: from utils.feature.targets import validate_target_columns
codex_output.md:7080: from utils.feature.targets import validate_target_columns
codex_output.md:7227: from utils.feature.targets import validate_target_columns
codex_output.md:7371: from utils.feature.targets import validate_target_columns
codex_output.md:7533: from utils.feature.targets import validate_target_columns
codex_output.md:7695: from utils.feature.targets import validate_target_columns
codex_output.md:7870: from utils.feature.targets import validate_target_columns
codex_output.md:8041: from utils.feature.targets import validate_target_columns
codex_output.md:8220: from utils.feature.targets import validate_target_columns
codex_output.md:8398: from utils.feature.targets import validate_target_columns
codex_output.md:8753: from utils.feature.targets import validate_target_columns
codex_output.md:9024: from utils.feature.targets import validate_target_columns
codex_output.md:9302: from utils.feature.targets import validate_target_columns
codex_output.md:9591: from utils.feature.targets import validate_target_columns
codex_output.md:9856: from utils.feature.targets import validate_target_columns
file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..dc5fa3ecfb113878ba721fd47fdf8337d4c2abd2
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -398,27 +454,6 @@
       - 'travel_rest_days'
       - 'travel_rest_days_l3'
       - 'rest_days_since_last_game'
-      - 'team_red_zone_'
-      - 'team_goal_to_go_'
-      - 'player_red_zone_'
-      - 'player_goal_to_go_'
-      - 'weather_bad_passing_flag'
-    columns_to_discard: *columns_to_discard
-    feature_prefixes_to_include:
-      - 'pred_'
-      - 'expected_'
-      - 'opp_def_'
-      - 'red_zone_'
-      - 'goal_to_go_'
-      - 'off_ctx_'
-      - 'qb_profile_'
-      - 'weather_'
-    other_features_to_include:
-      - 'week'
-      - 'season'
-      - 'position'
-      - 'total_line'
-      - 'team_implied_total'
       - 'team_red_zone_'
       - 'team_goal_to_go_'
       - 'player_red_zone_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..208733668f46e0f2359cf19bbfb0e59d9c7f2f7c
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1369,28 +1375,6 @@
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
 
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
-
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
     if "decision_cutoff_ts" in enriched.columns:
@@ -2331,28 +2315,37 @@
              
     return adj
 
-def _predict_for_problem(features: pd.DataFrame, problem_name: str, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+def _predict_for_problem(features: pd.DataFrame, problem_config: dict, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+    """Load the trained model and return probability or point forecasts based on task metadata."""
+    problem_name = problem_config.get("name", "<unknown>")
+    task_type = str(
+        problem_config.get("task_type")
+        or artifacts.get("task_type")
+        or ""
+    ).lower()
+    output_mode = artifacts.get("output_mode") or problem_config.get("output_mode")
+
     X, _ = _prepare_feature_matrix(features, artifacts)
-    
     model = joblib.load(_latest_model_path(problem_name))
-    
-    # Assuming XGBoost or similar with predict_proba for classification and predict for regression
-    # But for simplicity and compatibility with regression, check model type or problem definition?
-    # Actually, regression models in sklearn/xgb return values directly on predict().
-    # Classification models return class labels on predict(), and probas on predict_proba().
-    
-    try:
-        # Heuristic: Try predict_proba first if it looks like a classifier (anytime_td)
-        # But we need to know task type.
-        if "anytime_td" in problem_name:
-             proba = model.predict_proba(X)[:, 1]
+
+    is_classification = task_type in {"classification", "binary", "multiclass"}
+    if is_classification:
+        if hasattr(model, "predict_proba"):
+            preds = model.predict_proba(X)
+            if preds.ndim > 1 and preds.shape[1] > 1:
+                preds = preds[:, 1]
         else:
-             proba = model.predict(X)
-    except AttributeError:
-        proba = model.predict(X)
-        
-    return proba
+            preds = model.predict(X)
+        preds = np.asarray(preds, dtype=float)
+        preds = np.clip(preds, 0.0, 1.0)
+    else:
+        preds = np.asarray(model.predict(X), dtype=float)
 
+    if output_mode and output_mode == "logit":
+        preds = 1.0 / (1.0 + np.exp(-preds))
+
+    return preds
+
 def main() -> None:
     _ensure_imports_ready()
     args = _parse_args()
@@ -2401,7 +2394,7 @@
                 logger.warning("Skipping %s (artifacts not found).", p_name)
                 continue
 
-            preds = _predict_for_problem(features, p_name, artifacts)
+            preds = _predict_for_problem(features, problem, artifacts)
             
             # Apply guards for availability components immediately
             if p_name == "availability_active":
diff --git a/pipeline/train.py b/pipeline/train.py
index 2e2508f5ee50bf4b1877b56465304ecac80dc0bb..30c70ab8292088cc8aad350882ef2c5e8cc7efa6
--- a/pipeline/train.py
+++ b/pipeline/train.py
@@ -2073,7 +2073,7 @@
 
         # --- Save inference artifacts AFTER all models for the problem are trained ---
         # This ensures the state (imputation, categories) is from the pre-tuning/pre-holdout phase.
-        save_inference_artifacts(self, problem_name)
+        save_inference_artifacts(self, problem_name, problem_copy)
 
     def _unwrap_base_model(self, model):
         """Return the true fitted estimator, no matter how it's wrapped."""
@@ -2334,7 +2334,7 @@
                     logger.warning("Failed to initialise team total scaling for %s: %s", problem_name, exc)
             if not use_cached_for_problem:
                 self._fit_feature_artifacts(df_train, problem_copy)
-                save_inference_artifacts(self, problem_name)
+                save_inference_artifacts(self, problem_name, problem_copy)
 
             # Log final feature list used
             logger.info(f"--- Using {len(self.feature_columns)} features for {problem_name} ---")
@@ -2697,4 +2697,4 @@
             train(config_path=args.config, ordinal_only=args.ordinal_only, ordinal_ev=ordinal_ev_flag, **overrides)
     except Exception as e:
         logger.critical(f"The pipeline has failed with a critical error: {e}", exc_info=True)
-        sys.exit(1)
\ No newline at end of file
+        sys.exit(1)
diff --git a/tests/test_predict_probabilities.py b/tests/test_predict_probabilities.py
new file mode 100644
index 0000000000000000000000000000000000000000..bd68c2fa4ae83bf2ab6533daea100378f36d07f3
--- /dev/null
+++ b/tests/test_predict_probabilities.py
@@ -0,0 +1,32 @@
+from pathlib import Path
+
+import numpy as np
+import pandas as pd
+
+import pipeline.predict as predict
+
+
+def test_predict_for_problem_uses_predict_proba(monkeypatch):
+    calls = {"proba": 0, "predict": 0}
+
+    class DummyModel:
+        def predict_proba(self, X):
+            calls["proba"] += 1
+            return np.column_stack([np.zeros(len(X)), np.full(len(X), 0.7)])
+
+        def predict(self, X):
+            calls["predict"] += 1
+            return np.full(len(X), 0.2)
+
+    monkeypatch.setattr(predict.joblib, "load", lambda path: DummyModel())
+    monkeypatch.setattr(predict, "_latest_model_path", lambda name: Path("dummy"))
+
+    artifacts = {"feature_columns": ["a"], "task_type": "classification"}
+    df = pd.DataFrame({"a": [0, 1]})
+
+    preds = predict._predict_for_problem(df, {"name": "any", "task_type": "classification"}, artifacts)
+
+    assert calls["proba"] == 1
+    assert calls["predict"] == 0
+    assert np.allclose(preds, 0.7)
+    assert preds.dtype.kind == "f"
diff --git a/tests/test_training_config_features.py b/tests/test_training_config_features.py
index c8dc5f3391185bd24a48956183ded4d5174f984d..dd8c776865d65c634372027b6214bcb5226dc70a
--- a/tests/test_training_config_features.py
+++ b/tests/test_training_config_features.py
@@ -14,6 +14,19 @@
         return yaml.safe_load(fh)
 
 
+def test_problem_names_unique():
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    names = [p.get("name") for p in problems]
+    seen = {}
+    duplicates = set()
+    for name in names:
+        if name in seen:
+            duplicates.add(name)
+        seen[name] = True
+    assert not duplicates, f"Duplicate problem names in config: {sorted(duplicates)}"
+
+
 def test_training_config_feature_guards():
     """Ensure columns_to_discard and other_features_to_include don't overlap."""
     training_cfg = _load_training_config()
@@ -150,4 +163,3 @@
         "As-of snapshot coverage dropped below expected thresholds: "
         f"{coverage_failures}"
     )
-
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..eb5471f38ae1512ba5cabf81e6baf81aab0e986b
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -44,18 +44,31 @@
             formatted[k] = v
     return formatted
 
-def save_inference_artifacts(trainer, problem_name: str) -> None:
+def save_inference_artifacts(trainer, problem_name: str, problem_config: dict | None = None) -> None:
     # Versioned artifact copy
     v_dir = _vdir(trainer, problem_name, None, "artifacts") / "inference"
     v_dir.mkdir(parents=True, exist_ok=True)
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync


thinking
**Inspecting target list in targets.py**
exec
/bin/zsh -lc "sed -n '1,120p' utils/feature/targets.py" in /Users/jameswest/Desktop/nfl_predict succeeded in 653ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
"""Target column validation for NFL player prediction models.

Target columns are created in utils/feature/player_game_level.py during aggregation.
This module validates that required targets exist and have correct dtypes.
"""

import polars as pl
import logging

logger = logging.getLogger(__name__)


# Expected target columns and their types
NFL_TARGET_SCHEMA = {
    # Binary classification targets
    "anytime_td": pl.Int8,  # Primary MVP target: did player score a TD?
    
    # Count/regression targets
    "td_count": pl.Int64,  # Number of TDs scored (receiving + rushing)
file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..dc5fa3ecfb113878ba721fd47fdf8337d4c2abd2
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -398,27 +454,6 @@
       - 'travel_rest_days'
       - 'travel_rest_days_l3'
       - 'rest_days_since_last_game'
-      - 'team_red_zone_'
-      - 'team_goal_to_go_'
-      - 'player_red_zone_'
-      - 'player_goal_to_go_'
-      - 'weather_bad_passing_flag'
-    columns_to_discard: *columns_to_discard
-    feature_prefixes_to_include:
-      - 'pred_'
-      - 'expected_'
-      - 'opp_def_'
-      - 'red_zone_'
-      - 'goal_to_go_'
-      - 'off_ctx_'
-      - 'qb_profile_'
-      - 'weather_'
-    other_features_to_include:
-      - 'week'
-      - 'season'
-      - 'position'
-      - 'total_line'
-      - 'team_implied_total'
       - 'team_red_zone_'
       - 'team_goal_to_go_'
       - 'player_red_zone_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..208733668f46e0f2359cf19bbfb0e59d9c7f2f7c
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1369,28 +1375,6 @@
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
 
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
-
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
     if "decision_cutoff_ts" in enriched.columns:
@@ -2331,28 +2315,37 @@
              
     return adj
 
-def _predict_for_problem(features: pd.DataFrame, problem_name: str, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+def _predict_for_problem(features: pd.DataFrame, problem_config: dict, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+    """Load the trained model and return probability or point forecasts based on task metadata."""
+    problem_name = problem_config.get("name", "<unknown>")
+    task_type = str(
+        problem_config.get("task_type")
+        or artifacts.get("task_type")
+        or ""
+    ).lower()
+    output_mode = artifacts.get("output_mode") or problem_config.get("output_mode")
+
     X, _ = _prepare_feature_matrix(features, artifacts)
-    
     model = joblib.load(_latest_model_path(problem_name))
-    
-    # Assuming XGBoost or similar with predict_proba for classification and predict for regression
-    # But for simplicity and compatibility with regression, check model type or problem definition?
-    # Actually, regression models in sklearn/xgb return values directly on predict().
-    # Classification models return class labels on predict(), and probas on predict_proba().
-    
-    try:
-        # Heuristic: Try predict_proba first if it looks like a classifier (anytime_td)
-        # But we need to know task type.
-        if "anytime_td" in problem_name:
-             proba = model.predict_proba(X)[:, 1]
+
+    is_classification = task_type in {"classification", "binary", "multiclass"}
+    if is_classification:
+        if hasattr(model, "predict_proba"):
+            preds = model.predict_proba(X)
+            if preds.ndim > 1 and preds.shape[1] > 1:
+                preds = preds[:, 1]
         else:
-             proba = model.predict(X)
-    except AttributeError:
-        proba = model.predict(X)
-        
-    return proba
+            preds = model.predict(X)
+        preds = np.asarray(preds, dtype=float)
+        preds = np.clip(preds, 0.0, 1.0)
+    else:
+        preds = np.asarray(model.predict(X), dtype=float)
 
+    if output_mode and output_mode == "logit":
+        preds = 1.0 / (1.0 + np.exp(-preds))
+
+    return preds
+
 def main() -> None:
     _ensure_imports_ready()
     args = _parse_args()
@@ -2401,7 +2394,7 @@
                 logger.warning("Skipping %s (artifacts not found).", p_name)
                 continue
 
-            preds = _predict_for_problem(features, p_name, artifacts)
+            preds = _predict_for_problem(features, problem, artifacts)
             
             # Apply guards for availability components immediately
             if p_name == "availability_active":
diff --git a/pipeline/train.py b/pipeline/train.py
index 2e2508f5ee50bf4b1877b56465304ecac80dc0bb..30c70ab8292088cc8aad350882ef2c5e8cc7efa6
--- a/pipeline/train.py
+++ b/pipeline/train.py
@@ -2073,7 +2073,7 @@
 
         # --- Save inference artifacts AFTER all models for the problem are trained ---
         # This ensures the state (imputation, categories) is from the pre-tuning/pre-holdout phase.
-        save_inference_artifacts(self, problem_name)
+        save_inference_artifacts(self, problem_name, problem_copy)
 
     def _unwrap_base_model(self, model):
         """Return the true fitted estimator, no matter how it's wrapped."""
@@ -2334,7 +2334,7 @@
                     logger.warning("Failed to initialise team total scaling for %s: %s", problem_name, exc)
             if not use_cached_for_problem:
                 self._fit_feature_artifacts(df_train, problem_copy)
-                save_inference_artifacts(self, problem_name)
+                save_inference_artifacts(self, problem_name, problem_copy)
 
             # Log final feature list used
             logger.info(f"--- Using {len(self.feature_columns)} features for {problem_name} ---")
@@ -2697,4 +2697,4 @@
             train(config_path=args.config, ordinal_only=args.ordinal_only, ordinal_ev=ordinal_ev_flag, **overrides)
     except Exception as e:
         logger.critical(f"The pipeline has failed with a critical error: {e}", exc_info=True)
-        sys.exit(1)
\ No newline at end of file
+        sys.exit(1)
diff --git a/tests/test_predict_probabilities.py b/tests/test_predict_probabilities.py
new file mode 100644
index 0000000000000000000000000000000000000000..bd68c2fa4ae83bf2ab6533daea100378f36d07f3
--- /dev/null
+++ b/tests/test_predict_probabilities.py
@@ -0,0 +1,32 @@
+from pathlib import Path
+
+import numpy as np
+import pandas as pd
+
+import pipeline.predict as predict
+
+
+def test_predict_for_problem_uses_predict_proba(monkeypatch):
+    calls = {"proba": 0, "predict": 0}
+
+    class DummyModel:
+        def predict_proba(self, X):
+            calls["proba"] += 1
+            return np.column_stack([np.zeros(len(X)), np.full(len(X), 0.7)])
+
+        def predict(self, X):
+            calls["predict"] += 1
+            return np.full(len(X), 0.2)
+
+    monkeypatch.setattr(predict.joblib, "load", lambda path: DummyModel())
+    monkeypatch.setattr(predict, "_latest_model_path", lambda name: Path("dummy"))
+
+    artifacts = {"feature_columns": ["a"], "task_type": "classification"}
+    df = pd.DataFrame({"a": [0, 1]})
+
+    preds = predict._predict_for_problem(df, {"name": "any", "task_type": "classification"}, artifacts)
+
+    assert calls["proba"] == 1
+    assert calls["predict"] == 0
+    assert np.allclose(preds, 0.7)
+    assert preds.dtype.kind == "f"
diff --git a/tests/test_training_config_features.py b/tests/test_training_config_features.py
index c8dc5f3391185bd24a48956183ded4d5174f984d..dd8c776865d65c634372027b6214bcb5226dc70a
--- a/tests/test_training_config_features.py
+++ b/tests/test_training_config_features.py
@@ -14,6 +14,19 @@
         return yaml.safe_load(fh)
 
 
+def test_problem_names_unique():
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    names = [p.get("name") for p in problems]
+    seen = {}
+    duplicates = set()
+    for name in names:
+        if name in seen:
+            duplicates.add(name)
+        seen[name] = True
+    assert not duplicates, f"Duplicate problem names in config: {sorted(duplicates)}"
+
+
 def test_training_config_feature_guards():
     """Ensure columns_to_discard and other_features_to_include don't overlap."""
     training_cfg = _load_training_config()
@@ -150,4 +163,3 @@
         "As-of snapshot coverage dropped below expected thresholds: "
         f"{coverage_failures}"
     )
-
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..eb5471f38ae1512ba5cabf81e6baf81aab0e986b
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -44,18 +44,31 @@
             formatted[k] = v
     return formatted
 
-def save_inference_artifacts(trainer, problem_name: str) -> None:
+def save_inference_artifacts(trainer, problem_name: str, problem_config: dict | None = None) -> None:
     # Versioned artifact copy
     v_dir = _vdir(trainer, problem_name, None, "artifacts") / "inference"
     v_dir.mkdir(parents=True, exist_ok=True)
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync


thinking
**Evaluating target columns and constants updates**
exec
/bin/zsh -lc 'tail -n 40 utils/general/constants.py' in /Users/jameswest/Desktop/nfl_predict succeeded in 761ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
NFL_TARGET_COLUMNS: Tuple[str, ...] = (
    'anytime_td',
    'td_count',
    'receiving_yards',
    'rushing_yards',
    'passing_yards',
    'target',
    'carry',
    'reception',
    'offense_pct',
)

IDENTIFIER_COLUMNS: Tuple[str, ...] = (
    'game_date',
    'game_id',
    'player_id',
    'player_name',
    'team',
    'opponent',
file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..dc5fa3ecfb113878ba721fd47fdf8337d4c2abd2
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -398,27 +454,6 @@
       - 'travel_rest_days'
       - 'travel_rest_days_l3'
       - 'rest_days_since_last_game'
-      - 'team_red_zone_'
-      - 'team_goal_to_go_'
-      - 'player_red_zone_'
-      - 'player_goal_to_go_'
-      - 'weather_bad_passing_flag'
-    columns_to_discard: *columns_to_discard
-    feature_prefixes_to_include:
-      - 'pred_'
-      - 'expected_'
-      - 'opp_def_'
-      - 'red_zone_'
-      - 'goal_to_go_'
-      - 'off_ctx_'
-      - 'qb_profile_'
-      - 'weather_'
-    other_features_to_include:
-      - 'week'
-      - 'season'
-      - 'position'
-      - 'total_line'
-      - 'team_implied_total'
       - 'team_red_zone_'
       - 'team_goal_to_go_'
       - 'player_red_zone_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..208733668f46e0f2359cf19bbfb0e59d9c7f2f7c
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1369,28 +1375,6 @@
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
 
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
-
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
     if "decision_cutoff_ts" in enriched.columns:
@@ -2331,28 +2315,37 @@
              
     return adj
 
-def _predict_for_problem(features: pd.DataFrame, problem_name: str, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+def _predict_for_problem(features: pd.DataFrame, problem_config: dict, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+    """Load the trained model and return probability or point forecasts based on task metadata."""
+    problem_name = problem_config.get("name", "<unknown>")
+    task_type = str(
+        problem_config.get("task_type")
+        or artifacts.get("task_type")
+        or ""
+    ).lower()
+    output_mode = artifacts.get("output_mode") or problem_config.get("output_mode")
+
     X, _ = _prepare_feature_matrix(features, artifacts)
-    
     model = joblib.load(_latest_model_path(problem_name))
-    
-    # Assuming XGBoost or similar with predict_proba for classification and predict for regression
-    # But for simplicity and compatibility with regression, check model type or problem definition?
-    # Actually, regression models in sklearn/xgb return values directly on predict().
-    # Classification models return class labels on predict(), and probas on predict_proba().
-    
-    try:
-        # Heuristic: Try predict_proba first if it looks like a classifier (anytime_td)
-        # But we need to know task type.
-        if "anytime_td" in problem_name:
-             proba = model.predict_proba(X)[:, 1]
+
+    is_classification = task_type in {"classification", "binary", "multiclass"}
+    if is_classification:
+        if hasattr(model, "predict_proba"):
+            preds = model.predict_proba(X)
+            if preds.ndim > 1 and preds.shape[1] > 1:
+                preds = preds[:, 1]
         else:
-             proba = model.predict(X)
-    except AttributeError:
-        proba = model.predict(X)
-        
-    return proba
+            preds = model.predict(X)
+        preds = np.asarray(preds, dtype=float)
+        preds = np.clip(preds, 0.0, 1.0)
+    else:
+        preds = np.asarray(model.predict(X), dtype=float)
 
+    if output_mode and output_mode == "logit":
+        preds = 1.0 / (1.0 + np.exp(-preds))
+
+    return preds
+
 def main() -> None:
     _ensure_imports_ready()
     args = _parse_args()
@@ -2401,7 +2394,7 @@
                 logger.warning("Skipping %s (artifacts not found).", p_name)
                 continue
 
-            preds = _predict_for_problem(features, p_name, artifacts)
+            preds = _predict_for_problem(features, problem, artifacts)
             
             # Apply guards for availability components immediately
             if p_name == "availability_active":
diff --git a/pipeline/train.py b/pipeline/train.py
index 2e2508f5ee50bf4b1877b56465304ecac80dc0bb..30c70ab8292088cc8aad350882ef2c5e8cc7efa6
--- a/pipeline/train.py
+++ b/pipeline/train.py
@@ -2073,7 +2073,7 @@
 
         # --- Save inference artifacts AFTER all models for the problem are trained ---
         # This ensures the state (imputation, categories) is from the pre-tuning/pre-holdout phase.
-        save_inference_artifacts(self, problem_name)
+        save_inference_artifacts(self, problem_name, problem_copy)
 
     def _unwrap_base_model(self, model):
         """Return the true fitted estimator, no matter how it's wrapped."""
@@ -2334,7 +2334,7 @@
                     logger.warning("Failed to initialise team total scaling for %s: %s", problem_name, exc)
             if not use_cached_for_problem:
                 self._fit_feature_artifacts(df_train, problem_copy)
-                save_inference_artifacts(self, problem_name)
+                save_inference_artifacts(self, problem_name, problem_copy)
 
             # Log final feature list used
             logger.info(f"--- Using {len(self.feature_columns)} features for {problem_name} ---")
@@ -2697,4 +2697,4 @@
             train(config_path=args.config, ordinal_only=args.ordinal_only, ordinal_ev=ordinal_ev_flag, **overrides)
     except Exception as e:
         logger.critical(f"The pipeline has failed with a critical error: {e}", exc_info=True)
-        sys.exit(1)
\ No newline at end of file
+        sys.exit(1)
diff --git a/tests/test_predict_probabilities.py b/tests/test_predict_probabilities.py
new file mode 100644
index 0000000000000000000000000000000000000000..bd68c2fa4ae83bf2ab6533daea100378f36d07f3
--- /dev/null
+++ b/tests/test_predict_probabilities.py
@@ -0,0 +1,32 @@
+from pathlib import Path
+
+import numpy as np
+import pandas as pd
+
+import pipeline.predict as predict
+
+
+def test_predict_for_problem_uses_predict_proba(monkeypatch):
+    calls = {"proba": 0, "predict": 0}
+
+    class DummyModel:
+        def predict_proba(self, X):
+            calls["proba"] += 1
+            return np.column_stack([np.zeros(len(X)), np.full(len(X), 0.7)])
+
+        def predict(self, X):
+            calls["predict"] += 1
+            return np.full(len(X), 0.2)
+
+    monkeypatch.setattr(predict.joblib, "load", lambda path: DummyModel())
+    monkeypatch.setattr(predict, "_latest_model_path", lambda name: Path("dummy"))
+
+    artifacts = {"feature_columns": ["a"], "task_type": "classification"}
+    df = pd.DataFrame({"a": [0, 1]})
+
+    preds = predict._predict_for_problem(df, {"name": "any", "task_type": "classification"}, artifacts)
+
+    assert calls["proba"] == 1
+    assert calls["predict"] == 0
+    assert np.allclose(preds, 0.7)
+    assert preds.dtype.kind == "f"
diff --git a/tests/test_training_config_features.py b/tests/test_training_config_features.py
index c8dc5f3391185bd24a48956183ded4d5174f984d..dd8c776865d65c634372027b6214bcb5226dc70a
--- a/tests/test_training_config_features.py
+++ b/tests/test_training_config_features.py
@@ -14,6 +14,19 @@
         return yaml.safe_load(fh)
 
 
+def test_problem_names_unique():
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    names = [p.get("name") for p in problems]
+    seen = {}
+    duplicates = set()
+    for name in names:
+        if name in seen:
+            duplicates.add(name)
+        seen[name] = True
+    assert not duplicates, f"Duplicate problem names in config: {sorted(duplicates)}"
+
+
 def test_training_config_feature_guards():
     """Ensure columns_to_discard and other_features_to_include don't overlap."""
     training_cfg = _load_training_config()
@@ -150,4 +163,3 @@
         "As-of snapshot coverage dropped below expected thresholds: "
         f"{coverage_failures}"
     )
-
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..eb5471f38ae1512ba5cabf81e6baf81aab0e986b
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -44,18 +44,31 @@
             formatted[k] = v
     return formatted
 
-def save_inference_artifacts(trainer, problem_name: str) -> None:
+def save_inference_artifacts(trainer, problem_name: str, problem_config: dict | None = None) -> None:
     # Versioned artifact copy
     v_dir = _vdir(trainer, problem_name, None, "artifacts") / "inference"
     v_dir.mkdir(parents=True, exist_ok=True)
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync


thinking
**Reviewing feature and metadata updates**

thinking
**Enhancing feature prefix tests**
file update
M /Users/jameswest/Desktop/nfl_predict/tests/test_training_config_features.py
@@ -128,2 +128,16 @@
 
+def test_ps_prefixes_use_hist_namespace():
+    """Prevent accidental inclusion of same-game ps_* columns as features."""
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    offenders = {}
+    for problem in problems:
+        name = problem.get("name", "<unknown>")
+        prefixes = problem.get("feature_prefixes_to_include") or []
+        bad = [p for p in prefixes if p.startswith("ps_") and not p.startswith("ps_hist_")]
+        if bad:
+            offenders[name] = bad
+    assert not offenders, f"Same-game pre-snap prefixes should be removed; found {offenders}"
+
+
 def test_asof_snapshots_not_after_cutoff():
apply_patch(auto_approved=true) exited 0 in 151ms:
Success. Updated the following files:
M tests/test_training_config_features.py
file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..dc5fa3ecfb113878ba721fd47fdf8337d4c2abd2
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -398,27 +454,6 @@
       - 'travel_rest_days'
       - 'travel_rest_days_l3'
       - 'rest_days_since_last_game'
-      - 'team_red_zone_'
-      - 'team_goal_to_go_'
-      - 'player_red_zone_'
-      - 'player_goal_to_go_'
-      - 'weather_bad_passing_flag'
-    columns_to_discard: *columns_to_discard
-    feature_prefixes_to_include:
-      - 'pred_'
-      - 'expected_'
-      - 'opp_def_'
-      - 'red_zone_'
-      - 'goal_to_go_'
-      - 'off_ctx_'
-      - 'qb_profile_'
-      - 'weather_'
-    other_features_to_include:
-      - 'week'
-      - 'season'
-      - 'position'
-      - 'total_line'
-      - 'team_implied_total'
       - 'team_red_zone_'
       - 'team_goal_to_go_'
       - 'player_red_zone_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..208733668f46e0f2359cf19bbfb0e59d9c7f2f7c
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1369,28 +1375,6 @@
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
 
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
-
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
     if "decision_cutoff_ts" in enriched.columns:
@@ -2331,28 +2315,37 @@
              
     return adj
 
-def _predict_for_problem(features: pd.DataFrame, problem_name: str, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+def _predict_for_problem(features: pd.DataFrame, problem_config: dict, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+    """Load the trained model and return probability or point forecasts based on task metadata."""
+    problem_name = problem_config.get("name", "<unknown>")
+    task_type = str(
+        problem_config.get("task_type")
+        or artifacts.get("task_type")
+        or ""
+    ).lower()
+    output_mode = artifacts.get("output_mode") or problem_config.get("output_mode")
+
     X, _ = _prepare_feature_matrix(features, artifacts)
-    
     model = joblib.load(_latest_model_path(problem_name))
-    
-    # Assuming XGBoost or similar with predict_proba for classification and predict for regression
-    # But for simplicity and compatibility with regression, check model type or problem definition?
-    # Actually, regression models in sklearn/xgb return values directly on predict().
-    # Classification models return class labels on predict(), and probas on predict_proba().
-    
-    try:
-        # Heuristic: Try predict_proba first if it looks like a classifier (anytime_td)
-        # But we need to know task type.
-        if "anytime_td" in problem_name:
-             proba = model.predict_proba(X)[:, 1]
+
+    is_classification = task_type in {"classification", "binary", "multiclass"}
+    if is_classification:
+        if hasattr(model, "predict_proba"):
+            preds = model.predict_proba(X)
+            if preds.ndim > 1 and preds.shape[1] > 1:
+                preds = preds[:, 1]
         else:
-             proba = model.predict(X)
-    except AttributeError:
-        proba = model.predict(X)
-        
-    return proba
+            preds = model.predict(X)
+        preds = np.asarray(preds, dtype=float)
+        preds = np.clip(preds, 0.0, 1.0)
+    else:
+        preds = np.asarray(model.predict(X), dtype=float)
 
+    if output_mode and output_mode == "logit":
+        preds = 1.0 / (1.0 + np.exp(-preds))
+
+    return preds
+
 def main() -> None:
     _ensure_imports_ready()
     args = _parse_args()
@@ -2401,7 +2394,7 @@
                 logger.warning("Skipping %s (artifacts not found).", p_name)
                 continue
 
-            preds = _predict_for_problem(features, p_name, artifacts)
+            preds = _predict_for_problem(features, problem, artifacts)
             
             # Apply guards for availability components immediately
             if p_name == "availability_active":
diff --git a/pipeline/train.py b/pipeline/train.py
index 2e2508f5ee50bf4b1877b56465304ecac80dc0bb..30c70ab8292088cc8aad350882ef2c5e8cc7efa6
--- a/pipeline/train.py
+++ b/pipeline/train.py
@@ -2073,7 +2073,7 @@
 
         # --- Save inference artifacts AFTER all models for the problem are trained ---
         # This ensures the state (imputation, categories) is from the pre-tuning/pre-holdout phase.
-        save_inference_artifacts(self, problem_name)
+        save_inference_artifacts(self, problem_name, problem_copy)
 
     def _unwrap_base_model(self, model):
         """Return the true fitted estimator, no matter how it's wrapped."""
@@ -2334,7 +2334,7 @@
                     logger.warning("Failed to initialise team total scaling for %s: %s", problem_name, exc)
             if not use_cached_for_problem:
                 self._fit_feature_artifacts(df_train, problem_copy)
-                save_inference_artifacts(self, problem_name)
+                save_inference_artifacts(self, problem_name, problem_copy)
 
             # Log final feature list used
             logger.info(f"--- Using {len(self.feature_columns)} features for {problem_name} ---")
@@ -2697,4 +2697,4 @@
             train(config_path=args.config, ordinal_only=args.ordinal_only, ordinal_ev=ordinal_ev_flag, **overrides)
     except Exception as e:
         logger.critical(f"The pipeline has failed with a critical error: {e}", exc_info=True)
-        sys.exit(1)
\ No newline at end of file
+        sys.exit(1)
diff --git a/tests/test_predict_probabilities.py b/tests/test_predict_probabilities.py
new file mode 100644
index 0000000000000000000000000000000000000000..bd68c2fa4ae83bf2ab6533daea100378f36d07f3
--- /dev/null
+++ b/tests/test_predict_probabilities.py
@@ -0,0 +1,32 @@
+from pathlib import Path
+
+import numpy as np
+import pandas as pd
+
+import pipeline.predict as predict
+
+
+def test_predict_for_problem_uses_predict_proba(monkeypatch):
+    calls = {"proba": 0, "predict": 0}
+
+    class DummyModel:
+        def predict_proba(self, X):
+            calls["proba"] += 1
+            return np.column_stack([np.zeros(len(X)), np.full(len(X), 0.7)])
+
+        def predict(self, X):
+            calls["predict"] += 1
+            return np.full(len(X), 0.2)
+
+    monkeypatch.setattr(predict.joblib, "load", lambda path: DummyModel())
+    monkeypatch.setattr(predict, "_latest_model_path", lambda name: Path("dummy"))
+
+    artifacts = {"feature_columns": ["a"], "task_type": "classification"}
+    df = pd.DataFrame({"a": [0, 1]})
+
+    preds = predict._predict_for_problem(df, {"name": "any", "task_type": "classification"}, artifacts)
+
+    assert calls["proba"] == 1
+    assert calls["predict"] == 0
+    assert np.allclose(preds, 0.7)
+    assert preds.dtype.kind == "f"
diff --git a/tests/test_training_config_features.py b/tests/test_training_config_features.py
index c8dc5f3391185bd24a48956183ded4d5174f984d..55365dd1217c1453a4f114216d285d83ed880320
--- a/tests/test_training_config_features.py
+++ b/tests/test_training_config_features.py
@@ -14,6 +14,19 @@
         return yaml.safe_load(fh)
 
 
+def test_problem_names_unique():
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    names = [p.get("name") for p in problems]
+    seen = {}
+    duplicates = set()
+    for name in names:
+        if name in seen:
+            duplicates.add(name)
+        seen[name] = True
+    assert not duplicates, f"Duplicate problem names in config: {sorted(duplicates)}"
+
+
 def test_training_config_feature_guards():
     """Ensure columns_to_discard and other_features_to_include don't overlap."""
     training_cfg = _load_training_config()
@@ -113,6 +126,20 @@
     )
 
 
+def test_ps_prefixes_use_hist_namespace():
+    """Prevent accidental inclusion of same-game ps_* columns as features."""
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    offenders = {}
+    for problem in problems:
+        name = problem.get("name", "<unknown>")
+        prefixes = problem.get("feature_prefixes_to_include") or []
+        bad = [p for p in prefixes if p.startswith("ps_") and not p.startswith("ps_hist_")]
+        if bad:
+            offenders[name] = bad
+    assert not offenders, f"Same-game pre-snap prefixes should be removed; found {offenders}"
+
+
 def test_asof_snapshots_not_after_cutoff():
     """Validate that stored snapshot timestamps never exceed the decision cutoff."""
     asof_path = Path(__file__).resolve().parents[1] / "data" / "processed" / "asof_metadata.parquet"
@@ -150,4 +177,3 @@
         "As-of snapshot coverage dropped below expected thresholds: "
         f"{coverage_failures}"
     )
-
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..eb5471f38ae1512ba5cabf81e6baf81aab0e986b
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -44,18 +44,31 @@
             formatted[k] = v
     return formatted
 
-def save_inference_artifacts(trainer, problem_name: str) -> None:
+def save_inference_artifacts(trainer, problem_name: str, problem_config: dict | None = None) -> None:
     # Versioned artifact copy
     v_dir = _vdir(trainer, problem_name, None, "artifacts") / "inference"
     v_dir.mkdir(parents=True, exist_ok=True)
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync

file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..dc5fa3ecfb113878ba721fd47fdf8337d4c2abd2
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -398,27 +454,6 @@
       - 'travel_rest_days'
       - 'travel_rest_days_l3'
       - 'rest_days_since_last_game'
-      - 'team_red_zone_'
-      - 'team_goal_to_go_'
-      - 'player_red_zone_'
-      - 'player_goal_to_go_'
-      - 'weather_bad_passing_flag'
-    columns_to_discard: *columns_to_discard
-    feature_prefixes_to_include:
-      - 'pred_'
-      - 'expected_'
-      - 'opp_def_'
-      - 'red_zone_'
-      - 'goal_to_go_'
-      - 'off_ctx_'
-      - 'qb_profile_'
-      - 'weather_'
-    other_features_to_include:
-      - 'week'
-      - 'season'
-      - 'position'
-      - 'total_line'
-      - 'team_implied_total'
       - 'team_red_zone_'
       - 'team_goal_to_go_'
       - 'player_red_zone_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..208733668f46e0f2359cf19bbfb0e59d9c7f2f7c
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1369,28 +1375,6 @@
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
 
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
-
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
     if "decision_cutoff_ts" in enriched.columns:
@@ -2331,28 +2315,37 @@
              
     return adj
 
-def _predict_for_problem(features: pd.DataFrame, problem_name: str, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+def _predict_for_problem(features: pd.DataFrame, problem_config: dict, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+    """Load the trained model and return probability or point forecasts based on task metadata."""
+    problem_name = problem_config.get("name", "<unknown>")
+    task_type = str(
+        problem_config.get("task_type")
+        or artifacts.get("task_type")
+        or ""
+    ).lower()
+    output_mode = artifacts.get("output_mode") or problem_config.get("output_mode")
+
     X, _ = _prepare_feature_matrix(features, artifacts)
-    
     model = joblib.load(_latest_model_path(problem_name))
-    
-    # Assuming XGBoost or similar with predict_proba for classification and predict for regression
-    # But for simplicity and compatibility with regression, check model type or problem definition?
-    # Actually, regression models in sklearn/xgb return values directly on predict().
-    # Classification models return class labels on predict(), and probas on predict_proba().
-    
-    try:
-        # Heuristic: Try predict_proba first if it looks like a classifier (anytime_td)
-        # But we need to know task type.
-        if "anytime_td" in problem_name:
-             proba = model.predict_proba(X)[:, 1]
+
+    is_classification = task_type in {"classification", "binary", "multiclass"}
+    if is_classification:
+        if hasattr(model, "predict_proba"):
+            preds = model.predict_proba(X)
+            if preds.ndim > 1 and preds.shape[1] > 1:
+                preds = preds[:, 1]
         else:
-             proba = model.predict(X)
-    except AttributeError:
-        proba = model.predict(X)
-        
-    return proba
+            preds = model.predict(X)
+        preds = np.asarray(preds, dtype=float)
+        preds = np.clip(preds, 0.0, 1.0)
+    else:
+        preds = np.asarray(model.predict(X), dtype=float)
 
+    if output_mode and output_mode == "logit":
+        preds = 1.0 / (1.0 + np.exp(-preds))
+
+    return preds
+
 def main() -> None:
     _ensure_imports_ready()
     args = _parse_args()
@@ -2401,7 +2394,7 @@
                 logger.warning("Skipping %s (artifacts not found).", p_name)
                 continue
 
-            preds = _predict_for_problem(features, p_name, artifacts)
+            preds = _predict_for_problem(features, problem, artifacts)
             
             # Apply guards for availability components immediately
             if p_name == "availability_active":
diff --git a/pipeline/train.py b/pipeline/train.py
index 2e2508f5ee50bf4b1877b56465304ecac80dc0bb..30c70ab8292088cc8aad350882ef2c5e8cc7efa6
--- a/pipeline/train.py
+++ b/pipeline/train.py
@@ -2073,7 +2073,7 @@
 
         # --- Save inference artifacts AFTER all models for the problem are trained ---
         # This ensures the state (imputation, categories) is from the pre-tuning/pre-holdout phase.
-        save_inference_artifacts(self, problem_name)
+        save_inference_artifacts(self, problem_name, problem_copy)
 
     def _unwrap_base_model(self, model):
         """Return the true fitted estimator, no matter how it's wrapped."""
@@ -2334,7 +2334,7 @@
                     logger.warning("Failed to initialise team total scaling for %s: %s", problem_name, exc)
             if not use_cached_for_problem:
                 self._fit_feature_artifacts(df_train, problem_copy)
-                save_inference_artifacts(self, problem_name)
+                save_inference_artifacts(self, problem_name, problem_copy)
 
             # Log final feature list used
             logger.info(f"--- Using {len(self.feature_columns)} features for {problem_name} ---")
@@ -2697,4 +2697,4 @@
             train(config_path=args.config, ordinal_only=args.ordinal_only, ordinal_ev=ordinal_ev_flag, **overrides)
     except Exception as e:
         logger.critical(f"The pipeline has failed with a critical error: {e}", exc_info=True)
-        sys.exit(1)
\ No newline at end of file
+        sys.exit(1)
diff --git a/tests/test_predict_probabilities.py b/tests/test_predict_probabilities.py
new file mode 100644
index 0000000000000000000000000000000000000000..bd68c2fa4ae83bf2ab6533daea100378f36d07f3
--- /dev/null
+++ b/tests/test_predict_probabilities.py
@@ -0,0 +1,32 @@
+from pathlib import Path
+
+import numpy as np
+import pandas as pd
+
+import pipeline.predict as predict
+
+
+def test_predict_for_problem_uses_predict_proba(monkeypatch):
+    calls = {"proba": 0, "predict": 0}
+
+    class DummyModel:
+        def predict_proba(self, X):
+            calls["proba"] += 1
+            return np.column_stack([np.zeros(len(X)), np.full(len(X), 0.7)])
+
+        def predict(self, X):
+            calls["predict"] += 1
+            return np.full(len(X), 0.2)
+
+    monkeypatch.setattr(predict.joblib, "load", lambda path: DummyModel())
+    monkeypatch.setattr(predict, "_latest_model_path", lambda name: Path("dummy"))
+
+    artifacts = {"feature_columns": ["a"], "task_type": "classification"}
+    df = pd.DataFrame({"a": [0, 1]})
+
+    preds = predict._predict_for_problem(df, {"name": "any", "task_type": "classification"}, artifacts)
+
+    assert calls["proba"] == 1
+    assert calls["predict"] == 0
+    assert np.allclose(preds, 0.7)
+    assert preds.dtype.kind == "f"
diff --git a/tests/test_training_config_features.py b/tests/test_training_config_features.py
index c8dc5f3391185bd24a48956183ded4d5174f984d..55365dd1217c1453a4f114216d285d83ed880320
--- a/tests/test_training_config_features.py
+++ b/tests/test_training_config_features.py
@@ -14,6 +14,19 @@
         return yaml.safe_load(fh)
 
 
+def test_problem_names_unique():
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    names = [p.get("name") for p in problems]
+    seen = {}
+    duplicates = set()
+    for name in names:
+        if name in seen:
+            duplicates.add(name)
+        seen[name] = True
+    assert not duplicates, f"Duplicate problem names in config: {sorted(duplicates)}"
+
+
 def test_training_config_feature_guards():
     """Ensure columns_to_discard and other_features_to_include don't overlap."""
     training_cfg = _load_training_config()
@@ -113,6 +126,20 @@
     )
 
 
+def test_ps_prefixes_use_hist_namespace():
+    """Prevent accidental inclusion of same-game ps_* columns as features."""
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    offenders = {}
+    for problem in problems:
+        name = problem.get("name", "<unknown>")
+        prefixes = problem.get("feature_prefixes_to_include") or []
+        bad = [p for p in prefixes if p.startswith("ps_") and not p.startswith("ps_hist_")]
+        if bad:
+            offenders[name] = bad
+    assert not offenders, f"Same-game pre-snap prefixes should be removed; found {offenders}"
+
+
 def test_asof_snapshots_not_after_cutoff():
     """Validate that stored snapshot timestamps never exceed the decision cutoff."""
     asof_path = Path(__file__).resolve().parents[1] / "data" / "processed" / "asof_metadata.parquet"
@@ -150,4 +177,3 @@
         "As-of snapshot coverage dropped below expected thresholds: "
         f"{coverage_failures}"
     )
-
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..eb5471f38ae1512ba5cabf81e6baf81aab0e986b
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -44,18 +44,31 @@
             formatted[k] = v
     return formatted
 
-def save_inference_artifacts(trainer, problem_name: str) -> None:
+def save_inference_artifacts(trainer, problem_name: str, problem_config: dict | None = None) -> None:
     # Versioned artifact copy
     v_dir = _vdir(trainer, problem_name, None, "artifacts") / "inference"
     v_dir.mkdir(parents=True, exist_ok=True)
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync


thinking
**Reviewing test coverage and config updates**

thinking
**Preparing to run targeted tests**
exec
/bin/zsh -lc 'cd /Users/jameswest/Desktop/nfl_predict && pytest tests/test_training_config_features.py tests/test_predict_probabilities.py' in /Users/jameswest/Desktop/nfl_predict exited 127 in 727ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
zsh:1: command not found: pytest
file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..dc5fa3ecfb113878ba721fd47fdf8337d4c2abd2
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -398,27 +454,6 @@
       - 'travel_rest_days'
       - 'travel_rest_days_l3'
       - 'rest_days_since_last_game'
-      - 'team_red_zone_'
-      - 'team_goal_to_go_'
-      - 'player_red_zone_'
-      - 'player_goal_to_go_'
-      - 'weather_bad_passing_flag'
-    columns_to_discard: *columns_to_discard
-    feature_prefixes_to_include:
-      - 'pred_'
-      - 'expected_'
-      - 'opp_def_'
-      - 'red_zone_'
-      - 'goal_to_go_'
-      - 'off_ctx_'
-      - 'qb_profile_'
-      - 'weather_'
-    other_features_to_include:
-      - 'week'
-      - 'season'
-      - 'position'
-      - 'total_line'
-      - 'team_implied_total'
       - 'team_red_zone_'
       - 'team_goal_to_go_'
       - 'player_red_zone_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..208733668f46e0f2359cf19bbfb0e59d9c7f2f7c
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1369,28 +1375,6 @@
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
 
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
-
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
     if "decision_cutoff_ts" in enriched.columns:
@@ -2331,28 +2315,37 @@
              
     return adj
 
-def _predict_for_problem(features: pd.DataFrame, problem_name: str, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+def _predict_for_problem(features: pd.DataFrame, problem_config: dict, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+    """Load the trained model and return probability or point forecasts based on task metadata."""
+    problem_name = problem_config.get("name", "<unknown>")
+    task_type = str(
+        problem_config.get("task_type")
+        or artifacts.get("task_type")
+        or ""
+    ).lower()
+    output_mode = artifacts.get("output_mode") or problem_config.get("output_mode")
+
     X, _ = _prepare_feature_matrix(features, artifacts)
-    
     model = joblib.load(_latest_model_path(problem_name))
-    
-    # Assuming XGBoost or similar with predict_proba for classification and predict for regression
-    # But for simplicity and compatibility with regression, check model type or problem definition?
-    # Actually, regression models in sklearn/xgb return values directly on predict().
-    # Classification models return class labels on predict(), and probas on predict_proba().
-    
-    try:
-        # Heuristic: Try predict_proba first if it looks like a classifier (anytime_td)
-        # But we need to know task type.
-        if "anytime_td" in problem_name:
-             proba = model.predict_proba(X)[:, 1]
+
+    is_classification = task_type in {"classification", "binary", "multiclass"}
+    if is_classification:
+        if hasattr(model, "predict_proba"):
+            preds = model.predict_proba(X)
+            if preds.ndim > 1 and preds.shape[1] > 1:
+                preds = preds[:, 1]
         else:
-             proba = model.predict(X)
-    except AttributeError:
-        proba = model.predict(X)
-        
-    return proba
+            preds = model.predict(X)
+        preds = np.asarray(preds, dtype=float)
+        preds = np.clip(preds, 0.0, 1.0)
+    else:
+        preds = np.asarray(model.predict(X), dtype=float)
 
+    if output_mode and output_mode == "logit":
+        preds = 1.0 / (1.0 + np.exp(-preds))
+
+    return preds
+
 def main() -> None:
     _ensure_imports_ready()
     args = _parse_args()
@@ -2401,7 +2394,7 @@
                 logger.warning("Skipping %s (artifacts not found).", p_name)
                 continue
 
-            preds = _predict_for_problem(features, p_name, artifacts)
+            preds = _predict_for_problem(features, problem, artifacts)
             
             # Apply guards for availability components immediately
             if p_name == "availability_active":
diff --git a/pipeline/train.py b/pipeline/train.py
index 2e2508f5ee50bf4b1877b56465304ecac80dc0bb..30c70ab8292088cc8aad350882ef2c5e8cc7efa6
--- a/pipeline/train.py
+++ b/pipeline/train.py
@@ -2073,7 +2073,7 @@
 
         # --- Save inference artifacts AFTER all models for the problem are trained ---
         # This ensures the state (imputation, categories) is from the pre-tuning/pre-holdout phase.
-        save_inference_artifacts(self, problem_name)
+        save_inference_artifacts(self, problem_name, problem_copy)
 
     def _unwrap_base_model(self, model):
         """Return the true fitted estimator, no matter how it's wrapped."""
@@ -2334,7 +2334,7 @@
                     logger.warning("Failed to initialise team total scaling for %s: %s", problem_name, exc)
             if not use_cached_for_problem:
                 self._fit_feature_artifacts(df_train, problem_copy)
-                save_inference_artifacts(self, problem_name)
+                save_inference_artifacts(self, problem_name, problem_copy)
 
             # Log final feature list used
             logger.info(f"--- Using {len(self.feature_columns)} features for {problem_name} ---")
@@ -2697,4 +2697,4 @@
             train(config_path=args.config, ordinal_only=args.ordinal_only, ordinal_ev=ordinal_ev_flag, **overrides)
     except Exception as e:
         logger.critical(f"The pipeline has failed with a critical error: {e}", exc_info=True)
-        sys.exit(1)
\ No newline at end of file
+        sys.exit(1)
diff --git a/tests/test_predict_probabilities.py b/tests/test_predict_probabilities.py
new file mode 100644
index 0000000000000000000000000000000000000000..bd68c2fa4ae83bf2ab6533daea100378f36d07f3
--- /dev/null
+++ b/tests/test_predict_probabilities.py
@@ -0,0 +1,32 @@
+from pathlib import Path
+
+import numpy as np
+import pandas as pd
+
+import pipeline.predict as predict
+
+
+def test_predict_for_problem_uses_predict_proba(monkeypatch):
+    calls = {"proba": 0, "predict": 0}
+
+    class DummyModel:
+        def predict_proba(self, X):
+            calls["proba"] += 1
+            return np.column_stack([np.zeros(len(X)), np.full(len(X), 0.7)])
+
+        def predict(self, X):
+            calls["predict"] += 1
+            return np.full(len(X), 0.2)
+
+    monkeypatch.setattr(predict.joblib, "load", lambda path: DummyModel())
+    monkeypatch.setattr(predict, "_latest_model_path", lambda name: Path("dummy"))
+
+    artifacts = {"feature_columns": ["a"], "task_type": "classification"}
+    df = pd.DataFrame({"a": [0, 1]})
+
+    preds = predict._predict_for_problem(df, {"name": "any", "task_type": "classification"}, artifacts)
+
+    assert calls["proba"] == 1
+    assert calls["predict"] == 0
+    assert np.allclose(preds, 0.7)
+    assert preds.dtype.kind == "f"
diff --git a/tests/test_training_config_features.py b/tests/test_training_config_features.py
index c8dc5f3391185bd24a48956183ded4d5174f984d..55365dd1217c1453a4f114216d285d83ed880320
--- a/tests/test_training_config_features.py
+++ b/tests/test_training_config_features.py
@@ -14,6 +14,19 @@
         return yaml.safe_load(fh)
 
 
+def test_problem_names_unique():
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    names = [p.get("name") for p in problems]
+    seen = {}
+    duplicates = set()
+    for name in names:
+        if name in seen:
+            duplicates.add(name)
+        seen[name] = True
+    assert not duplicates, f"Duplicate problem names in config: {sorted(duplicates)}"
+
+
 def test_training_config_feature_guards():
     """Ensure columns_to_discard and other_features_to_include don't overlap."""
     training_cfg = _load_training_config()
@@ -113,6 +126,20 @@
     )
 
 
+def test_ps_prefixes_use_hist_namespace():
+    """Prevent accidental inclusion of same-game ps_* columns as features."""
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    offenders = {}
+    for problem in problems:
+        name = problem.get("name", "<unknown>")
+        prefixes = problem.get("feature_prefixes_to_include") or []
+        bad = [p for p in prefixes if p.startswith("ps_") and not p.startswith("ps_hist_")]
+        if bad:
+            offenders[name] = bad
+    assert not offenders, f"Same-game pre-snap prefixes should be removed; found {offenders}"
+
+
 def test_asof_snapshots_not_after_cutoff():
     """Validate that stored snapshot timestamps never exceed the decision cutoff."""
     asof_path = Path(__file__).resolve().parents[1] / "data" / "processed" / "asof_metadata.parquet"
@@ -150,4 +177,3 @@
         "As-of snapshot coverage dropped below expected thresholds: "
         f"{coverage_failures}"
     )
-
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..eb5471f38ae1512ba5cabf81e6baf81aab0e986b
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -44,18 +44,31 @@
             formatted[k] = v
     return formatted
 
-def save_inference_artifacts(trainer, problem_name: str) -> None:
+def save_inference_artifacts(trainer, problem_name: str, problem_config: dict | None = None) -> None:
     # Versioned artifact copy
     v_dir = _vdir(trainer, problem_name, None, "artifacts") / "inference"
     v_dir.mkdir(parents=True, exist_ok=True)
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync


thinking
**Attempting to run tests with python module**
exec
/bin/zsh -lc 'cd /Users/jameswest/Desktop/nfl_predict && python -m pytest tests/test_training_config_features.py tests/test_predict_probabilities.py' in /Users/jameswest/Desktop/nfl_predict exited 127 in 666ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
zsh:1: command not found: python
file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..dc5fa3ecfb113878ba721fd47fdf8337d4c2abd2
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -398,27 +454,6 @@
       - 'travel_rest_days'
       - 'travel_rest_days_l3'
       - 'rest_days_since_last_game'
-      - 'team_red_zone_'
-      - 'team_goal_to_go_'
-      - 'player_red_zone_'
-      - 'player_goal_to_go_'
-      - 'weather_bad_passing_flag'
-    columns_to_discard: *columns_to_discard
-    feature_prefixes_to_include:
-      - 'pred_'
-      - 'expected_'
-      - 'opp_def_'
-      - 'red_zone_'
-      - 'goal_to_go_'
-      - 'off_ctx_'
-      - 'qb_profile_'
-      - 'weather_'
-    other_features_to_include:
-      - 'week'
-      - 'season'
-      - 'position'
-      - 'total_line'
-      - 'team_implied_total'
       - 'team_red_zone_'
       - 'team_goal_to_go_'
       - 'player_red_zone_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..208733668f46e0f2359cf19bbfb0e59d9c7f2f7c
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1369,28 +1375,6 @@
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
 
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
-
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
     if "decision_cutoff_ts" in enriched.columns:
@@ -2331,28 +2315,37 @@
              
     return adj
 
-def _predict_for_problem(features: pd.DataFrame, problem_name: str, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+def _predict_for_problem(features: pd.DataFrame, problem_config: dict, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+    """Load the trained model and return probability or point forecasts based on task metadata."""
+    problem_name = problem_config.get("name", "<unknown>")
+    task_type = str(
+        problem_config.get("task_type")
+        or artifacts.get("task_type")
+        or ""
+    ).lower()
+    output_mode = artifacts.get("output_mode") or problem_config.get("output_mode")
+
     X, _ = _prepare_feature_matrix(features, artifacts)
-    
     model = joblib.load(_latest_model_path(problem_name))
-    
-    # Assuming XGBoost or similar with predict_proba for classification and predict for regression
-    # But for simplicity and compatibility with regression, check model type or problem definition?
-    # Actually, regression models in sklearn/xgb return values directly on predict().
-    # Classification models return class labels on predict(), and probas on predict_proba().
-    
-    try:
-        # Heuristic: Try predict_proba first if it looks like a classifier (anytime_td)
-        # But we need to know task type.
-        if "anytime_td" in problem_name:
-             proba = model.predict_proba(X)[:, 1]
+
+    is_classification = task_type in {"classification", "binary", "multiclass"}
+    if is_classification:
+        if hasattr(model, "predict_proba"):
+            preds = model.predict_proba(X)
+            if preds.ndim > 1 and preds.shape[1] > 1:
+                preds = preds[:, 1]
         else:
-             proba = model.predict(X)
-    except AttributeError:
-        proba = model.predict(X)
-        
-    return proba
+            preds = model.predict(X)
+        preds = np.asarray(preds, dtype=float)
+        preds = np.clip(preds, 0.0, 1.0)
+    else:
+        preds = np.asarray(model.predict(X), dtype=float)
 
+    if output_mode and output_mode == "logit":
+        preds = 1.0 / (1.0 + np.exp(-preds))
+
+    return preds
+
 def main() -> None:
     _ensure_imports_ready()
     args = _parse_args()
@@ -2401,7 +2394,7 @@
                 logger.warning("Skipping %s (artifacts not found).", p_name)
                 continue
 
-            preds = _predict_for_problem(features, p_name, artifacts)
+            preds = _predict_for_problem(features, problem, artifacts)
             
             # Apply guards for availability components immediately
             if p_name == "availability_active":
diff --git a/pipeline/train.py b/pipeline/train.py
index 2e2508f5ee50bf4b1877b56465304ecac80dc0bb..30c70ab8292088cc8aad350882ef2c5e8cc7efa6
--- a/pipeline/train.py
+++ b/pipeline/train.py
@@ -2073,7 +2073,7 @@
 
         # --- Save inference artifacts AFTER all models for the problem are trained ---
         # This ensures the state (imputation, categories) is from the pre-tuning/pre-holdout phase.
-        save_inference_artifacts(self, problem_name)
+        save_inference_artifacts(self, problem_name, problem_copy)
 
     def _unwrap_base_model(self, model):
         """Return the true fitted estimator, no matter how it's wrapped."""
@@ -2334,7 +2334,7 @@
                     logger.warning("Failed to initialise team total scaling for %s: %s", problem_name, exc)
             if not use_cached_for_problem:
                 self._fit_feature_artifacts(df_train, problem_copy)
-                save_inference_artifacts(self, problem_name)
+                save_inference_artifacts(self, problem_name, problem_copy)
 
             # Log final feature list used
             logger.info(f"--- Using {len(self.feature_columns)} features for {problem_name} ---")
@@ -2697,4 +2697,4 @@
             train(config_path=args.config, ordinal_only=args.ordinal_only, ordinal_ev=ordinal_ev_flag, **overrides)
     except Exception as e:
         logger.critical(f"The pipeline has failed with a critical error: {e}", exc_info=True)
-        sys.exit(1)
\ No newline at end of file
+        sys.exit(1)
diff --git a/tests/test_predict_probabilities.py b/tests/test_predict_probabilities.py
new file mode 100644
index 0000000000000000000000000000000000000000..bd68c2fa4ae83bf2ab6533daea100378f36d07f3
--- /dev/null
+++ b/tests/test_predict_probabilities.py
@@ -0,0 +1,32 @@
+from pathlib import Path
+
+import numpy as np
+import pandas as pd
+
+import pipeline.predict as predict
+
+
+def test_predict_for_problem_uses_predict_proba(monkeypatch):
+    calls = {"proba": 0, "predict": 0}
+
+    class DummyModel:
+        def predict_proba(self, X):
+            calls["proba"] += 1
+            return np.column_stack([np.zeros(len(X)), np.full(len(X), 0.7)])
+
+        def predict(self, X):
+            calls["predict"] += 1
+            return np.full(len(X), 0.2)
+
+    monkeypatch.setattr(predict.joblib, "load", lambda path: DummyModel())
+    monkeypatch.setattr(predict, "_latest_model_path", lambda name: Path("dummy"))
+
+    artifacts = {"feature_columns": ["a"], "task_type": "classification"}
+    df = pd.DataFrame({"a": [0, 1]})
+
+    preds = predict._predict_for_problem(df, {"name": "any", "task_type": "classification"}, artifacts)
+
+    assert calls["proba"] == 1
+    assert calls["predict"] == 0
+    assert np.allclose(preds, 0.7)
+    assert preds.dtype.kind == "f"
diff --git a/tests/test_training_config_features.py b/tests/test_training_config_features.py
index c8dc5f3391185bd24a48956183ded4d5174f984d..55365dd1217c1453a4f114216d285d83ed880320
--- a/tests/test_training_config_features.py
+++ b/tests/test_training_config_features.py
@@ -14,6 +14,19 @@
         return yaml.safe_load(fh)
 
 
+def test_problem_names_unique():
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    names = [p.get("name") for p in problems]
+    seen = {}
+    duplicates = set()
+    for name in names:
+        if name in seen:
+            duplicates.add(name)
+        seen[name] = True
+    assert not duplicates, f"Duplicate problem names in config: {sorted(duplicates)}"
+
+
 def test_training_config_feature_guards():
     """Ensure columns_to_discard and other_features_to_include don't overlap."""
     training_cfg = _load_training_config()
@@ -113,6 +126,20 @@
     )
 
 
+def test_ps_prefixes_use_hist_namespace():
+    """Prevent accidental inclusion of same-game ps_* columns as features."""
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    offenders = {}
+    for problem in problems:
+        name = problem.get("name", "<unknown>")
+        prefixes = problem.get("feature_prefixes_to_include") or []
+        bad = [p for p in prefixes if p.startswith("ps_") and not p.startswith("ps_hist_")]
+        if bad:
+            offenders[name] = bad
+    assert not offenders, f"Same-game pre-snap prefixes should be removed; found {offenders}"
+
+
 def test_asof_snapshots_not_after_cutoff():
     """Validate that stored snapshot timestamps never exceed the decision cutoff."""
     asof_path = Path(__file__).resolve().parents[1] / "data" / "processed" / "asof_metadata.parquet"
@@ -150,4 +177,3 @@
         "As-of snapshot coverage dropped below expected thresholds: "
         f"{coverage_failures}"
     )
-
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..eb5471f38ae1512ba5cabf81e6baf81aab0e986b
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -44,18 +44,31 @@
             formatted[k] = v
     return formatted
 
-def save_inference_artifacts(trainer, problem_name: str) -> None:
+def save_inference_artifacts(trainer, problem_name: str, problem_config: dict | None = None) -> None:
     # Versioned artifact copy
     v_dir = _vdir(trainer, problem_name, None, "artifacts") / "inference"
     v_dir.mkdir(parents=True, exist_ok=True)
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync


thinking
**Trying pytest with python3**
exec
/bin/zsh -lc 'cd /Users/jameswest/Desktop/nfl_predict && python3 -m pytest tests/test_training_config_features.py tests/test_predict_probabilities.py' in /Users/jameswest/Desktop/nfl_predict exited 1 in 770ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
/opt/homebrew/opt/python@3.13/bin/python3.13: No module named pytest
file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..dc5fa3ecfb113878ba721fd47fdf8337d4c2abd2
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -398,27 +454,6 @@
       - 'travel_rest_days'
       - 'travel_rest_days_l3'
       - 'rest_days_since_last_game'
-      - 'team_red_zone_'
-      - 'team_goal_to_go_'
-      - 'player_red_zone_'
-      - 'player_goal_to_go_'
-      - 'weather_bad_passing_flag'
-    columns_to_discard: *columns_to_discard
-    feature_prefixes_to_include:
-      - 'pred_'
-      - 'expected_'
-      - 'opp_def_'
-      - 'red_zone_'
-      - 'goal_to_go_'
-      - 'off_ctx_'
-      - 'qb_profile_'
-      - 'weather_'
-    other_features_to_include:
-      - 'week'
-      - 'season'
-      - 'position'
-      - 'total_line'
-      - 'team_implied_total'
       - 'team_red_zone_'
       - 'team_goal_to_go_'
       - 'player_red_zone_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..208733668f46e0f2359cf19bbfb0e59d9c7f2f7c
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1369,28 +1375,6 @@
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
 
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
-
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
     if "decision_cutoff_ts" in enriched.columns:
@@ -2331,28 +2315,37 @@
              
     return adj
 
-def _predict_for_problem(features: pd.DataFrame, problem_name: str, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+def _predict_for_problem(features: pd.DataFrame, problem_config: dict, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+    """Load the trained model and return probability or point forecasts based on task metadata."""
+    problem_name = problem_config.get("name", "<unknown>")
+    task_type = str(
+        problem_config.get("task_type")
+        or artifacts.get("task_type")
+        or ""
+    ).lower()
+    output_mode = artifacts.get("output_mode") or problem_config.get("output_mode")
+
     X, _ = _prepare_feature_matrix(features, artifacts)
-    
     model = joblib.load(_latest_model_path(problem_name))
-    
-    # Assuming XGBoost or similar with predict_proba for classification and predict for regression
-    # But for simplicity and compatibility with regression, check model type or problem definition?
-    # Actually, regression models in sklearn/xgb return values directly on predict().
-    # Classification models return class labels on predict(), and probas on predict_proba().
-    
-    try:
-        # Heuristic: Try predict_proba first if it looks like a classifier (anytime_td)
-        # But we need to know task type.
-        if "anytime_td" in problem_name:
-             proba = model.predict_proba(X)[:, 1]
+
+    is_classification = task_type in {"classification", "binary", "multiclass"}
+    if is_classification:
+        if hasattr(model, "predict_proba"):
+            preds = model.predict_proba(X)
+            if preds.ndim > 1 and preds.shape[1] > 1:
+                preds = preds[:, 1]
         else:
-             proba = model.predict(X)
-    except AttributeError:
-        proba = model.predict(X)
-        
-    return proba
+            preds = model.predict(X)
+        preds = np.asarray(preds, dtype=float)
+        preds = np.clip(preds, 0.0, 1.0)
+    else:
+        preds = np.asarray(model.predict(X), dtype=float)
 
+    if output_mode and output_mode == "logit":
+        preds = 1.0 / (1.0 + np.exp(-preds))
+
+    return preds
+
 def main() -> None:
     _ensure_imports_ready()
     args = _parse_args()
@@ -2401,7 +2394,7 @@
                 logger.warning("Skipping %s (artifacts not found).", p_name)
                 continue
 
-            preds = _predict_for_problem(features, p_name, artifacts)
+            preds = _predict_for_problem(features, problem, artifacts)
             
             # Apply guards for availability components immediately
             if p_name == "availability_active":
diff --git a/pipeline/train.py b/pipeline/train.py
index 2e2508f5ee50bf4b1877b56465304ecac80dc0bb..30c70ab8292088cc8aad350882ef2c5e8cc7efa6
--- a/pipeline/train.py
+++ b/pipeline/train.py
@@ -2073,7 +2073,7 @@
 
         # --- Save inference artifacts AFTER all models for the problem are trained ---
         # This ensures the state (imputation, categories) is from the pre-tuning/pre-holdout phase.
-        save_inference_artifacts(self, problem_name)
+        save_inference_artifacts(self, problem_name, problem_copy)
 
     def _unwrap_base_model(self, model):
         """Return the true fitted estimator, no matter how it's wrapped."""
@@ -2334,7 +2334,7 @@
                     logger.warning("Failed to initialise team total scaling for %s: %s", problem_name, exc)
             if not use_cached_for_problem:
                 self._fit_feature_artifacts(df_train, problem_copy)
-                save_inference_artifacts(self, problem_name)
+                save_inference_artifacts(self, problem_name, problem_copy)
 
             # Log final feature list used
             logger.info(f"--- Using {len(self.feature_columns)} features for {problem_name} ---")
@@ -2697,4 +2697,4 @@
             train(config_path=args.config, ordinal_only=args.ordinal_only, ordinal_ev=ordinal_ev_flag, **overrides)
     except Exception as e:
         logger.critical(f"The pipeline has failed with a critical error: {e}", exc_info=True)
-        sys.exit(1)
\ No newline at end of file
+        sys.exit(1)
diff --git a/tests/test_predict_probabilities.py b/tests/test_predict_probabilities.py
new file mode 100644
index 0000000000000000000000000000000000000000..bd68c2fa4ae83bf2ab6533daea100378f36d07f3
--- /dev/null
+++ b/tests/test_predict_probabilities.py
@@ -0,0 +1,32 @@
+from pathlib import Path
+
+import numpy as np
+import pandas as pd
+
+import pipeline.predict as predict
+
+
+def test_predict_for_problem_uses_predict_proba(monkeypatch):
+    calls = {"proba": 0, "predict": 0}
+
+    class DummyModel:
+        def predict_proba(self, X):
+            calls["proba"] += 1
+            return np.column_stack([np.zeros(len(X)), np.full(len(X), 0.7)])
+
+        def predict(self, X):
+            calls["predict"] += 1
+            return np.full(len(X), 0.2)
+
+    monkeypatch.setattr(predict.joblib, "load", lambda path: DummyModel())
+    monkeypatch.setattr(predict, "_latest_model_path", lambda name: Path("dummy"))
+
+    artifacts = {"feature_columns": ["a"], "task_type": "classification"}
+    df = pd.DataFrame({"a": [0, 1]})
+
+    preds = predict._predict_for_problem(df, {"name": "any", "task_type": "classification"}, artifacts)
+
+    assert calls["proba"] == 1
+    assert calls["predict"] == 0
+    assert np.allclose(preds, 0.7)
+    assert preds.dtype.kind == "f"
diff --git a/tests/test_training_config_features.py b/tests/test_training_config_features.py
index c8dc5f3391185bd24a48956183ded4d5174f984d..55365dd1217c1453a4f114216d285d83ed880320
--- a/tests/test_training_config_features.py
+++ b/tests/test_training_config_features.py
@@ -14,6 +14,19 @@
         return yaml.safe_load(fh)
 
 
+def test_problem_names_unique():
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    names = [p.get("name") for p in problems]
+    seen = {}
+    duplicates = set()
+    for name in names:
+        if name in seen:
+            duplicates.add(name)
+        seen[name] = True
+    assert not duplicates, f"Duplicate problem names in config: {sorted(duplicates)}"
+
+
 def test_training_config_feature_guards():
     """Ensure columns_to_discard and other_features_to_include don't overlap."""
     training_cfg = _load_training_config()
@@ -113,6 +126,20 @@
     )
 
 
+def test_ps_prefixes_use_hist_namespace():
+    """Prevent accidental inclusion of same-game ps_* columns as features."""
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    offenders = {}
+    for problem in problems:
+        name = problem.get("name", "<unknown>")
+        prefixes = problem.get("feature_prefixes_to_include") or []
+        bad = [p for p in prefixes if p.startswith("ps_") and not p.startswith("ps_hist_")]
+        if bad:
+            offenders[name] = bad
+    assert not offenders, f"Same-game pre-snap prefixes should be removed; found {offenders}"
+
+
 def test_asof_snapshots_not_after_cutoff():
     """Validate that stored snapshot timestamps never exceed the decision cutoff."""
     asof_path = Path(__file__).resolve().parents[1] / "data" / "processed" / "asof_metadata.parquet"
@@ -150,4 +177,3 @@
         "As-of snapshot coverage dropped below expected thresholds: "
         f"{coverage_failures}"
     )
-
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..eb5471f38ae1512ba5cabf81e6baf81aab0e986b
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -44,18 +44,31 @@
             formatted[k] = v
     return formatted
 
-def save_inference_artifacts(trainer, problem_name: str) -> None:
+def save_inference_artifacts(trainer, problem_name: str, problem_config: dict | None = None) -> None:
     # Versioned artifact copy
     v_dir = _vdir(trainer, problem_name, None, "artifacts") / "inference"
     v_dir.mkdir(parents=True, exist_ok=True)
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync


thinking
**Noting pytest absence and verifying fallback map usage**
exec
/bin/zsh -lc 'rg -n "PS_L3_FALLBACK_MAP" pipeline/predict.py' in /Users/jameswest/Desktop/nfl_predict succeeded in 744ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
220:PS_L3_FALLBACK_MAP = {
634:    for l3_col, src_col in PS_L3_FALLBACK_MAP.items():
file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..dc5fa3ecfb113878ba721fd47fdf8337d4c2abd2
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -398,27 +454,6 @@
       - 'travel_rest_days'
       - 'travel_rest_days_l3'
       - 'rest_days_since_last_game'
-      - 'team_red_zone_'
-      - 'team_goal_to_go_'
-      - 'player_red_zone_'
-      - 'player_goal_to_go_'
-      - 'weather_bad_passing_flag'
-    columns_to_discard: *columns_to_discard
-    feature_prefixes_to_include:
-      - 'pred_'
-      - 'expected_'
-      - 'opp_def_'
-      - 'red_zone_'
-      - 'goal_to_go_'
-      - 'off_ctx_'
-      - 'qb_profile_'
-      - 'weather_'
-    other_features_to_include:
-      - 'week'
-      - 'season'
-      - 'position'
-      - 'total_line'
-      - 'team_implied_total'
       - 'team_red_zone_'
       - 'team_goal_to_go_'
       - 'player_red_zone_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..208733668f46e0f2359cf19bbfb0e59d9c7f2f7c
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1369,28 +1375,6 @@
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
 
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
-
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
     if "decision_cutoff_ts" in enriched.columns:
@@ -2331,28 +2315,37 @@
              
     return adj
 
-def _predict_for_problem(features: pd.DataFrame, problem_name: str, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+def _predict_for_problem(features: pd.DataFrame, problem_config: dict, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+    """Load the trained model and return probability or point forecasts based on task metadata."""
+    problem_name = problem_config.get("name", "<unknown>")
+    task_type = str(
+        problem_config.get("task_type")
+        or artifacts.get("task_type")
+        or ""
+    ).lower()
+    output_mode = artifacts.get("output_mode") or problem_config.get("output_mode")
+
     X, _ = _prepare_feature_matrix(features, artifacts)
-    
     model = joblib.load(_latest_model_path(problem_name))
-    
-    # Assuming XGBoost or similar with predict_proba for classification and predict for regression
-    # But for simplicity and compatibility with regression, check model type or problem definition?
-    # Actually, regression models in sklearn/xgb return values directly on predict().
-    # Classification models return class labels on predict(), and probas on predict_proba().
-    
-    try:
-        # Heuristic: Try predict_proba first if it looks like a classifier (anytime_td)
-        # But we need to know task type.
-        if "anytime_td" in problem_name:
-             proba = model.predict_proba(X)[:, 1]
+
+    is_classification = task_type in {"classification", "binary", "multiclass"}
+    if is_classification:
+        if hasattr(model, "predict_proba"):
+            preds = model.predict_proba(X)
+            if preds.ndim > 1 and preds.shape[1] > 1:
+                preds = preds[:, 1]
         else:
-             proba = model.predict(X)
-    except AttributeError:
-        proba = model.predict(X)
-        
-    return proba
+            preds = model.predict(X)
+        preds = np.asarray(preds, dtype=float)
+        preds = np.clip(preds, 0.0, 1.0)
+    else:
+        preds = np.asarray(model.predict(X), dtype=float)
 
+    if output_mode and output_mode == "logit":
+        preds = 1.0 / (1.0 + np.exp(-preds))
+
+    return preds
+
 def main() -> None:
     _ensure_imports_ready()
     args = _parse_args()
@@ -2401,7 +2394,7 @@
                 logger.warning("Skipping %s (artifacts not found).", p_name)
                 continue
 
-            preds = _predict_for_problem(features, p_name, artifacts)
+            preds = _predict_for_problem(features, problem, artifacts)
             
             # Apply guards for availability components immediately
             if p_name == "availability_active":
diff --git a/pipeline/train.py b/pipeline/train.py
index 2e2508f5ee50bf4b1877b56465304ecac80dc0bb..30c70ab8292088cc8aad350882ef2c5e8cc7efa6
--- a/pipeline/train.py
+++ b/pipeline/train.py
@@ -2073,7 +2073,7 @@
 
         # --- Save inference artifacts AFTER all models for the problem are trained ---
         # This ensures the state (imputation, categories) is from the pre-tuning/pre-holdout phase.
-        save_inference_artifacts(self, problem_name)
+        save_inference_artifacts(self, problem_name, problem_copy)
 
     def _unwrap_base_model(self, model):
         """Return the true fitted estimator, no matter how it's wrapped."""
@@ -2334,7 +2334,7 @@
                     logger.warning("Failed to initialise team total scaling for %s: %s", problem_name, exc)
             if not use_cached_for_problem:
                 self._fit_feature_artifacts(df_train, problem_copy)
-                save_inference_artifacts(self, problem_name)
+                save_inference_artifacts(self, problem_name, problem_copy)
 
             # Log final feature list used
             logger.info(f"--- Using {len(self.feature_columns)} features for {problem_name} ---")
@@ -2697,4 +2697,4 @@
             train(config_path=args.config, ordinal_only=args.ordinal_only, ordinal_ev=ordinal_ev_flag, **overrides)
     except Exception as e:
         logger.critical(f"The pipeline has failed with a critical error: {e}", exc_info=True)
-        sys.exit(1)
\ No newline at end of file
+        sys.exit(1)
diff --git a/tests/test_predict_probabilities.py b/tests/test_predict_probabilities.py
new file mode 100644
index 0000000000000000000000000000000000000000..bd68c2fa4ae83bf2ab6533daea100378f36d07f3
--- /dev/null
+++ b/tests/test_predict_probabilities.py
@@ -0,0 +1,32 @@
+from pathlib import Path
+
+import numpy as np
+import pandas as pd
+
+import pipeline.predict as predict
+
+
+def test_predict_for_problem_uses_predict_proba(monkeypatch):
+    calls = {"proba": 0, "predict": 0}
+
+    class DummyModel:
+        def predict_proba(self, X):
+            calls["proba"] += 1
+            return np.column_stack([np.zeros(len(X)), np.full(len(X), 0.7)])
+
+        def predict(self, X):
+            calls["predict"] += 1
+            return np.full(len(X), 0.2)
+
+    monkeypatch.setattr(predict.joblib, "load", lambda path: DummyModel())
+    monkeypatch.setattr(predict, "_latest_model_path", lambda name: Path("dummy"))
+
+    artifacts = {"feature_columns": ["a"], "task_type": "classification"}
+    df = pd.DataFrame({"a": [0, 1]})
+
+    preds = predict._predict_for_problem(df, {"name": "any", "task_type": "classification"}, artifacts)
+
+    assert calls["proba"] == 1
+    assert calls["predict"] == 0
+    assert np.allclose(preds, 0.7)
+    assert preds.dtype.kind == "f"
diff --git a/tests/test_training_config_features.py b/tests/test_training_config_features.py
index c8dc5f3391185bd24a48956183ded4d5174f984d..55365dd1217c1453a4f114216d285d83ed880320
--- a/tests/test_training_config_features.py
+++ b/tests/test_training_config_features.py
@@ -14,6 +14,19 @@
         return yaml.safe_load(fh)
 
 
+def test_problem_names_unique():
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    names = [p.get("name") for p in problems]
+    seen = {}
+    duplicates = set()
+    for name in names:
+        if name in seen:
+            duplicates.add(name)
+        seen[name] = True
+    assert not duplicates, f"Duplicate problem names in config: {sorted(duplicates)}"
+
+
 def test_training_config_feature_guards():
     """Ensure columns_to_discard and other_features_to_include don't overlap."""
     training_cfg = _load_training_config()
@@ -113,6 +126,20 @@
     )
 
 
+def test_ps_prefixes_use_hist_namespace():
+    """Prevent accidental inclusion of same-game ps_* columns as features."""
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    offenders = {}
+    for problem in problems:
+        name = problem.get("name", "<unknown>")
+        prefixes = problem.get("feature_prefixes_to_include") or []
+        bad = [p for p in prefixes if p.startswith("ps_") and not p.startswith("ps_hist_")]
+        if bad:
+            offenders[name] = bad
+    assert not offenders, f"Same-game pre-snap prefixes should be removed; found {offenders}"
+
+
 def test_asof_snapshots_not_after_cutoff():
     """Validate that stored snapshot timestamps never exceed the decision cutoff."""
     asof_path = Path(__file__).resolve().parents[1] / "data" / "processed" / "asof_metadata.parquet"
@@ -150,4 +177,3 @@
         "As-of snapshot coverage dropped below expected thresholds: "
         f"{coverage_failures}"
     )
-
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..eb5471f38ae1512ba5cabf81e6baf81aab0e986b
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -44,18 +44,31 @@
             formatted[k] = v
     return formatted
 
-def save_inference_artifacts(trainer, problem_name: str) -> None:
+def save_inference_artifacts(trainer, problem_name: str, problem_config: dict | None = None) -> None:
     # Versioned artifact copy
     v_dir = _vdir(trainer, problem_name, None, "artifacts") / "inference"
     v_dir.mkdir(parents=True, exist_ok=True)
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync

exec
/bin/zsh -lc "sed -n '200,230p' pipeline/predict.py" in /Users/jameswest/Desktop/nfl_predict succeeded in 750ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
    "ps_route_participation_pct_prev",
    "ps_route_participation_pct_l3",
    "ps_scripted_touch_share_prev",
    "ps_scripted_touch_share_l3",
    "ps_targets_slot_share_prev",
    "ps_targets_slot_share_l3",
    "ps_targets_wide_share_prev",
    "ps_targets_wide_share_l3",
    "ps_targets_inline_share_prev",
    "ps_targets_inline_share_l3",
    "ps_targets_backfield_share_prev",
    "ps_targets_backfield_share_l3",
    "ps_route_participation_plays_l3",
    "ps_targets_total_l3",
    "ps_targets_slot_count_l3",
    "ps_targets_wide_count_l3",
    "ps_targets_inline_count_l3",
    "ps_targets_backfield_count_l3",
]
file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..dc5fa3ecfb113878ba721fd47fdf8337d4c2abd2
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -398,27 +454,6 @@
       - 'travel_rest_days'
       - 'travel_rest_days_l3'
       - 'rest_days_since_last_game'
-      - 'team_red_zone_'
-      - 'team_goal_to_go_'
-      - 'player_red_zone_'
-      - 'player_goal_to_go_'
-      - 'weather_bad_passing_flag'
-    columns_to_discard: *columns_to_discard
-    feature_prefixes_to_include:
-      - 'pred_'
-      - 'expected_'
-      - 'opp_def_'
-      - 'red_zone_'
-      - 'goal_to_go_'
-      - 'off_ctx_'
-      - 'qb_profile_'
-      - 'weather_'
-    other_features_to_include:
-      - 'week'
-      - 'season'
-      - 'position'
-      - 'total_line'
-      - 'team_implied_total'
       - 'team_red_zone_'
       - 'team_goal_to_go_'
       - 'player_red_zone_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..208733668f46e0f2359cf19bbfb0e59d9c7f2f7c
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1369,28 +1375,6 @@
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
 
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
-
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
     if "decision_cutoff_ts" in enriched.columns:
@@ -2331,28 +2315,37 @@
              
     return adj
 
-def _predict_for_problem(features: pd.DataFrame, problem_name: str, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+def _predict_for_problem(features: pd.DataFrame, problem_config: dict, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+    """Load the trained model and return probability or point forecasts based on task metadata."""
+    problem_name = problem_config.get("name", "<unknown>")
+    task_type = str(
+        problem_config.get("task_type")
+        or artifacts.get("task_type")
+        or ""
+    ).lower()
+    output_mode = artifacts.get("output_mode") or problem_config.get("output_mode")
+
     X, _ = _prepare_feature_matrix(features, artifacts)
-    
     model = joblib.load(_latest_model_path(problem_name))
-    
-    # Assuming XGBoost or similar with predict_proba for classification and predict for regression
-    # But for simplicity and compatibility with regression, check model type or problem definition?
-    # Actually, regression models in sklearn/xgb return values directly on predict().
-    # Classification models return class labels on predict(), and probas on predict_proba().
-    
-    try:
-        # Heuristic: Try predict_proba first if it looks like a classifier (anytime_td)
-        # But we need to know task type.
-        if "anytime_td" in problem_name:
-             proba = model.predict_proba(X)[:, 1]
+
+    is_classification = task_type in {"classification", "binary", "multiclass"}
+    if is_classification:
+        if hasattr(model, "predict_proba"):
+            preds = model.predict_proba(X)
+            if preds.ndim > 1 and preds.shape[1] > 1:
+                preds = preds[:, 1]
         else:
-             proba = model.predict(X)
-    except AttributeError:
-        proba = model.predict(X)
-        
-    return proba
+            preds = model.predict(X)
+        preds = np.asarray(preds, dtype=float)
+        preds = np.clip(preds, 0.0, 1.0)
+    else:
+        preds = np.asarray(model.predict(X), dtype=float)
 
+    if output_mode and output_mode == "logit":
+        preds = 1.0 / (1.0 + np.exp(-preds))
+
+    return preds
+
 def main() -> None:
     _ensure_imports_ready()
     args = _parse_args()
@@ -2401,7 +2394,7 @@
                 logger.warning("Skipping %s (artifacts not found).", p_name)
                 continue
 
-            preds = _predict_for_problem(features, p_name, artifacts)
+            preds = _predict_for_problem(features, problem, artifacts)
             
             # Apply guards for availability components immediately
             if p_name == "availability_active":
diff --git a/pipeline/train.py b/pipeline/train.py
index 2e2508f5ee50bf4b1877b56465304ecac80dc0bb..30c70ab8292088cc8aad350882ef2c5e8cc7efa6
--- a/pipeline/train.py
+++ b/pipeline/train.py
@@ -2073,7 +2073,7 @@
 
         # --- Save inference artifacts AFTER all models for the problem are trained ---
         # This ensures the state (imputation, categories) is from the pre-tuning/pre-holdout phase.
-        save_inference_artifacts(self, problem_name)
+        save_inference_artifacts(self, problem_name, problem_copy)
 
     def _unwrap_base_model(self, model):
         """Return the true fitted estimator, no matter how it's wrapped."""
@@ -2334,7 +2334,7 @@
                     logger.warning("Failed to initialise team total scaling for %s: %s", problem_name, exc)
             if not use_cached_for_problem:
                 self._fit_feature_artifacts(df_train, problem_copy)
-                save_inference_artifacts(self, problem_name)
+                save_inference_artifacts(self, problem_name, problem_copy)
 
             # Log final feature list used
             logger.info(f"--- Using {len(self.feature_columns)} features for {problem_name} ---")
@@ -2697,4 +2697,4 @@
             train(config_path=args.config, ordinal_only=args.ordinal_only, ordinal_ev=ordinal_ev_flag, **overrides)
     except Exception as e:
         logger.critical(f"The pipeline has failed with a critical error: {e}", exc_info=True)
-        sys.exit(1)
\ No newline at end of file
+        sys.exit(1)
diff --git a/tests/test_predict_probabilities.py b/tests/test_predict_probabilities.py
new file mode 100644
index 0000000000000000000000000000000000000000..bd68c2fa4ae83bf2ab6533daea100378f36d07f3
--- /dev/null
+++ b/tests/test_predict_probabilities.py
@@ -0,0 +1,32 @@
+from pathlib import Path
+
+import numpy as np
+import pandas as pd
+
+import pipeline.predict as predict
+
+
+def test_predict_for_problem_uses_predict_proba(monkeypatch):
+    calls = {"proba": 0, "predict": 0}
+
+    class DummyModel:
+        def predict_proba(self, X):
+            calls["proba"] += 1
+            return np.column_stack([np.zeros(len(X)), np.full(len(X), 0.7)])
+
+        def predict(self, X):
+            calls["predict"] += 1
+            return np.full(len(X), 0.2)
+
+    monkeypatch.setattr(predict.joblib, "load", lambda path: DummyModel())
+    monkeypatch.setattr(predict, "_latest_model_path", lambda name: Path("dummy"))
+
+    artifacts = {"feature_columns": ["a"], "task_type": "classification"}
+    df = pd.DataFrame({"a": [0, 1]})
+
+    preds = predict._predict_for_problem(df, {"name": "any", "task_type": "classification"}, artifacts)
+
+    assert calls["proba"] == 1
+    assert calls["predict"] == 0
+    assert np.allclose(preds, 0.7)
+    assert preds.dtype.kind == "f"
diff --git a/tests/test_training_config_features.py b/tests/test_training_config_features.py
index c8dc5f3391185bd24a48956183ded4d5174f984d..55365dd1217c1453a4f114216d285d83ed880320
--- a/tests/test_training_config_features.py
+++ b/tests/test_training_config_features.py
@@ -14,6 +14,19 @@
         return yaml.safe_load(fh)
 
 
+def test_problem_names_unique():
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    names = [p.get("name") for p in problems]
+    seen = {}
+    duplicates = set()
+    for name in names:
+        if name in seen:
+            duplicates.add(name)
+        seen[name] = True
+    assert not duplicates, f"Duplicate problem names in config: {sorted(duplicates)}"
+
+
 def test_training_config_feature_guards():
     """Ensure columns_to_discard and other_features_to_include don't overlap."""
     training_cfg = _load_training_config()
@@ -113,6 +126,20 @@
     )
 
 
+def test_ps_prefixes_use_hist_namespace():
+    """Prevent accidental inclusion of same-game ps_* columns as features."""
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    offenders = {}
+    for problem in problems:
+        name = problem.get("name", "<unknown>")
+        prefixes = problem.get("feature_prefixes_to_include") or []
+        bad = [p for p in prefixes if p.startswith("ps_") and not p.startswith("ps_hist_")]
+        if bad:
+            offenders[name] = bad
+    assert not offenders, f"Same-game pre-snap prefixes should be removed; found {offenders}"
+
+
 def test_asof_snapshots_not_after_cutoff():
     """Validate that stored snapshot timestamps never exceed the decision cutoff."""
     asof_path = Path(__file__).resolve().parents[1] / "data" / "processed" / "asof_metadata.parquet"
@@ -150,4 +177,3 @@
         "As-of snapshot coverage dropped below expected thresholds: "
         f"{coverage_failures}"
     )
-
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..eb5471f38ae1512ba5cabf81e6baf81aab0e986b
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -44,18 +44,31 @@
             formatted[k] = v
     return formatted
 
-def save_inference_artifacts(trainer, problem_name: str) -> None:
+def save_inference_artifacts(trainer, problem_name: str, problem_config: dict | None = None) -> None:
     # Versioned artifact copy
     v_dir = _vdir(trainer, problem_name, None, "artifacts") / "inference"
     v_dir.mkdir(parents=True, exist_ok=True)
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync


thinking
**Reviewing fallback map naming consistency**
exec
/bin/zsh -lc 'rg -n "_load_ps_baselines" pipeline/predict.py' in /Users/jameswest/Desktop/nfl_predict succeeded in 740ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
534:def _load_ps_baselines(season: int) -> pl.DataFrame:
599:    baseline = _load_ps_baselines(season_hint)
file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..dc5fa3ecfb113878ba721fd47fdf8337d4c2abd2
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -398,27 +454,6 @@
       - 'travel_rest_days'
       - 'travel_rest_days_l3'
       - 'rest_days_since_last_game'
-      - 'team_red_zone_'
-      - 'team_goal_to_go_'
-      - 'player_red_zone_'
-      - 'player_goal_to_go_'
-      - 'weather_bad_passing_flag'
-    columns_to_discard: *columns_to_discard
-    feature_prefixes_to_include:
-      - 'pred_'
-      - 'expected_'
-      - 'opp_def_'
-      - 'red_zone_'
-      - 'goal_to_go_'
-      - 'off_ctx_'
-      - 'qb_profile_'
-      - 'weather_'
-    other_features_to_include:
-      - 'week'
-      - 'season'
-      - 'position'
-      - 'total_line'
-      - 'team_implied_total'
       - 'team_red_zone_'
       - 'team_goal_to_go_'
       - 'player_red_zone_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..208733668f46e0f2359cf19bbfb0e59d9c7f2f7c
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1369,28 +1375,6 @@
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
 
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
-
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
     if "decision_cutoff_ts" in enriched.columns:
@@ -2331,28 +2315,37 @@
              
     return adj
 
-def _predict_for_problem(features: pd.DataFrame, problem_name: str, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+def _predict_for_problem(features: pd.DataFrame, problem_config: dict, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+    """Load the trained model and return probability or point forecasts based on task metadata."""
+    problem_name = problem_config.get("name", "<unknown>")
+    task_type = str(
+        problem_config.get("task_type")
+        or artifacts.get("task_type")
+        or ""
+    ).lower()
+    output_mode = artifacts.get("output_mode") or problem_config.get("output_mode")
+
     X, _ = _prepare_feature_matrix(features, artifacts)
-    
     model = joblib.load(_latest_model_path(problem_name))
-    
-    # Assuming XGBoost or similar with predict_proba for classification and predict for regression
-    # But for simplicity and compatibility with regression, check model type or problem definition?
-    # Actually, regression models in sklearn/xgb return values directly on predict().
-    # Classification models return class labels on predict(), and probas on predict_proba().
-    
-    try:
-        # Heuristic: Try predict_proba first if it looks like a classifier (anytime_td)
-        # But we need to know task type.
-        if "anytime_td" in problem_name:
-             proba = model.predict_proba(X)[:, 1]
+
+    is_classification = task_type in {"classification", "binary", "multiclass"}
+    if is_classification:
+        if hasattr(model, "predict_proba"):
+            preds = model.predict_proba(X)
+            if preds.ndim > 1 and preds.shape[1] > 1:
+                preds = preds[:, 1]
         else:
-             proba = model.predict(X)
-    except AttributeError:
-        proba = model.predict(X)
-        
-    return proba
+            preds = model.predict(X)
+        preds = np.asarray(preds, dtype=float)
+        preds = np.clip(preds, 0.0, 1.0)
+    else:
+        preds = np.asarray(model.predict(X), dtype=float)
 
+    if output_mode and output_mode == "logit":
+        preds = 1.0 / (1.0 + np.exp(-preds))
+
+    return preds
+
 def main() -> None:
     _ensure_imports_ready()
     args = _parse_args()
@@ -2401,7 +2394,7 @@
                 logger.warning("Skipping %s (artifacts not found).", p_name)
                 continue
 
-            preds = _predict_for_problem(features, p_name, artifacts)
+            preds = _predict_for_problem(features, problem, artifacts)
             
             # Apply guards for availability components immediately
             if p_name == "availability_active":
diff --git a/pipeline/train.py b/pipeline/train.py
index 2e2508f5ee50bf4b1877b56465304ecac80dc0bb..30c70ab8292088cc8aad350882ef2c5e8cc7efa6
--- a/pipeline/train.py
+++ b/pipeline/train.py
@@ -2073,7 +2073,7 @@
 
         # --- Save inference artifacts AFTER all models for the problem are trained ---
         # This ensures the state (imputation, categories) is from the pre-tuning/pre-holdout phase.
-        save_inference_artifacts(self, problem_name)
+        save_inference_artifacts(self, problem_name, problem_copy)
 
     def _unwrap_base_model(self, model):
         """Return the true fitted estimator, no matter how it's wrapped."""
@@ -2334,7 +2334,7 @@
                     logger.warning("Failed to initialise team total scaling for %s: %s", problem_name, exc)
             if not use_cached_for_problem:
                 self._fit_feature_artifacts(df_train, problem_copy)
-                save_inference_artifacts(self, problem_name)
+                save_inference_artifacts(self, problem_name, problem_copy)
 
             # Log final feature list used
             logger.info(f"--- Using {len(self.feature_columns)} features for {problem_name} ---")
@@ -2697,4 +2697,4 @@
             train(config_path=args.config, ordinal_only=args.ordinal_only, ordinal_ev=ordinal_ev_flag, **overrides)
     except Exception as e:
         logger.critical(f"The pipeline has failed with a critical error: {e}", exc_info=True)
-        sys.exit(1)
\ No newline at end of file
+        sys.exit(1)
diff --git a/tests/test_predict_probabilities.py b/tests/test_predict_probabilities.py
new file mode 100644
index 0000000000000000000000000000000000000000..bd68c2fa4ae83bf2ab6533daea100378f36d07f3
--- /dev/null
+++ b/tests/test_predict_probabilities.py
@@ -0,0 +1,32 @@
+from pathlib import Path
+
+import numpy as np
+import pandas as pd
+
+import pipeline.predict as predict
+
+
+def test_predict_for_problem_uses_predict_proba(monkeypatch):
+    calls = {"proba": 0, "predict": 0}
+
+    class DummyModel:
+        def predict_proba(self, X):
+            calls["proba"] += 1
+            return np.column_stack([np.zeros(len(X)), np.full(len(X), 0.7)])
+
+        def predict(self, X):
+            calls["predict"] += 1
+            return np.full(len(X), 0.2)
+
+    monkeypatch.setattr(predict.joblib, "load", lambda path: DummyModel())
+    monkeypatch.setattr(predict, "_latest_model_path", lambda name: Path("dummy"))
+
+    artifacts = {"feature_columns": ["a"], "task_type": "classification"}
+    df = pd.DataFrame({"a": [0, 1]})
+
+    preds = predict._predict_for_problem(df, {"name": "any", "task_type": "classification"}, artifacts)
+
+    assert calls["proba"] == 1
+    assert calls["predict"] == 0
+    assert np.allclose(preds, 0.7)
+    assert preds.dtype.kind == "f"
diff --git a/tests/test_training_config_features.py b/tests/test_training_config_features.py
index c8dc5f3391185bd24a48956183ded4d5174f984d..55365dd1217c1453a4f114216d285d83ed880320
--- a/tests/test_training_config_features.py
+++ b/tests/test_training_config_features.py
@@ -14,6 +14,19 @@
         return yaml.safe_load(fh)
 
 
+def test_problem_names_unique():
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    names = [p.get("name") for p in problems]
+    seen = {}
+    duplicates = set()
+    for name in names:
+        if name in seen:
+            duplicates.add(name)
+        seen[name] = True
+    assert not duplicates, f"Duplicate problem names in config: {sorted(duplicates)}"
+
+
 def test_training_config_feature_guards():
     """Ensure columns_to_discard and other_features_to_include don't overlap."""
     training_cfg = _load_training_config()
@@ -113,6 +126,20 @@
     )
 
 
+def test_ps_prefixes_use_hist_namespace():
+    """Prevent accidental inclusion of same-game ps_* columns as features."""
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    offenders = {}
+    for problem in problems:
+        name = problem.get("name", "<unknown>")
+        prefixes = problem.get("feature_prefixes_to_include") or []
+        bad = [p for p in prefixes if p.startswith("ps_") and not p.startswith("ps_hist_")]
+        if bad:
+            offenders[name] = bad
+    assert not offenders, f"Same-game pre-snap prefixes should be removed; found {offenders}"
+
+
 def test_asof_snapshots_not_after_cutoff():
     """Validate that stored snapshot timestamps never exceed the decision cutoff."""
     asof_path = Path(__file__).resolve().parents[1] / "data" / "processed" / "asof_metadata.parquet"
@@ -150,4 +177,3 @@
         "As-of snapshot coverage dropped below expected thresholds: "
         f"{coverage_failures}"
     )
-
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..eb5471f38ae1512ba5cabf81e6baf81aab0e986b
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -44,18 +44,31 @@
             formatted[k] = v
     return formatted
 
-def save_inference_artifacts(trainer, problem_name: str) -> None:
+def save_inference_artifacts(trainer, problem_name: str, problem_config: dict | None = None) -> None:
     # Versioned artifact copy
     v_dir = _vdir(trainer, problem_name, None, "artifacts") / "inference"
     v_dir.mkdir(parents=True, exist_ok=True)
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync

exec
/bin/zsh -lc "sed -n '520,585p' pipeline/predict.py" in /Users/jameswest/Desktop/nfl_predict succeeded in 735ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted

    return df

def _collect_partition_paths(base_dir: Path, seasons: Iterable[int]) -> list[Path]:
    paths: list[Path] = []
    for season in sorted({int(s) for s in seasons}):
        season_dir = base_dir / f"season={season}"
        if not season_dir.exists():
            continue
        paths.extend(sorted(season_dir.glob("week=*/part.parquet")))
    return paths


@lru_cache(maxsize=6)
def _load_ps_baselines(season: int) -> pl.DataFrame:
    """
    Load the latest available pre-snap participation features for seasons prior to `season`.
    These serve as carry-forward baselines when the current season has no tracking data yet.
    """
file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..dc5fa3ecfb113878ba721fd47fdf8337d4c2abd2
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -398,27 +454,6 @@
       - 'travel_rest_days'
       - 'travel_rest_days_l3'
       - 'rest_days_since_last_game'
-      - 'team_red_zone_'
-      - 'team_goal_to_go_'
-      - 'player_red_zone_'
-      - 'player_goal_to_go_'
-      - 'weather_bad_passing_flag'
-    columns_to_discard: *columns_to_discard
-    feature_prefixes_to_include:
-      - 'pred_'
-      - 'expected_'
-      - 'opp_def_'
-      - 'red_zone_'
-      - 'goal_to_go_'
-      - 'off_ctx_'
-      - 'qb_profile_'
-      - 'weather_'
-    other_features_to_include:
-      - 'week'
-      - 'season'
-      - 'position'
-      - 'total_line'
-      - 'team_implied_total'
       - 'team_red_zone_'
       - 'team_goal_to_go_'
       - 'player_red_zone_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..208733668f46e0f2359cf19bbfb0e59d9c7f2f7c
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1369,28 +1375,6 @@
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
 
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
-
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
     if "decision_cutoff_ts" in enriched.columns:
@@ -2331,28 +2315,37 @@
              
     return adj
 
-def _predict_for_problem(features: pd.DataFrame, problem_name: str, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+def _predict_for_problem(features: pd.DataFrame, problem_config: dict, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+    """Load the trained model and return probability or point forecasts based on task metadata."""
+    problem_name = problem_config.get("name", "<unknown>")
+    task_type = str(
+        problem_config.get("task_type")
+        or artifacts.get("task_type")
+        or ""
+    ).lower()
+    output_mode = artifacts.get("output_mode") or problem_config.get("output_mode")
+
     X, _ = _prepare_feature_matrix(features, artifacts)
-    
     model = joblib.load(_latest_model_path(problem_name))
-    
-    # Assuming XGBoost or similar with predict_proba for classification and predict for regression
-    # But for simplicity and compatibility with regression, check model type or problem definition?
-    # Actually, regression models in sklearn/xgb return values directly on predict().
-    # Classification models return class labels on predict(), and probas on predict_proba().
-    
-    try:
-        # Heuristic: Try predict_proba first if it looks like a classifier (anytime_td)
-        # But we need to know task type.
-        if "anytime_td" in problem_name:
-             proba = model.predict_proba(X)[:, 1]
+
+    is_classification = task_type in {"classification", "binary", "multiclass"}
+    if is_classification:
+        if hasattr(model, "predict_proba"):
+            preds = model.predict_proba(X)
+            if preds.ndim > 1 and preds.shape[1] > 1:
+                preds = preds[:, 1]
         else:
-             proba = model.predict(X)
-    except AttributeError:
-        proba = model.predict(X)
-        
-    return proba
+            preds = model.predict(X)
+        preds = np.asarray(preds, dtype=float)
+        preds = np.clip(preds, 0.0, 1.0)
+    else:
+        preds = np.asarray(model.predict(X), dtype=float)
 
+    if output_mode and output_mode == "logit":
+        preds = 1.0 / (1.0 + np.exp(-preds))
+
+    return preds
+
 def main() -> None:
     _ensure_imports_ready()
     args = _parse_args()
@@ -2401,7 +2394,7 @@
                 logger.warning("Skipping %s (artifacts not found).", p_name)
                 continue
 
-            preds = _predict_for_problem(features, p_name, artifacts)
+            preds = _predict_for_problem(features, problem, artifacts)
             
             # Apply guards for availability components immediately
             if p_name == "availability_active":
diff --git a/pipeline/train.py b/pipeline/train.py
index 2e2508f5ee50bf4b1877b56465304ecac80dc0bb..30c70ab8292088cc8aad350882ef2c5e8cc7efa6
--- a/pipeline/train.py
+++ b/pipeline/train.py
@@ -2073,7 +2073,7 @@
 
         # --- Save inference artifacts AFTER all models for the problem are trained ---
         # This ensures the state (imputation, categories) is from the pre-tuning/pre-holdout phase.
-        save_inference_artifacts(self, problem_name)
+        save_inference_artifacts(self, problem_name, problem_copy)
 
     def _unwrap_base_model(self, model):
         """Return the true fitted estimator, no matter how it's wrapped."""
@@ -2334,7 +2334,7 @@
                     logger.warning("Failed to initialise team total scaling for %s: %s", problem_name, exc)
             if not use_cached_for_problem:
                 self._fit_feature_artifacts(df_train, problem_copy)
-                save_inference_artifacts(self, problem_name)
+                save_inference_artifacts(self, problem_name, problem_copy)
 
             # Log final feature list used
             logger.info(f"--- Using {len(self.feature_columns)} features for {problem_name} ---")
@@ -2697,4 +2697,4 @@
             train(config_path=args.config, ordinal_only=args.ordinal_only, ordinal_ev=ordinal_ev_flag, **overrides)
     except Exception as e:
         logger.critical(f"The pipeline has failed with a critical error: {e}", exc_info=True)
-        sys.exit(1)
\ No newline at end of file
+        sys.exit(1)
diff --git a/tests/test_predict_probabilities.py b/tests/test_predict_probabilities.py
new file mode 100644
index 0000000000000000000000000000000000000000..bd68c2fa4ae83bf2ab6533daea100378f36d07f3
--- /dev/null
+++ b/tests/test_predict_probabilities.py
@@ -0,0 +1,32 @@
+from pathlib import Path
+
+import numpy as np
+import pandas as pd
+
+import pipeline.predict as predict
+
+
+def test_predict_for_problem_uses_predict_proba(monkeypatch):
+    calls = {"proba": 0, "predict": 0}
+
+    class DummyModel:
+        def predict_proba(self, X):
+            calls["proba"] += 1
+            return np.column_stack([np.zeros(len(X)), np.full(len(X), 0.7)])
+
+        def predict(self, X):
+            calls["predict"] += 1
+            return np.full(len(X), 0.2)
+
+    monkeypatch.setattr(predict.joblib, "load", lambda path: DummyModel())
+    monkeypatch.setattr(predict, "_latest_model_path", lambda name: Path("dummy"))
+
+    artifacts = {"feature_columns": ["a"], "task_type": "classification"}
+    df = pd.DataFrame({"a": [0, 1]})
+
+    preds = predict._predict_for_problem(df, {"name": "any", "task_type": "classification"}, artifacts)
+
+    assert calls["proba"] == 1
+    assert calls["predict"] == 0
+    assert np.allclose(preds, 0.7)
+    assert preds.dtype.kind == "f"
diff --git a/tests/test_training_config_features.py b/tests/test_training_config_features.py
index c8dc5f3391185bd24a48956183ded4d5174f984d..55365dd1217c1453a4f114216d285d83ed880320
--- a/tests/test_training_config_features.py
+++ b/tests/test_training_config_features.py
@@ -14,6 +14,19 @@
         return yaml.safe_load(fh)
 
 
+def test_problem_names_unique():
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    names = [p.get("name") for p in problems]
+    seen = {}
+    duplicates = set()
+    for name in names:
+        if name in seen:
+            duplicates.add(name)
+        seen[name] = True
+    assert not duplicates, f"Duplicate problem names in config: {sorted(duplicates)}"
+
+
 def test_training_config_feature_guards():
     """Ensure columns_to_discard and other_features_to_include don't overlap."""
     training_cfg = _load_training_config()
@@ -113,6 +126,20 @@
     )
 
 
+def test_ps_prefixes_use_hist_namespace():
+    """Prevent accidental inclusion of same-game ps_* columns as features."""
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    offenders = {}
+    for problem in problems:
+        name = problem.get("name", "<unknown>")
+        prefixes = problem.get("feature_prefixes_to_include") or []
+        bad = [p for p in prefixes if p.startswith("ps_") and not p.startswith("ps_hist_")]
+        if bad:
+            offenders[name] = bad
+    assert not offenders, f"Same-game pre-snap prefixes should be removed; found {offenders}"
+
+
 def test_asof_snapshots_not_after_cutoff():
     """Validate that stored snapshot timestamps never exceed the decision cutoff."""
     asof_path = Path(__file__).resolve().parents[1] / "data" / "processed" / "asof_metadata.parquet"
@@ -150,4 +177,3 @@
         "As-of snapshot coverage dropped below expected thresholds: "
         f"{coverage_failures}"
     )
-
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..eb5471f38ae1512ba5cabf81e6baf81aab0e986b
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -44,18 +44,31 @@
             formatted[k] = v
     return formatted
 
-def save_inference_artifacts(trainer, problem_name: str) -> None:
+def save_inference_artifacts(trainer, problem_name: str, problem_config: dict | None = None) -> None:
     # Versioned artifact copy
     v_dir = _vdir(trainer, problem_name, None, "artifacts") / "inference"
     v_dir.mkdir(parents=True, exist_ok=True)
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync


thinking
**Evaluating baseline and historical column handling**

thinking
**Verifying baseline column definitions**
exec
/bin/zsh -lc "sed -n '150,240p' pipeline/predict.py" in /Users/jameswest/Desktop/nfl_predict succeeded in 760ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
    "away_team",
    *ODDS_COLUMNS,
]

BASE_GAME_COLS = [
    "passing_yards",
    "rushing_yards",
    "receiving_yards",
    "pass_attempt",
    "completion",
    "carry",
    "target",
    "reception",
    "passing_td",
    "rushing_td_count",
    "receiving_td_count",
    "touchdowns",
    "td_count",
    "hist_target_share_prev",
file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..dc5fa3ecfb113878ba721fd47fdf8337d4c2abd2
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -398,27 +454,6 @@
       - 'travel_rest_days'
       - 'travel_rest_days_l3'
       - 'rest_days_since_last_game'
-      - 'team_red_zone_'
-      - 'team_goal_to_go_'
-      - 'player_red_zone_'
-      - 'player_goal_to_go_'
-      - 'weather_bad_passing_flag'
-    columns_to_discard: *columns_to_discard
-    feature_prefixes_to_include:
-      - 'pred_'
-      - 'expected_'
-      - 'opp_def_'
-      - 'red_zone_'
-      - 'goal_to_go_'
-      - 'off_ctx_'
-      - 'qb_profile_'
-      - 'weather_'
-    other_features_to_include:
-      - 'week'
-      - 'season'
-      - 'position'
-      - 'total_line'
-      - 'team_implied_total'
       - 'team_red_zone_'
       - 'team_goal_to_go_'
       - 'player_red_zone_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..208733668f46e0f2359cf19bbfb0e59d9c7f2f7c
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -1314,29 +1314,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1369,28 +1375,6 @@
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
 
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
-
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
     if "decision_cutoff_ts" in enriched.columns:
@@ -2331,28 +2315,37 @@
              
     return adj
 
-def _predict_for_problem(features: pd.DataFrame, problem_name: str, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+def _predict_for_problem(features: pd.DataFrame, problem_config: dict, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+    """Load the trained model and return probability or point forecasts based on task metadata."""
+    problem_name = problem_config.get("name", "<unknown>")
+    task_type = str(
+        problem_config.get("task_type")
+        or artifacts.get("task_type")
+        or ""
+    ).lower()
+    output_mode = artifacts.get("output_mode") or problem_config.get("output_mode")
+
     X, _ = _prepare_feature_matrix(features, artifacts)
-    
     model = joblib.load(_latest_model_path(problem_name))
-    
-    # Assuming XGBoost or similar with predict_proba for classification and predict for regression
-    # But for simplicity and compatibility with regression, check model type or problem definition?
-    # Actually, regression models in sklearn/xgb return values directly on predict().
-    # Classification models return class labels on predict(), and probas on predict_proba().
-    
-    try:
-        # Heuristic: Try predict_proba first if it looks like a classifier (anytime_td)
-        # But we need to know task type.
-        if "anytime_td" in problem_name:
-             proba = model.predict_proba(X)[:, 1]
+
+    is_classification = task_type in {"classification", "binary", "multiclass"}
+    if is_classification:
+        if hasattr(model, "predict_proba"):
+            preds = model.predict_proba(X)
+            if preds.ndim > 1 and preds.shape[1] > 1:
+                preds = preds[:, 1]
         else:
-             proba = model.predict(X)
-    except AttributeError:
-        proba = model.predict(X)
-        
-    return proba
+            preds = model.predict(X)
+        preds = np.asarray(preds, dtype=float)
+        preds = np.clip(preds, 0.0, 1.0)
+    else:
+        preds = np.asarray(model.predict(X), dtype=float)
 
+    if output_mode and output_mode == "logit":
+        preds = 1.0 / (1.0 + np.exp(-preds))
+
+    return preds
+
 def main() -> None:
     _ensure_imports_ready()
     args = _parse_args()
@@ -2401,7 +2394,7 @@
                 logger.warning("Skipping %s (artifacts not found).", p_name)
                 continue
 
-            preds = _predict_for_problem(features, p_name, artifacts)
+            preds = _predict_for_problem(features, problem, artifacts)
             
             # Apply guards for availability components immediately
             if p_name == "availability_active":
diff --git a/pipeline/train.py b/pipeline/train.py
index 2e2508f5ee50bf4b1877b56465304ecac80dc0bb..30c70ab8292088cc8aad350882ef2c5e8cc7efa6
--- a/pipeline/train.py
+++ b/pipeline/train.py
@@ -2073,7 +2073,7 @@
 
         # --- Save inference artifacts AFTER all models for the problem are trained ---
         # This ensures the state (imputation, categories) is from the pre-tuning/pre-holdout phase.
-        save_inference_artifacts(self, problem_name)
+        save_inference_artifacts(self, problem_name, problem_copy)
 
     def _unwrap_base_model(self, model):
         """Return the true fitted estimator, no matter how it's wrapped."""
@@ -2334,7 +2334,7 @@
                     logger.warning("Failed to initialise team total scaling for %s: %s", problem_name, exc)
             if not use_cached_for_problem:
                 self._fit_feature_artifacts(df_train, problem_copy)
-                save_inference_artifacts(self, problem_name)
+                save_inference_artifacts(self, problem_name, problem_copy)
 
             # Log final feature list used
             logger.info(f"--- Using {len(self.feature_columns)} features for {problem_name} ---")
@@ -2697,4 +2697,4 @@
             train(config_path=args.config, ordinal_only=args.ordinal_only, ordinal_ev=ordinal_ev_flag, **overrides)
     except Exception as e:
         logger.critical(f"The pipeline has failed with a critical error: {e}", exc_info=True)
-        sys.exit(1)
\ No newline at end of file
+        sys.exit(1)
diff --git a/tests/test_predict_probabilities.py b/tests/test_predict_probabilities.py
new file mode 100644
index 0000000000000000000000000000000000000000..bd68c2fa4ae83bf2ab6533daea100378f36d07f3
--- /dev/null
+++ b/tests/test_predict_probabilities.py
@@ -0,0 +1,32 @@
+from pathlib import Path
+
+import numpy as np
+import pandas as pd
+
+import pipeline.predict as predict
+
+
+def test_predict_for_problem_uses_predict_proba(monkeypatch):
+    calls = {"proba": 0, "predict": 0}
+
+    class DummyModel:
+        def predict_proba(self, X):
+            calls["proba"] += 1
+            return np.column_stack([np.zeros(len(X)), np.full(len(X), 0.7)])
+
+        def predict(self, X):
+            calls["predict"] += 1
+            return np.full(len(X), 0.2)
+
+    monkeypatch.setattr(predict.joblib, "load", lambda path: DummyModel())
+    monkeypatch.setattr(predict, "_latest_model_path", lambda name: Path("dummy"))
+
+    artifacts = {"feature_columns": ["a"], "task_type": "classification"}
+    df = pd.DataFrame({"a": [0, 1]})
+
+    preds = predict._predict_for_problem(df, {"name": "any", "task_type": "classification"}, artifacts)
+
+    assert calls["proba"] == 1
+    assert calls["predict"] == 0
+    assert np.allclose(preds, 0.7)
+    assert preds.dtype.kind == "f"
diff --git a/tests/test_training_config_features.py b/tests/test_training_config_features.py
index c8dc5f3391185bd24a48956183ded4d5174f984d..55365dd1217c1453a4f114216d285d83ed880320
--- a/tests/test_training_config_features.py
+++ b/tests/test_training_config_features.py
@@ -14,6 +14,19 @@
         return yaml.safe_load(fh)
 
 
+def test_problem_names_unique():
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    names = [p.get("name") for p in problems]
+    seen = {}
+    duplicates = set()
+    for name in names:
+        if name in seen:
+            duplicates.add(name)
+        seen[name] = True
+    assert not duplicates, f"Duplicate problem names in config: {sorted(duplicates)}"
+
+
 def test_training_config_feature_guards():
     """Ensure columns_to_discard and other_features_to_include don't overlap."""
     training_cfg = _load_training_config()
@@ -113,6 +126,20 @@
     )
 
 
+def test_ps_prefixes_use_hist_namespace():
+    """Prevent accidental inclusion of same-game ps_* columns as features."""
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    offenders = {}
+    for problem in problems:
+        name = problem.get("name", "<unknown>")
+        prefixes = problem.get("feature_prefixes_to_include") or []
+        bad = [p for p in prefixes if p.startswith("ps_") and not p.startswith("ps_hist_")]
+        if bad:
+            offenders[name] = bad
+    assert not offenders, f"Same-game pre-snap prefixes should be removed; found {offenders}"
+
+
 def test_asof_snapshots_not_after_cutoff():
     """Validate that stored snapshot timestamps never exceed the decision cutoff."""
     asof_path = Path(__file__).resolve().parents[1] / "data" / "processed" / "asof_metadata.parquet"
@@ -150,4 +177,3 @@
         "As-of snapshot coverage dropped below expected thresholds: "
         f"{coverage_failures}"
     )
-
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..eb5471f38ae1512ba5cabf81e6baf81aab0e986b
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -44,18 +44,31 @@
             formatted[k] = v
     return formatted
 
-def save_inference_artifacts(trainer, problem_name: str) -> None:
+def save_inference_artifacts(trainer, problem_name: str, problem_config: dict | None = None) -> None:
     # Versioned artifact copy
     v_dir = _vdir(trainer, problem_name, None, "artifacts") / "inference"
     v_dir.mkdir(parents=True, exist_ok=True)
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync


thinking
**Extending baseline and fallback mappings**

I'm considering adding the ps_hist versions of existing prev/l3 columns to the PS_BASELINE_COLUMNS and updating the PS_L3_FALLBACK_MAP accordingly to maintain fallback behavior for when l3 data is missing. This involves expanding the lists to include many ps_hist equivalents based on the rename_map, ensuring compatibility and fallback continuity without dropping the original base columns. It's a bit complex but manageable.
file update
M /Users/jameswest/Desktop/nfl_predict/pipeline/predict.py
@@ -217,2 +217,31 @@
     "ps_targets_backfield_count_l3",
+    # Historical namespace (preferred)
+    "ps_hist_route_participation_pct_prev",
+    "ps_hist_route_participation_pct_l3",
+    "ps_hist_route_participation_plays_prev",
+    "ps_hist_route_participation_plays_l3",
+    "ps_hist_targets_total_prev",
+    "ps_hist_targets_total_l3",
+    "ps_hist_targets_slot_count_prev",
+    "ps_hist_targets_slot_count_l3",
+    "ps_hist_targets_wide_count_prev",
+    "ps_hist_targets_wide_count_l3",
+    "ps_hist_targets_inline_count_prev",
+    "ps_hist_targets_inline_count_l3",
+    "ps_hist_targets_backfield_count_prev",
+    "ps_hist_targets_backfield_count_l3",
+    "ps_hist_targets_slot_share_prev",
+    "ps_hist_targets_slot_share_l3",
+    "ps_hist_targets_wide_share_prev",
+    "ps_hist_targets_wide_share_l3",
+    "ps_hist_targets_inline_share_prev",
+    "ps_hist_targets_inline_share_l3",
+    "ps_hist_targets_backfield_share_prev",
+    "ps_hist_targets_backfield_share_l3",
+    "ps_hist_total_touches_prev",
+    "ps_hist_total_touches_l3",
+    "ps_hist_scripted_touches_prev",
+    "ps_hist_scripted_touches_l3",
+    "ps_hist_scripted_touch_share_prev",
+    "ps_hist_scripted_touch_share_l3",
 ]
@@ -226,2 +255,16 @@
     "ps_targets_backfield_count_l3": "ps_targets_backfield_count",
+    "ps_hist_route_participation_plays_l3": "ps_hist_route_participation_plays_prev",
+    "ps_hist_targets_total_l3": "ps_hist_targets_total_prev",
+    "ps_hist_targets_slot_count_l3": "ps_hist_targets_slot_count_prev",
+    "ps_hist_targets_wide_count_l3": "ps_hist_targets_wide_count_prev",
+    "ps_hist_targets_inline_count_l3": "ps_hist_targets_inline_count_prev",
+    "ps_hist_targets_backfield_count_l3": "ps_hist_targets_backfield_count_prev",
+    "ps_hist_total_touches_l3": "ps_hist_total_touches_prev",
+    "ps_hist_scripted_touches_l3": "ps_hist_scripted_touches_prev",
+    "ps_hist_route_participation_pct_l3": "ps_hist_route_participation_pct_prev",
+    "ps_hist_scripted_touch_share_l3": "ps_hist_scripted_touch_share_prev",
+    "ps_hist_targets_slot_share_l3": "ps_hist_targets_slot_share_prev",
+    "ps_hist_targets_wide_share_l3": "ps_hist_targets_wide_share_prev",
+    "ps_hist_targets_inline_share_l3": "ps_hist_targets_inline_share_prev",
+    "ps_hist_targets_backfield_share_l3": "ps_hist_targets_backfield_share_prev",
 }
apply_patch(auto_approved=true) exited 0 in 140ms:
Success. Updated the following files:
M pipeline/predict.py
file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..dc5fa3ecfb113878ba721fd47fdf8337d4c2abd2
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -398,27 +454,6 @@
       - 'travel_rest_days'
       - 'travel_rest_days_l3'
       - 'rest_days_since_last_game'
-      - 'team_red_zone_'
-      - 'team_goal_to_go_'
-      - 'player_red_zone_'
-      - 'player_goal_to_go_'
-      - 'weather_bad_passing_flag'
-    columns_to_discard: *columns_to_discard
-    feature_prefixes_to_include:
-      - 'pred_'
-      - 'expected_'
-      - 'opp_def_'
-      - 'red_zone_'
-      - 'goal_to_go_'
-      - 'off_ctx_'
-      - 'qb_profile_'
-      - 'weather_'
-    other_features_to_include:
-      - 'week'
-      - 'season'
-      - 'position'
-      - 'total_line'
-      - 'team_implied_total'
       - 'team_red_zone_'
       - 'team_goal_to_go_'
       - 'player_red_zone_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..949edb71af9513cfd859e5f2a1316499906b045c
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -215,6 +215,35 @@
     "ps_targets_wide_count_l3",
     "ps_targets_inline_count_l3",
     "ps_targets_backfield_count_l3",
+    # Historical namespace (preferred)
+    "ps_hist_route_participation_pct_prev",
+    "ps_hist_route_participation_pct_l3",
+    "ps_hist_route_participation_plays_prev",
+    "ps_hist_route_participation_plays_l3",
+    "ps_hist_targets_total_prev",
+    "ps_hist_targets_total_l3",
+    "ps_hist_targets_slot_count_prev",
+    "ps_hist_targets_slot_count_l3",
+    "ps_hist_targets_wide_count_prev",
+    "ps_hist_targets_wide_count_l3",
+    "ps_hist_targets_inline_count_prev",
+    "ps_hist_targets_inline_count_l3",
+    "ps_hist_targets_backfield_count_prev",
+    "ps_hist_targets_backfield_count_l3",
+    "ps_hist_targets_slot_share_prev",
+    "ps_hist_targets_slot_share_l3",
+    "ps_hist_targets_wide_share_prev",
+    "ps_hist_targets_wide_share_l3",
+    "ps_hist_targets_inline_share_prev",
+    "ps_hist_targets_inline_share_l3",
+    "ps_hist_targets_backfield_share_prev",
+    "ps_hist_targets_backfield_share_l3",
+    "ps_hist_total_touches_prev",
+    "ps_hist_total_touches_l3",
+    "ps_hist_scripted_touches_prev",
+    "ps_hist_scripted_touches_l3",
+    "ps_hist_scripted_touch_share_prev",
+    "ps_hist_scripted_touch_share_l3",
 ]
 
 PS_L3_FALLBACK_MAP = {
@@ -224,6 +253,20 @@
     "ps_targets_wide_count_l3": "ps_targets_wide_count",
     "ps_targets_inline_count_l3": "ps_targets_inline_count",
     "ps_targets_backfield_count_l3": "ps_targets_backfield_count",
+    "ps_hist_route_participation_plays_l3": "ps_hist_route_participation_plays_prev",
+    "ps_hist_targets_total_l3": "ps_hist_targets_total_prev",
+    "ps_hist_targets_slot_count_l3": "ps_hist_targets_slot_count_prev",
+    "ps_hist_targets_wide_count_l3": "ps_hist_targets_wide_count_prev",
+    "ps_hist_targets_inline_count_l3": "ps_hist_targets_inline_count_prev",
+    "ps_hist_targets_backfield_count_l3": "ps_hist_targets_backfield_count_prev",
+    "ps_hist_total_touches_l3": "ps_hist_total_touches_prev",
+    "ps_hist_scripted_touches_l3": "ps_hist_scripted_touches_prev",
+    "ps_hist_route_participation_pct_l3": "ps_hist_route_participation_pct_prev",
+    "ps_hist_scripted_touch_share_l3": "ps_hist_scripted_touch_share_prev",
+    "ps_hist_targets_slot_share_l3": "ps_hist_targets_slot_share_prev",
+    "ps_hist_targets_wide_share_l3": "ps_hist_targets_wide_share_prev",
+    "ps_hist_targets_inline_share_l3": "ps_hist_targets_inline_share_prev",
+    "ps_hist_targets_backfield_share_l3": "ps_hist_targets_backfield_share_prev",
 }
 
 OUTPUT_COLUMN_PREFIXES = (
@@ -1314,29 +1357,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1369,28 +1418,6 @@
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
 
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
-
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
     if "decision_cutoff_ts" in enriched.columns:
@@ -2331,27 +2358,36 @@
              
     return adj
 
-def _predict_for_problem(features: pd.DataFrame, problem_name: str, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+def _predict_for_problem(features: pd.DataFrame, problem_config: dict, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+    """Load the trained model and return probability or point forecasts based on task metadata."""
+    problem_name = problem_config.get("name", "<unknown>")
+    task_type = str(
+        problem_config.get("task_type")
+        or artifacts.get("task_type")
+        or ""
+    ).lower()
+    output_mode = artifacts.get("output_mode") or problem_config.get("output_mode")
+
     X, _ = _prepare_feature_matrix(features, artifacts)
-    
     model = joblib.load(_latest_model_path(problem_name))
-    
-    # Assuming XGBoost or similar with predict_proba for classification and predict for regression
-    # But for simplicity and compatibility with regression, check model type or problem definition?
-    # Actually, regression models in sklearn/xgb return values directly on predict().
-    # Classification models return class labels on predict(), and probas on predict_proba().
-    
-    try:
-        # Heuristic: Try predict_proba first if it looks like a classifier (anytime_td)
-        # But we need to know task type.
-        if "anytime_td" in problem_name:
-             proba = model.predict_proba(X)[:, 1]
+
+    is_classification = task_type in {"classification", "binary", "multiclass"}
+    if is_classification:
+        if hasattr(model, "predict_proba"):
+            preds = model.predict_proba(X)
+            if preds.ndim > 1 and preds.shape[1] > 1:
+                preds = preds[:, 1]
         else:
-             proba = model.predict(X)
-    except AttributeError:
-        proba = model.predict(X)
-        
-    return proba
+            preds = model.predict(X)
+        preds = np.asarray(preds, dtype=float)
+        preds = np.clip(preds, 0.0, 1.0)
+    else:
+        preds = np.asarray(model.predict(X), dtype=float)
+
+    if output_mode and output_mode == "logit":
+        preds = 1.0 / (1.0 + np.exp(-preds))
+
+    return preds
 
 def main() -> None:
     _ensure_imports_ready()
@@ -2401,7 +2437,7 @@
                 logger.warning("Skipping %s (artifacts not found).", p_name)
                 continue
 
-            preds = _predict_for_problem(features, p_name, artifacts)
+            preds = _predict_for_problem(features, problem, artifacts)
             
             # Apply guards for availability components immediately
             if p_name == "availability_active":
diff --git a/pipeline/train.py b/pipeline/train.py
index 2e2508f5ee50bf4b1877b56465304ecac80dc0bb..30c70ab8292088cc8aad350882ef2c5e8cc7efa6
--- a/pipeline/train.py
+++ b/pipeline/train.py
@@ -2073,7 +2073,7 @@
 
         # --- Save inference artifacts AFTER all models for the problem are trained ---
         # This ensures the state (imputation, categories) is from the pre-tuning/pre-holdout phase.
-        save_inference_artifacts(self, problem_name)
+        save_inference_artifacts(self, problem_name, problem_copy)
 
     def _unwrap_base_model(self, model):
         """Return the true fitted estimator, no matter how it's wrapped."""
@@ -2334,7 +2334,7 @@
                     logger.warning("Failed to initialise team total scaling for %s: %s", problem_name, exc)
             if not use_cached_for_problem:
                 self._fit_feature_artifacts(df_train, problem_copy)
-                save_inference_artifacts(self, problem_name)
+                save_inference_artifacts(self, problem_name, problem_copy)
 
             # Log final feature list used
             logger.info(f"--- Using {len(self.feature_columns)} features for {problem_name} ---")
@@ -2697,4 +2697,4 @@
             train(config_path=args.config, ordinal_only=args.ordinal_only, ordinal_ev=ordinal_ev_flag, **overrides)
     except Exception as e:
         logger.critical(f"The pipeline has failed with a critical error: {e}", exc_info=True)
-        sys.exit(1)
\ No newline at end of file
+        sys.exit(1)
diff --git a/tests/test_predict_probabilities.py b/tests/test_predict_probabilities.py
new file mode 100644
index 0000000000000000000000000000000000000000..bd68c2fa4ae83bf2ab6533daea100378f36d07f3
--- /dev/null
+++ b/tests/test_predict_probabilities.py
@@ -0,0 +1,32 @@
+from pathlib import Path
+
+import numpy as np
+import pandas as pd
+
+import pipeline.predict as predict
+
+
+def test_predict_for_problem_uses_predict_proba(monkeypatch):
+    calls = {"proba": 0, "predict": 0}
+
+    class DummyModel:
+        def predict_proba(self, X):
+            calls["proba"] += 1
+            return np.column_stack([np.zeros(len(X)), np.full(len(X), 0.7)])
+
+        def predict(self, X):
+            calls["predict"] += 1
+            return np.full(len(X), 0.2)
+
+    monkeypatch.setattr(predict.joblib, "load", lambda path: DummyModel())
+    monkeypatch.setattr(predict, "_latest_model_path", lambda name: Path("dummy"))
+
+    artifacts = {"feature_columns": ["a"], "task_type": "classification"}
+    df = pd.DataFrame({"a": [0, 1]})
+
+    preds = predict._predict_for_problem(df, {"name": "any", "task_type": "classification"}, artifacts)
+
+    assert calls["proba"] == 1
+    assert calls["predict"] == 0
+    assert np.allclose(preds, 0.7)
+    assert preds.dtype.kind == "f"
diff --git a/tests/test_training_config_features.py b/tests/test_training_config_features.py
index c8dc5f3391185bd24a48956183ded4d5174f984d..55365dd1217c1453a4f114216d285d83ed880320
--- a/tests/test_training_config_features.py
+++ b/tests/test_training_config_features.py
@@ -14,6 +14,19 @@
         return yaml.safe_load(fh)
 
 
+def test_problem_names_unique():
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    names = [p.get("name") for p in problems]
+    seen = {}
+    duplicates = set()
+    for name in names:
+        if name in seen:
+            duplicates.add(name)
+        seen[name] = True
+    assert not duplicates, f"Duplicate problem names in config: {sorted(duplicates)}"
+
+
 def test_training_config_feature_guards():
     """Ensure columns_to_discard and other_features_to_include don't overlap."""
     training_cfg = _load_training_config()
@@ -113,6 +126,20 @@
     )
 
 
+def test_ps_prefixes_use_hist_namespace():
+    """Prevent accidental inclusion of same-game ps_* columns as features."""
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    offenders = {}
+    for problem in problems:
+        name = problem.get("name", "<unknown>")
+        prefixes = problem.get("feature_prefixes_to_include") or []
+        bad = [p for p in prefixes if p.startswith("ps_") and not p.startswith("ps_hist_")]
+        if bad:
+            offenders[name] = bad
+    assert not offenders, f"Same-game pre-snap prefixes should be removed; found {offenders}"
+
+
 def test_asof_snapshots_not_after_cutoff():
     """Validate that stored snapshot timestamps never exceed the decision cutoff."""
     asof_path = Path(__file__).resolve().parents[1] / "data" / "processed" / "asof_metadata.parquet"
@@ -150,4 +177,3 @@
         "As-of snapshot coverage dropped below expected thresholds: "
         f"{coverage_failures}"
     )
-
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..eb5471f38ae1512ba5cabf81e6baf81aab0e986b
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -44,18 +44,31 @@
             formatted[k] = v
     return formatted
 
-def save_inference_artifacts(trainer, problem_name: str) -> None:
+def save_inference_artifacts(trainer, problem_name: str, problem_config: dict | None = None) -> None:
     # Versioned artifact copy
     v_dir = _vdir(trainer, problem_name, None, "artifacts") / "inference"
     v_dir.mkdir(parents=True, exist_ok=True)
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync

file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..dc5fa3ecfb113878ba721fd47fdf8337d4c2abd2
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -398,27 +454,6 @@
       - 'travel_rest_days'
       - 'travel_rest_days_l3'
       - 'rest_days_since_last_game'
-      - 'team_red_zone_'
-      - 'team_goal_to_go_'
-      - 'player_red_zone_'
-      - 'player_goal_to_go_'
-      - 'weather_bad_passing_flag'
-    columns_to_discard: *columns_to_discard
-    feature_prefixes_to_include:
-      - 'pred_'
-      - 'expected_'
-      - 'opp_def_'
-      - 'red_zone_'
-      - 'goal_to_go_'
-      - 'off_ctx_'
-      - 'qb_profile_'
-      - 'weather_'
-    other_features_to_include:
-      - 'week'
-      - 'season'
-      - 'position'
-      - 'total_line'
-      - 'team_implied_total'
       - 'team_red_zone_'
       - 'team_goal_to_go_'
       - 'player_red_zone_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..949edb71af9513cfd859e5f2a1316499906b045c
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -215,6 +215,35 @@
     "ps_targets_wide_count_l3",
     "ps_targets_inline_count_l3",
     "ps_targets_backfield_count_l3",
+    # Historical namespace (preferred)
+    "ps_hist_route_participation_pct_prev",
+    "ps_hist_route_participation_pct_l3",
+    "ps_hist_route_participation_plays_prev",
+    "ps_hist_route_participation_plays_l3",
+    "ps_hist_targets_total_prev",
+    "ps_hist_targets_total_l3",
+    "ps_hist_targets_slot_count_prev",
+    "ps_hist_targets_slot_count_l3",
+    "ps_hist_targets_wide_count_prev",
+    "ps_hist_targets_wide_count_l3",
+    "ps_hist_targets_inline_count_prev",
+    "ps_hist_targets_inline_count_l3",
+    "ps_hist_targets_backfield_count_prev",
+    "ps_hist_targets_backfield_count_l3",
+    "ps_hist_targets_slot_share_prev",
+    "ps_hist_targets_slot_share_l3",
+    "ps_hist_targets_wide_share_prev",
+    "ps_hist_targets_wide_share_l3",
+    "ps_hist_targets_inline_share_prev",
+    "ps_hist_targets_inline_share_l3",
+    "ps_hist_targets_backfield_share_prev",
+    "ps_hist_targets_backfield_share_l3",
+    "ps_hist_total_touches_prev",
+    "ps_hist_total_touches_l3",
+    "ps_hist_scripted_touches_prev",
+    "ps_hist_scripted_touches_l3",
+    "ps_hist_scripted_touch_share_prev",
+    "ps_hist_scripted_touch_share_l3",
 ]
 
 PS_L3_FALLBACK_MAP = {
@@ -224,6 +253,20 @@
     "ps_targets_wide_count_l3": "ps_targets_wide_count",
     "ps_targets_inline_count_l3": "ps_targets_inline_count",
     "ps_targets_backfield_count_l3": "ps_targets_backfield_count",
+    "ps_hist_route_participation_plays_l3": "ps_hist_route_participation_plays_prev",
+    "ps_hist_targets_total_l3": "ps_hist_targets_total_prev",
+    "ps_hist_targets_slot_count_l3": "ps_hist_targets_slot_count_prev",
+    "ps_hist_targets_wide_count_l3": "ps_hist_targets_wide_count_prev",
+    "ps_hist_targets_inline_count_l3": "ps_hist_targets_inline_count_prev",
+    "ps_hist_targets_backfield_count_l3": "ps_hist_targets_backfield_count_prev",
+    "ps_hist_total_touches_l3": "ps_hist_total_touches_prev",
+    "ps_hist_scripted_touches_l3": "ps_hist_scripted_touches_prev",
+    "ps_hist_route_participation_pct_l3": "ps_hist_route_participation_pct_prev",
+    "ps_hist_scripted_touch_share_l3": "ps_hist_scripted_touch_share_prev",
+    "ps_hist_targets_slot_share_l3": "ps_hist_targets_slot_share_prev",
+    "ps_hist_targets_wide_share_l3": "ps_hist_targets_wide_share_prev",
+    "ps_hist_targets_inline_share_l3": "ps_hist_targets_inline_share_prev",
+    "ps_hist_targets_backfield_share_l3": "ps_hist_targets_backfield_share_prev",
 }
 
 OUTPUT_COLUMN_PREFIXES = (
@@ -1314,29 +1357,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1369,28 +1418,6 @@
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
 
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
-
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
     if "decision_cutoff_ts" in enriched.columns:
@@ -2331,27 +2358,36 @@
              
     return adj
 
-def _predict_for_problem(features: pd.DataFrame, problem_name: str, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+def _predict_for_problem(features: pd.DataFrame, problem_config: dict, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+    """Load the trained model and return probability or point forecasts based on task metadata."""
+    problem_name = problem_config.get("name", "<unknown>")
+    task_type = str(
+        problem_config.get("task_type")
+        or artifacts.get("task_type")
+        or ""
+    ).lower()
+    output_mode = artifacts.get("output_mode") or problem_config.get("output_mode")
+
     X, _ = _prepare_feature_matrix(features, artifacts)
-    
     model = joblib.load(_latest_model_path(problem_name))
-    
-    # Assuming XGBoost or similar with predict_proba for classification and predict for regression
-    # But for simplicity and compatibility with regression, check model type or problem definition?
-    # Actually, regression models in sklearn/xgb return values directly on predict().
-    # Classification models return class labels on predict(), and probas on predict_proba().
-    
-    try:
-        # Heuristic: Try predict_proba first if it looks like a classifier (anytime_td)
-        # But we need to know task type.
-        if "anytime_td" in problem_name:
-             proba = model.predict_proba(X)[:, 1]
+
+    is_classification = task_type in {"classification", "binary", "multiclass"}
+    if is_classification:
+        if hasattr(model, "predict_proba"):
+            preds = model.predict_proba(X)
+            if preds.ndim > 1 and preds.shape[1] > 1:
+                preds = preds[:, 1]
         else:
-             proba = model.predict(X)
-    except AttributeError:
-        proba = model.predict(X)
-        
-    return proba
+            preds = model.predict(X)
+        preds = np.asarray(preds, dtype=float)
+        preds = np.clip(preds, 0.0, 1.0)
+    else:
+        preds = np.asarray(model.predict(X), dtype=float)
+
+    if output_mode and output_mode == "logit":
+        preds = 1.0 / (1.0 + np.exp(-preds))
+
+    return preds
 
 def main() -> None:
     _ensure_imports_ready()
@@ -2401,7 +2437,7 @@
                 logger.warning("Skipping %s (artifacts not found).", p_name)
                 continue
 
-            preds = _predict_for_problem(features, p_name, artifacts)
+            preds = _predict_for_problem(features, problem, artifacts)
             
             # Apply guards for availability components immediately
             if p_name == "availability_active":
diff --git a/pipeline/train.py b/pipeline/train.py
index 2e2508f5ee50bf4b1877b56465304ecac80dc0bb..30c70ab8292088cc8aad350882ef2c5e8cc7efa6
--- a/pipeline/train.py
+++ b/pipeline/train.py
@@ -2073,7 +2073,7 @@
 
         # --- Save inference artifacts AFTER all models for the problem are trained ---
         # This ensures the state (imputation, categories) is from the pre-tuning/pre-holdout phase.
-        save_inference_artifacts(self, problem_name)
+        save_inference_artifacts(self, problem_name, problem_copy)
 
     def _unwrap_base_model(self, model):
         """Return the true fitted estimator, no matter how it's wrapped."""
@@ -2334,7 +2334,7 @@
                     logger.warning("Failed to initialise team total scaling for %s: %s", problem_name, exc)
             if not use_cached_for_problem:
                 self._fit_feature_artifacts(df_train, problem_copy)
-                save_inference_artifacts(self, problem_name)
+                save_inference_artifacts(self, problem_name, problem_copy)
 
             # Log final feature list used
             logger.info(f"--- Using {len(self.feature_columns)} features for {problem_name} ---")
@@ -2697,4 +2697,4 @@
             train(config_path=args.config, ordinal_only=args.ordinal_only, ordinal_ev=ordinal_ev_flag, **overrides)
     except Exception as e:
         logger.critical(f"The pipeline has failed with a critical error: {e}", exc_info=True)
-        sys.exit(1)
\ No newline at end of file
+        sys.exit(1)
diff --git a/tests/test_predict_probabilities.py b/tests/test_predict_probabilities.py
new file mode 100644
index 0000000000000000000000000000000000000000..bd68c2fa4ae83bf2ab6533daea100378f36d07f3
--- /dev/null
+++ b/tests/test_predict_probabilities.py
@@ -0,0 +1,32 @@
+from pathlib import Path
+
+import numpy as np
+import pandas as pd
+
+import pipeline.predict as predict
+
+
+def test_predict_for_problem_uses_predict_proba(monkeypatch):
+    calls = {"proba": 0, "predict": 0}
+
+    class DummyModel:
+        def predict_proba(self, X):
+            calls["proba"] += 1
+            return np.column_stack([np.zeros(len(X)), np.full(len(X), 0.7)])
+
+        def predict(self, X):
+            calls["predict"] += 1
+            return np.full(len(X), 0.2)
+
+    monkeypatch.setattr(predict.joblib, "load", lambda path: DummyModel())
+    monkeypatch.setattr(predict, "_latest_model_path", lambda name: Path("dummy"))
+
+    artifacts = {"feature_columns": ["a"], "task_type": "classification"}
+    df = pd.DataFrame({"a": [0, 1]})
+
+    preds = predict._predict_for_problem(df, {"name": "any", "task_type": "classification"}, artifacts)
+
+    assert calls["proba"] == 1
+    assert calls["predict"] == 0
+    assert np.allclose(preds, 0.7)
+    assert preds.dtype.kind == "f"
diff --git a/tests/test_training_config_features.py b/tests/test_training_config_features.py
index c8dc5f3391185bd24a48956183ded4d5174f984d..55365dd1217c1453a4f114216d285d83ed880320
--- a/tests/test_training_config_features.py
+++ b/tests/test_training_config_features.py
@@ -14,6 +14,19 @@
         return yaml.safe_load(fh)
 
 
+def test_problem_names_unique():
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    names = [p.get("name") for p in problems]
+    seen = {}
+    duplicates = set()
+    for name in names:
+        if name in seen:
+            duplicates.add(name)
+        seen[name] = True
+    assert not duplicates, f"Duplicate problem names in config: {sorted(duplicates)}"
+
+
 def test_training_config_feature_guards():
     """Ensure columns_to_discard and other_features_to_include don't overlap."""
     training_cfg = _load_training_config()
@@ -113,6 +126,20 @@
     )
 
 
+def test_ps_prefixes_use_hist_namespace():
+    """Prevent accidental inclusion of same-game ps_* columns as features."""
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    offenders = {}
+    for problem in problems:
+        name = problem.get("name", "<unknown>")
+        prefixes = problem.get("feature_prefixes_to_include") or []
+        bad = [p for p in prefixes if p.startswith("ps_") and not p.startswith("ps_hist_")]
+        if bad:
+            offenders[name] = bad
+    assert not offenders, f"Same-game pre-snap prefixes should be removed; found {offenders}"
+
+
 def test_asof_snapshots_not_after_cutoff():
     """Validate that stored snapshot timestamps never exceed the decision cutoff."""
     asof_path = Path(__file__).resolve().parents[1] / "data" / "processed" / "asof_metadata.parquet"
@@ -150,4 +177,3 @@
         "As-of snapshot coverage dropped below expected thresholds: "
         f"{coverage_failures}"
     )
-
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..eb5471f38ae1512ba5cabf81e6baf81aab0e986b
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -44,18 +44,31 @@
             formatted[k] = v
     return formatted
 
-def save_inference_artifacts(trainer, problem_name: str) -> None:
+def save_inference_artifacts(trainer, problem_name: str, problem_config: dict | None = None) -> None:
     # Versioned artifact copy
     v_dir = _vdir(trainer, problem_name, None, "artifacts") / "inference"
     v_dir.mkdir(parents=True, exist_ok=True)
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync


thinking
**Reviewing feature integration and dataset adjustments**

thinking
**Checking git status for changes**
exec
/bin/zsh -lc 'git status --short' in /Users/jameswest/Desktop/nfl_predict succeeded in 793ms:
/opt/homebrew/Library/Homebrew/cmd/shellenv.sh: line 18: /bin/ps: Operation not permitted
 M codex_meta_loop.py
 M docs/rolling_window_implementation.md
 M pipeline/feature.py
 M pipeline/predict.py
 M pipeline/train.py
 M tests/test_training_config_features.py
 M utils/feature/player_game_level.py
 M utils/feature/rolling_window.py
 M utils/feature/stats.py
 M utils/general/constants.py
 M utils/train/persist.py
?? .codex_meta_logs/
?? codex_output.md
?? tests/test_predict_probabilities.py
file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..dc5fa3ecfb113878ba721fd47fdf8337d4c2abd2
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -398,27 +454,6 @@
       - 'travel_rest_days'
       - 'travel_rest_days_l3'
       - 'rest_days_since_last_game'
-      - 'team_red_zone_'
-      - 'team_goal_to_go_'
-      - 'player_red_zone_'
-      - 'player_goal_to_go_'
-      - 'weather_bad_passing_flag'
-    columns_to_discard: *columns_to_discard
-    feature_prefixes_to_include:
-      - 'pred_'
-      - 'expected_'
-      - 'opp_def_'
-      - 'red_zone_'
-      - 'goal_to_go_'
-      - 'off_ctx_'
-      - 'qb_profile_'
-      - 'weather_'
-    other_features_to_include:
-      - 'week'
-      - 'season'
-      - 'position'
-      - 'total_line'
-      - 'team_implied_total'
       - 'team_red_zone_'
       - 'team_goal_to_go_'
       - 'player_red_zone_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..949edb71af9513cfd859e5f2a1316499906b045c
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -215,6 +215,35 @@
     "ps_targets_wide_count_l3",
     "ps_targets_inline_count_l3",
     "ps_targets_backfield_count_l3",
+    # Historical namespace (preferred)
+    "ps_hist_route_participation_pct_prev",
+    "ps_hist_route_participation_pct_l3",
+    "ps_hist_route_participation_plays_prev",
+    "ps_hist_route_participation_plays_l3",
+    "ps_hist_targets_total_prev",
+    "ps_hist_targets_total_l3",
+    "ps_hist_targets_slot_count_prev",
+    "ps_hist_targets_slot_count_l3",
+    "ps_hist_targets_wide_count_prev",
+    "ps_hist_targets_wide_count_l3",
+    "ps_hist_targets_inline_count_prev",
+    "ps_hist_targets_inline_count_l3",
+    "ps_hist_targets_backfield_count_prev",
+    "ps_hist_targets_backfield_count_l3",
+    "ps_hist_targets_slot_share_prev",
+    "ps_hist_targets_slot_share_l3",
+    "ps_hist_targets_wide_share_prev",
+    "ps_hist_targets_wide_share_l3",
+    "ps_hist_targets_inline_share_prev",
+    "ps_hist_targets_inline_share_l3",
+    "ps_hist_targets_backfield_share_prev",
+    "ps_hist_targets_backfield_share_l3",
+    "ps_hist_total_touches_prev",
+    "ps_hist_total_touches_l3",
+    "ps_hist_scripted_touches_prev",
+    "ps_hist_scripted_touches_l3",
+    "ps_hist_scripted_touch_share_prev",
+    "ps_hist_scripted_touch_share_l3",
 ]
 
 PS_L3_FALLBACK_MAP = {
@@ -224,6 +253,20 @@
     "ps_targets_wide_count_l3": "ps_targets_wide_count",
     "ps_targets_inline_count_l3": "ps_targets_inline_count",
     "ps_targets_backfield_count_l3": "ps_targets_backfield_count",
+    "ps_hist_route_participation_plays_l3": "ps_hist_route_participation_plays_prev",
+    "ps_hist_targets_total_l3": "ps_hist_targets_total_prev",
+    "ps_hist_targets_slot_count_l3": "ps_hist_targets_slot_count_prev",
+    "ps_hist_targets_wide_count_l3": "ps_hist_targets_wide_count_prev",
+    "ps_hist_targets_inline_count_l3": "ps_hist_targets_inline_count_prev",
+    "ps_hist_targets_backfield_count_l3": "ps_hist_targets_backfield_count_prev",
+    "ps_hist_total_touches_l3": "ps_hist_total_touches_prev",
+    "ps_hist_scripted_touches_l3": "ps_hist_scripted_touches_prev",
+    "ps_hist_route_participation_pct_l3": "ps_hist_route_participation_pct_prev",
+    "ps_hist_scripted_touch_share_l3": "ps_hist_scripted_touch_share_prev",
+    "ps_hist_targets_slot_share_l3": "ps_hist_targets_slot_share_prev",
+    "ps_hist_targets_wide_share_l3": "ps_hist_targets_wide_share_prev",
+    "ps_hist_targets_inline_share_l3": "ps_hist_targets_inline_share_prev",
+    "ps_hist_targets_backfield_share_l3": "ps_hist_targets_backfield_share_prev",
 }
 
 OUTPUT_COLUMN_PREFIXES = (
@@ -1314,29 +1357,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1369,28 +1418,6 @@
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
 
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
-
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
     if "decision_cutoff_ts" in enriched.columns:
@@ -2331,27 +2358,36 @@
              
     return adj
 
-def _predict_for_problem(features: pd.DataFrame, problem_name: str, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+def _predict_for_problem(features: pd.DataFrame, problem_config: dict, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+    """Load the trained model and return probability or point forecasts based on task metadata."""
+    problem_name = problem_config.get("name", "<unknown>")
+    task_type = str(
+        problem_config.get("task_type")
+        or artifacts.get("task_type")
+        or ""
+    ).lower()
+    output_mode = artifacts.get("output_mode") or problem_config.get("output_mode")
+
     X, _ = _prepare_feature_matrix(features, artifacts)
-    
     model = joblib.load(_latest_model_path(problem_name))
-    
-    # Assuming XGBoost or similar with predict_proba for classification and predict for regression
-    # But for simplicity and compatibility with regression, check model type or problem definition?
-    # Actually, regression models in sklearn/xgb return values directly on predict().
-    # Classification models return class labels on predict(), and probas on predict_proba().
-    
-    try:
-        # Heuristic: Try predict_proba first if it looks like a classifier (anytime_td)
-        # But we need to know task type.
-        if "anytime_td" in problem_name:
-             proba = model.predict_proba(X)[:, 1]
+
+    is_classification = task_type in {"classification", "binary", "multiclass"}
+    if is_classification:
+        if hasattr(model, "predict_proba"):
+            preds = model.predict_proba(X)
+            if preds.ndim > 1 and preds.shape[1] > 1:
+                preds = preds[:, 1]
         else:
-             proba = model.predict(X)
-    except AttributeError:
-        proba = model.predict(X)
-        
-    return proba
+            preds = model.predict(X)
+        preds = np.asarray(preds, dtype=float)
+        preds = np.clip(preds, 0.0, 1.0)
+    else:
+        preds = np.asarray(model.predict(X), dtype=float)
+
+    if output_mode and output_mode == "logit":
+        preds = 1.0 / (1.0 + np.exp(-preds))
+
+    return preds
 
 def main() -> None:
     _ensure_imports_ready()
@@ -2401,7 +2437,7 @@
                 logger.warning("Skipping %s (artifacts not found).", p_name)
                 continue
 
-            preds = _predict_for_problem(features, p_name, artifacts)
+            preds = _predict_for_problem(features, problem, artifacts)
             
             # Apply guards for availability components immediately
             if p_name == "availability_active":
diff --git a/pipeline/train.py b/pipeline/train.py
index 2e2508f5ee50bf4b1877b56465304ecac80dc0bb..30c70ab8292088cc8aad350882ef2c5e8cc7efa6
--- a/pipeline/train.py
+++ b/pipeline/train.py
@@ -2073,7 +2073,7 @@
 
         # --- Save inference artifacts AFTER all models for the problem are trained ---
         # This ensures the state (imputation, categories) is from the pre-tuning/pre-holdout phase.
-        save_inference_artifacts(self, problem_name)
+        save_inference_artifacts(self, problem_name, problem_copy)
 
     def _unwrap_base_model(self, model):
         """Return the true fitted estimator, no matter how it's wrapped."""
@@ -2334,7 +2334,7 @@
                     logger.warning("Failed to initialise team total scaling for %s: %s", problem_name, exc)
             if not use_cached_for_problem:
                 self._fit_feature_artifacts(df_train, problem_copy)
-                save_inference_artifacts(self, problem_name)
+                save_inference_artifacts(self, problem_name, problem_copy)
 
             # Log final feature list used
             logger.info(f"--- Using {len(self.feature_columns)} features for {problem_name} ---")
@@ -2697,4 +2697,4 @@
             train(config_path=args.config, ordinal_only=args.ordinal_only, ordinal_ev=ordinal_ev_flag, **overrides)
     except Exception as e:
         logger.critical(f"The pipeline has failed with a critical error: {e}", exc_info=True)
-        sys.exit(1)
\ No newline at end of file
+        sys.exit(1)
diff --git a/tests/test_predict_probabilities.py b/tests/test_predict_probabilities.py
new file mode 100644
index 0000000000000000000000000000000000000000..bd68c2fa4ae83bf2ab6533daea100378f36d07f3
--- /dev/null
+++ b/tests/test_predict_probabilities.py
@@ -0,0 +1,32 @@
+from pathlib import Path
+
+import numpy as np
+import pandas as pd
+
+import pipeline.predict as predict
+
+
+def test_predict_for_problem_uses_predict_proba(monkeypatch):
+    calls = {"proba": 0, "predict": 0}
+
+    class DummyModel:
+        def predict_proba(self, X):
+            calls["proba"] += 1
+            return np.column_stack([np.zeros(len(X)), np.full(len(X), 0.7)])
+
+        def predict(self, X):
+            calls["predict"] += 1
+            return np.full(len(X), 0.2)
+
+    monkeypatch.setattr(predict.joblib, "load", lambda path: DummyModel())
+    monkeypatch.setattr(predict, "_latest_model_path", lambda name: Path("dummy"))
+
+    artifacts = {"feature_columns": ["a"], "task_type": "classification"}
+    df = pd.DataFrame({"a": [0, 1]})
+
+    preds = predict._predict_for_problem(df, {"name": "any", "task_type": "classification"}, artifacts)
+
+    assert calls["proba"] == 1
+    assert calls["predict"] == 0
+    assert np.allclose(preds, 0.7)
+    assert preds.dtype.kind == "f"
diff --git a/tests/test_training_config_features.py b/tests/test_training_config_features.py
index c8dc5f3391185bd24a48956183ded4d5174f984d..55365dd1217c1453a4f114216d285d83ed880320
--- a/tests/test_training_config_features.py
+++ b/tests/test_training_config_features.py
@@ -14,6 +14,19 @@
         return yaml.safe_load(fh)
 
 
+def test_problem_names_unique():
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    names = [p.get("name") for p in problems]
+    seen = {}
+    duplicates = set()
+    for name in names:
+        if name in seen:
+            duplicates.add(name)
+        seen[name] = True
+    assert not duplicates, f"Duplicate problem names in config: {sorted(duplicates)}"
+
+
 def test_training_config_feature_guards():
     """Ensure columns_to_discard and other_features_to_include don't overlap."""
     training_cfg = _load_training_config()
@@ -113,6 +126,20 @@
     )
 
 
+def test_ps_prefixes_use_hist_namespace():
+    """Prevent accidental inclusion of same-game ps_* columns as features."""
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    offenders = {}
+    for problem in problems:
+        name = problem.get("name", "<unknown>")
+        prefixes = problem.get("feature_prefixes_to_include") or []
+        bad = [p for p in prefixes if p.startswith("ps_") and not p.startswith("ps_hist_")]
+        if bad:
+            offenders[name] = bad
+    assert not offenders, f"Same-game pre-snap prefixes should be removed; found {offenders}"
+
+
 def test_asof_snapshots_not_after_cutoff():
     """Validate that stored snapshot timestamps never exceed the decision cutoff."""
     asof_path = Path(__file__).resolve().parents[1] / "data" / "processed" / "asof_metadata.parquet"
@@ -150,4 +177,3 @@
         "As-of snapshot coverage dropped below expected thresholds: "
         f"{coverage_failures}"
     )
-
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..eb5471f38ae1512ba5cabf81e6baf81aab0e986b
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -44,18 +44,31 @@
             formatted[k] = v
     return formatted
 
-def save_inference_artifacts(trainer, problem_name: str) -> None:
+def save_inference_artifacts(trainer, problem_name: str, problem_config: dict | None = None) -> None:
     # Versioned artifact copy
     v_dir = _vdir(trainer, problem_name, None, "artifacts") / "inference"
     v_dir.mkdir(parents=True, exist_ok=True)
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync


thinking
**Reviewing and updating pipeline feature steps**
Plan update
Implemented ps_game aliases + ps_hist historical features, rewired configs/prediction renames, classification prediction uses task metadata + predict_proba, and deduped TD config with new hygiene tests.
  ✓ Add ps_game aliases for realized pre-snap stats, create ps_hist rolling aliases, and switch training/prediction to consume ps_hist while excluding ps_game/same-game columns.
  ✓ Standardize classification outputs: persist task metadata in artifacts and always use predict_proba for classification problems in inference.
  ✓ Clean TD config duplication and add config/tests for uniqueness/leakage guards (e.g., no duplicate problem names, ps_game not in features).
file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..dc5fa3ecfb113878ba721fd47fdf8337d4c2abd2
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -398,27 +454,6 @@
       - 'travel_rest_days'
       - 'travel_rest_days_l3'
       - 'rest_days_since_last_game'
-      - 'team_red_zone_'
-      - 'team_goal_to_go_'
-      - 'player_red_zone_'
-      - 'player_goal_to_go_'
-      - 'weather_bad_passing_flag'
-    columns_to_discard: *columns_to_discard
-    feature_prefixes_to_include:
-      - 'pred_'
-      - 'expected_'
-      - 'opp_def_'
-      - 'red_zone_'
-      - 'goal_to_go_'
-      - 'off_ctx_'
-      - 'qb_profile_'
-      - 'weather_'
-    other_features_to_include:
-      - 'week'
-      - 'season'
-      - 'position'
-      - 'total_line'
-      - 'team_implied_total'
       - 'team_red_zone_'
       - 'team_goal_to_go_'
       - 'player_red_zone_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..949edb71af9513cfd859e5f2a1316499906b045c
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -215,6 +215,35 @@
     "ps_targets_wide_count_l3",
     "ps_targets_inline_count_l3",
     "ps_targets_backfield_count_l3",
+    # Historical namespace (preferred)
+    "ps_hist_route_participation_pct_prev",
+    "ps_hist_route_participation_pct_l3",
+    "ps_hist_route_participation_plays_prev",
+    "ps_hist_route_participation_plays_l3",
+    "ps_hist_targets_total_prev",
+    "ps_hist_targets_total_l3",
+    "ps_hist_targets_slot_count_prev",
+    "ps_hist_targets_slot_count_l3",
+    "ps_hist_targets_wide_count_prev",
+    "ps_hist_targets_wide_count_l3",
+    "ps_hist_targets_inline_count_prev",
+    "ps_hist_targets_inline_count_l3",
+    "ps_hist_targets_backfield_count_prev",
+    "ps_hist_targets_backfield_count_l3",
+    "ps_hist_targets_slot_share_prev",
+    "ps_hist_targets_slot_share_l3",
+    "ps_hist_targets_wide_share_prev",
+    "ps_hist_targets_wide_share_l3",
+    "ps_hist_targets_inline_share_prev",
+    "ps_hist_targets_inline_share_l3",
+    "ps_hist_targets_backfield_share_prev",
+    "ps_hist_targets_backfield_share_l3",
+    "ps_hist_total_touches_prev",
+    "ps_hist_total_touches_l3",
+    "ps_hist_scripted_touches_prev",
+    "ps_hist_scripted_touches_l3",
+    "ps_hist_scripted_touch_share_prev",
+    "ps_hist_scripted_touch_share_l3",
 ]
 
 PS_L3_FALLBACK_MAP = {
@@ -224,6 +253,20 @@
     "ps_targets_wide_count_l3": "ps_targets_wide_count",
     "ps_targets_inline_count_l3": "ps_targets_inline_count",
     "ps_targets_backfield_count_l3": "ps_targets_backfield_count",
+    "ps_hist_route_participation_plays_l3": "ps_hist_route_participation_plays_prev",
+    "ps_hist_targets_total_l3": "ps_hist_targets_total_prev",
+    "ps_hist_targets_slot_count_l3": "ps_hist_targets_slot_count_prev",
+    "ps_hist_targets_wide_count_l3": "ps_hist_targets_wide_count_prev",
+    "ps_hist_targets_inline_count_l3": "ps_hist_targets_inline_count_prev",
+    "ps_hist_targets_backfield_count_l3": "ps_hist_targets_backfield_count_prev",
+    "ps_hist_total_touches_l3": "ps_hist_total_touches_prev",
+    "ps_hist_scripted_touches_l3": "ps_hist_scripted_touches_prev",
+    "ps_hist_route_participation_pct_l3": "ps_hist_route_participation_pct_prev",
+    "ps_hist_scripted_touch_share_l3": "ps_hist_scripted_touch_share_prev",
+    "ps_hist_targets_slot_share_l3": "ps_hist_targets_slot_share_prev",
+    "ps_hist_targets_wide_share_l3": "ps_hist_targets_wide_share_prev",
+    "ps_hist_targets_inline_share_l3": "ps_hist_targets_inline_share_prev",
+    "ps_hist_targets_backfield_share_l3": "ps_hist_targets_backfield_share_prev",
 }
 
 OUTPUT_COLUMN_PREFIXES = (
@@ -1314,29 +1357,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1369,28 +1418,6 @@
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
 
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
-
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
     if "decision_cutoff_ts" in enriched.columns:
@@ -2331,27 +2358,36 @@
              
     return adj
 
-def _predict_for_problem(features: pd.DataFrame, problem_name: str, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+def _predict_for_problem(features: pd.DataFrame, problem_config: dict, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+    """Load the trained model and return probability or point forecasts based on task metadata."""
+    problem_name = problem_config.get("name", "<unknown>")
+    task_type = str(
+        problem_config.get("task_type")
+        or artifacts.get("task_type")
+        or ""
+    ).lower()
+    output_mode = artifacts.get("output_mode") or problem_config.get("output_mode")
+
     X, _ = _prepare_feature_matrix(features, artifacts)
-    
     model = joblib.load(_latest_model_path(problem_name))
-    
-    # Assuming XGBoost or similar with predict_proba for classification and predict for regression
-    # But for simplicity and compatibility with regression, check model type or problem definition?
-    # Actually, regression models in sklearn/xgb return values directly on predict().
-    # Classification models return class labels on predict(), and probas on predict_proba().
-    
-    try:
-        # Heuristic: Try predict_proba first if it looks like a classifier (anytime_td)
-        # But we need to know task type.
-        if "anytime_td" in problem_name:
-             proba = model.predict_proba(X)[:, 1]
+
+    is_classification = task_type in {"classification", "binary", "multiclass"}
+    if is_classification:
+        if hasattr(model, "predict_proba"):
+            preds = model.predict_proba(X)
+            if preds.ndim > 1 and preds.shape[1] > 1:
+                preds = preds[:, 1]
         else:
-             proba = model.predict(X)
-    except AttributeError:
-        proba = model.predict(X)
-        
-    return proba
+            preds = model.predict(X)
+        preds = np.asarray(preds, dtype=float)
+        preds = np.clip(preds, 0.0, 1.0)
+    else:
+        preds = np.asarray(model.predict(X), dtype=float)
+
+    if output_mode and output_mode == "logit":
+        preds = 1.0 / (1.0 + np.exp(-preds))
+
+    return preds
 
 def main() -> None:
     _ensure_imports_ready()
@@ -2401,7 +2437,7 @@
                 logger.warning("Skipping %s (artifacts not found).", p_name)
                 continue
 
-            preds = _predict_for_problem(features, p_name, artifacts)
+            preds = _predict_for_problem(features, problem, artifacts)
             
             # Apply guards for availability components immediately
             if p_name == "availability_active":
diff --git a/pipeline/train.py b/pipeline/train.py
index 2e2508f5ee50bf4b1877b56465304ecac80dc0bb..30c70ab8292088cc8aad350882ef2c5e8cc7efa6
--- a/pipeline/train.py
+++ b/pipeline/train.py
@@ -2073,7 +2073,7 @@
 
         # --- Save inference artifacts AFTER all models for the problem are trained ---
         # This ensures the state (imputation, categories) is from the pre-tuning/pre-holdout phase.
-        save_inference_artifacts(self, problem_name)
+        save_inference_artifacts(self, problem_name, problem_copy)
 
     def _unwrap_base_model(self, model):
         """Return the true fitted estimator, no matter how it's wrapped."""
@@ -2334,7 +2334,7 @@
                     logger.warning("Failed to initialise team total scaling for %s: %s", problem_name, exc)
             if not use_cached_for_problem:
                 self._fit_feature_artifacts(df_train, problem_copy)
-                save_inference_artifacts(self, problem_name)
+                save_inference_artifacts(self, problem_name, problem_copy)
 
             # Log final feature list used
             logger.info(f"--- Using {len(self.feature_columns)} features for {problem_name} ---")
@@ -2697,4 +2697,4 @@
             train(config_path=args.config, ordinal_only=args.ordinal_only, ordinal_ev=ordinal_ev_flag, **overrides)
     except Exception as e:
         logger.critical(f"The pipeline has failed with a critical error: {e}", exc_info=True)
-        sys.exit(1)
\ No newline at end of file
+        sys.exit(1)
diff --git a/tests/test_predict_probabilities.py b/tests/test_predict_probabilities.py
new file mode 100644
index 0000000000000000000000000000000000000000..bd68c2fa4ae83bf2ab6533daea100378f36d07f3
--- /dev/null
+++ b/tests/test_predict_probabilities.py
@@ -0,0 +1,32 @@
+from pathlib import Path
+
+import numpy as np
+import pandas as pd
+
+import pipeline.predict as predict
+
+
+def test_predict_for_problem_uses_predict_proba(monkeypatch):
+    calls = {"proba": 0, "predict": 0}
+
+    class DummyModel:
+        def predict_proba(self, X):
+            calls["proba"] += 1
+            return np.column_stack([np.zeros(len(X)), np.full(len(X), 0.7)])
+
+        def predict(self, X):
+            calls["predict"] += 1
+            return np.full(len(X), 0.2)
+
+    monkeypatch.setattr(predict.joblib, "load", lambda path: DummyModel())
+    monkeypatch.setattr(predict, "_latest_model_path", lambda name: Path("dummy"))
+
+    artifacts = {"feature_columns": ["a"], "task_type": "classification"}
+    df = pd.DataFrame({"a": [0, 1]})
+
+    preds = predict._predict_for_problem(df, {"name": "any", "task_type": "classification"}, artifacts)
+
+    assert calls["proba"] == 1
+    assert calls["predict"] == 0
+    assert np.allclose(preds, 0.7)
+    assert preds.dtype.kind == "f"
diff --git a/tests/test_training_config_features.py b/tests/test_training_config_features.py
index c8dc5f3391185bd24a48956183ded4d5174f984d..55365dd1217c1453a4f114216d285d83ed880320
--- a/tests/test_training_config_features.py
+++ b/tests/test_training_config_features.py
@@ -14,6 +14,19 @@
         return yaml.safe_load(fh)
 
 
+def test_problem_names_unique():
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    names = [p.get("name") for p in problems]
+    seen = {}
+    duplicates = set()
+    for name in names:
+        if name in seen:
+            duplicates.add(name)
+        seen[name] = True
+    assert not duplicates, f"Duplicate problem names in config: {sorted(duplicates)}"
+
+
 def test_training_config_feature_guards():
     """Ensure columns_to_discard and other_features_to_include don't overlap."""
     training_cfg = _load_training_config()
@@ -113,6 +126,20 @@
     )
 
 
+def test_ps_prefixes_use_hist_namespace():
+    """Prevent accidental inclusion of same-game ps_* columns as features."""
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    offenders = {}
+    for problem in problems:
+        name = problem.get("name", "<unknown>")
+        prefixes = problem.get("feature_prefixes_to_include") or []
+        bad = [p for p in prefixes if p.startswith("ps_") and not p.startswith("ps_hist_")]
+        if bad:
+            offenders[name] = bad
+    assert not offenders, f"Same-game pre-snap prefixes should be removed; found {offenders}"
+
+
 def test_asof_snapshots_not_after_cutoff():
     """Validate that stored snapshot timestamps never exceed the decision cutoff."""
     asof_path = Path(__file__).resolve().parents[1] / "data" / "processed" / "asof_metadata.parquet"
@@ -150,4 +177,3 @@
         "As-of snapshot coverage dropped below expected thresholds: "
         f"{coverage_failures}"
     )
-
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..eb5471f38ae1512ba5cabf81e6baf81aab0e986b
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -44,18 +44,31 @@
             formatted[k] = v
     return formatted
 
-def save_inference_artifacts(trainer, problem_name: str) -> None:
+def save_inference_artifacts(trainer, problem_name: str, problem_config: dict | None = None) -> None:
     # Versioned artifact copy
     v_dir = _vdir(trainer, problem_name, None, "artifacts") / "inference"
     v_dir.mkdir(parents=True, exist_ok=True)
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync


thinking
**Summarizing final changes and limitations**

I’m wrapping up with a progress summary since the plan is large and only partially done—main Tier 1 steps addressed but deeper Tier 2 tasks remain. I’m highlighting key file changes like new ps_hist features, updates to training configs, and added tests, while noting tests weren’t run because pytest is missing and I couldn’t commit changes due to git permission issues. I’ll suggest retraining models and running tests once these blockers clear.

thinking
**Preparing final message format**
codex
- Introduced explicit same-game vs historical namespaces: pre-snap stats now emit `ps_game_*` aliases and `ps_hist_*` historical counterparts, rolling stat surface includes pre-snap metrics, prediction renames/fallbacks honor the new hist names, and training config consumes only `ps_hist_` while marking `ps_game_/ps_*` as leak-prone (`utils/feature/player_game_level.py`, `utils/feature/stats.py`, `pipeline/predict.py`, `config/training.yaml`, `utils/general/constants.py`, `tests/test_training_config_features.py`).
- Classification inference is metadata-driven: inference artifacts now carry `task_type/output_mode`, `_predict_for_problem` always uses `predict_proba` for classifiers, and calls were updated accordingly (`utils/train/persist.py`, `pipeline/train.py`, `pipeline/predict.py`); added a unit test to lock in the proba behavior (`tests/test_predict_probabilities.py`).
- Cleaned TD config duplication and added config hygiene (unique problem names, ps_hist namespace guard) plus deduped the double `efficiency_tds` block (`config/training.yaml`, `tests/test_training_config_features.py`).

Tests: `python3 -m pytest tests/test_training_config_features.py tests/test_predict_probabilities.py` (pytest not installed in the environment).

Notes: Unable to stage/commit because the sandbox blocks writes inside `.git` (index.lock/permission errors remain). Models will need retraining so artifacts include the new `ps_hist_*` feature names and task metadata.

PROGRESS: Tier-1 scaffolding done (ps_hist namespace, classifier probabilities, TD config cleanup); remaining epics (T2/T3 feature audits, tracking coverage, scripted heuristics, docs) still outstanding. Next steps: install pytest, rerun the targeted tests, retrain pipelines to regenerate artifacts with the updated feature set, and extend audits/tests for leakage across the remaining epics.
file update:
diff --git a/config/training.yaml b/config/training.yaml
index 3901b45e1931b23d3fd1ed147e14a94f2ecb0207..dc5fa3ecfb113878ba721fd47fdf8337d4c2abd2
--- a/config/training.yaml
+++ b/config/training.yaml
@@ -48,6 +48,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
 
 # Extended version adds team_offensive_plays_actual (for availability model only)
 _columns_to_discard_extended: &columns_to_discard_extended
@@ -77,6 +108,37 @@
   - defense_pct
   - st_snaps
   - st_pct
+  # Realized same-game pre-snap usage (must remain labels/diagnostics only)
+  - ps_route_participation_plays
+  - ps_route_participation_pct
+  - ps_team_dropbacks
+  - ps_targets_total
+  - ps_targets_slot_count
+  - ps_targets_wide_count
+  - ps_targets_inline_count
+  - ps_targets_backfield_count
+  - ps_targets_slot_share
+  - ps_targets_wide_share
+  - ps_targets_inline_share
+  - ps_targets_backfield_share
+  - ps_total_touches
+  - ps_scripted_touches
+  - ps_scripted_touch_share
+  - ps_game_route_participation_plays
+  - ps_game_route_participation_pct
+  - ps_game_team_dropbacks
+  - ps_game_targets_total
+  - ps_game_targets_slot_count
+  - ps_game_targets_wide_count
+  - ps_game_targets_inline_count
+  - ps_game_targets_backfield_count
+  - ps_game_targets_slot_share
+  - ps_game_targets_wide_share
+  - ps_game_targets_inline_share
+  - ps_game_targets_backfield_share
+  - ps_game_total_touches
+  - ps_game_scripted_touches
+  - ps_game_scripted_touch_share
   # Extended columns (availability model specific)
   - team_offensive_plays_actual
 
@@ -175,13 +237,12 @@
   # 1C. PRE-SNAP ROUTE PARTICIPATION MODEL
   # ============================================================================
   - name: 'pre_snap_routes'
-    target_col: 'ps_route_participation_pct'
+    target_col: 'ps_game_route_participation_pct'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -200,15 +261,12 @@
   # 1D. PRE-SNAP SCRIPTED TOUCHES MODEL
   # ============================================================================
   - name: 'pre_snap_scripted_touches'
-    target_col: 'ps_scripted_touches'
+    target_col: 'ps_game_scripted_touches'
     task_type: 'regression'
     input_predictions: ['availability_active', 'availability_snapshare', 'team_pace', 'pre_snap_routes']
     feature_prefixes_to_include:
       - 'pred_'
-      - 'ps_scripted_'
-      - 'ps_route_participation_'
-      - 'ps_total_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'team_pace_'
       - 'opp_pace_'
       - 'matchup_pace_'
@@ -232,8 +290,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -267,7 +324,7 @@
     feature_prefixes_to_include:
       - 'pred_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'team_pace_'
       - 'opp_pace_'
@@ -307,8 +364,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_target_share_'
-      - 'ps_route_participation_'
-      - 'ps_targets_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -345,7 +401,7 @@
       - 'pred_'
       - 'expected_'
       - 'hist_carry_share_'
-      - 'ps_targets_backfield_'
+      - 'ps_hist_'
       - 'travel_'
       - 'opp_def_'
       - 'team_ctx_'
@@ -398,27 +454,6 @@
       - 'travel_rest_days'
       - 'travel_rest_days_l3'
       - 'rest_days_since_last_game'
-      - 'team_red_zone_'
-      - 'team_goal_to_go_'
-      - 'player_red_zone_'
-      - 'player_goal_to_go_'
-      - 'weather_bad_passing_flag'
-    columns_to_discard: *columns_to_discard
-    feature_prefixes_to_include:
-      - 'pred_'
-      - 'expected_'
-      - 'opp_def_'
-      - 'red_zone_'
-      - 'goal_to_go_'
-      - 'off_ctx_'
-      - 'qb_profile_'
-      - 'weather_'
-    other_features_to_include:
-      - 'week'
-      - 'season'
-      - 'position'
-      - 'total_line'
-      - 'team_implied_total'
       - 'team_red_zone_'
       - 'team_goal_to_go_'
       - 'player_red_zone_'
diff --git a/pipeline/predict.py b/pipeline/predict.py
index 085b3827db1af50daff9d65491694934bcfc006a..949edb71af9513cfd859e5f2a1316499906b045c
--- a/pipeline/predict.py
+++ b/pipeline/predict.py
@@ -215,6 +215,35 @@
     "ps_targets_wide_count_l3",
     "ps_targets_inline_count_l3",
     "ps_targets_backfield_count_l3",
+    # Historical namespace (preferred)
+    "ps_hist_route_participation_pct_prev",
+    "ps_hist_route_participation_pct_l3",
+    "ps_hist_route_participation_plays_prev",
+    "ps_hist_route_participation_plays_l3",
+    "ps_hist_targets_total_prev",
+    "ps_hist_targets_total_l3",
+    "ps_hist_targets_slot_count_prev",
+    "ps_hist_targets_slot_count_l3",
+    "ps_hist_targets_wide_count_prev",
+    "ps_hist_targets_wide_count_l3",
+    "ps_hist_targets_inline_count_prev",
+    "ps_hist_targets_inline_count_l3",
+    "ps_hist_targets_backfield_count_prev",
+    "ps_hist_targets_backfield_count_l3",
+    "ps_hist_targets_slot_share_prev",
+    "ps_hist_targets_slot_share_l3",
+    "ps_hist_targets_wide_share_prev",
+    "ps_hist_targets_wide_share_l3",
+    "ps_hist_targets_inline_share_prev",
+    "ps_hist_targets_inline_share_l3",
+    "ps_hist_targets_backfield_share_prev",
+    "ps_hist_targets_backfield_share_l3",
+    "ps_hist_total_touches_prev",
+    "ps_hist_total_touches_l3",
+    "ps_hist_scripted_touches_prev",
+    "ps_hist_scripted_touches_l3",
+    "ps_hist_scripted_touch_share_prev",
+    "ps_hist_scripted_touch_share_l3",
 ]
 
 PS_L3_FALLBACK_MAP = {
@@ -224,6 +253,20 @@
     "ps_targets_wide_count_l3": "ps_targets_wide_count",
     "ps_targets_inline_count_l3": "ps_targets_inline_count",
     "ps_targets_backfield_count_l3": "ps_targets_backfield_count",
+    "ps_hist_route_participation_plays_l3": "ps_hist_route_participation_plays_prev",
+    "ps_hist_targets_total_l3": "ps_hist_targets_total_prev",
+    "ps_hist_targets_slot_count_l3": "ps_hist_targets_slot_count_prev",
+    "ps_hist_targets_wide_count_l3": "ps_hist_targets_wide_count_prev",
+    "ps_hist_targets_inline_count_l3": "ps_hist_targets_inline_count_prev",
+    "ps_hist_targets_backfield_count_l3": "ps_hist_targets_backfield_count_prev",
+    "ps_hist_total_touches_l3": "ps_hist_total_touches_prev",
+    "ps_hist_scripted_touches_l3": "ps_hist_scripted_touches_prev",
+    "ps_hist_route_participation_pct_l3": "ps_hist_route_participation_pct_prev",
+    "ps_hist_scripted_touch_share_l3": "ps_hist_scripted_touch_share_prev",
+    "ps_hist_targets_slot_share_l3": "ps_hist_targets_slot_share_prev",
+    "ps_hist_targets_wide_share_l3": "ps_hist_targets_wide_share_prev",
+    "ps_hist_targets_inline_share_l3": "ps_hist_targets_inline_share_prev",
+    "ps_hist_targets_backfield_share_l3": "ps_hist_targets_backfield_share_prev",
 }
 
 OUTPUT_COLUMN_PREFIXES = (
@@ -1314,29 +1357,35 @@
         "3g_st_pct_per_game": "snap_st_pct_l3",
         "1g_st_snaps_per_game": "snap_st_snaps_prev",
 
-        # Pre-snap participation/target splits
-        "1g_ps_route_participation_pct_per_game": "ps_route_participation_pct",
-        "3g_ps_route_participation_pct_per_game": "ps_route_participation_pct_l3",
-        "1g_ps_route_participation_plays_per_game": "ps_route_participation_plays",
-        "3g_ps_route_participation_plays_per_game": "ps_route_participation_plays_l3",
-        "1g_ps_targets_total_per_game": "ps_targets_total",
-        "3g_ps_targets_total_per_game": "ps_targets_total_l3",
-        "1g_ps_targets_slot_count_per_game": "ps_targets_slot_count",
-        "3g_ps_targets_slot_count_per_game": "ps_targets_slot_count_l3",
-        "1g_ps_targets_wide_count_per_game": "ps_targets_wide_count",
-        "3g_ps_targets_wide_count_per_game": "ps_targets_wide_count_l3",
-        "1g_ps_targets_inline_count_per_game": "ps_targets_inline_count",
-        "3g_ps_targets_inline_count_per_game": "ps_targets_inline_count_l3",
-        "1g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count",
-        "3g_ps_targets_backfield_count_per_game": "ps_targets_backfield_count_l3",
-        "1g_ps_targets_slot_share_per_game": "ps_targets_slot_share",
-        "3g_ps_targets_slot_share_per_game": "ps_targets_slot_share_l3",
-        "1g_ps_targets_wide_share_per_game": "ps_targets_wide_share",
-        "3g_ps_targets_wide_share_per_game": "ps_targets_wide_share_l3",
-        "1g_ps_targets_inline_share_per_game": "ps_targets_inline_share",
-        "3g_ps_targets_inline_share_per_game": "ps_targets_inline_share_l3",
-        "1g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share",
-        "3g_ps_targets_backfield_share_per_game": "ps_targets_backfield_share_l3",
+        # Pre-snap participation/target splits (historical projections)
+        "1g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_prev",
+        "3g_ps_route_participation_pct_per_game": "ps_hist_route_participation_pct_l3",
+        "1g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_prev",
+        "3g_ps_route_participation_plays_per_game": "ps_hist_route_participation_plays_l3",
+        "1g_ps_targets_total_per_game": "ps_hist_targets_total_prev",
+        "3g_ps_targets_total_per_game": "ps_hist_targets_total_l3",
+        "1g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_prev",
+        "3g_ps_targets_slot_count_per_game": "ps_hist_targets_slot_count_l3",
+        "1g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_prev",
+        "3g_ps_targets_wide_count_per_game": "ps_hist_targets_wide_count_l3",
+        "1g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_prev",
+        "3g_ps_targets_inline_count_per_game": "ps_hist_targets_inline_count_l3",
+        "1g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_prev",
+        "3g_ps_targets_backfield_count_per_game": "ps_hist_targets_backfield_count_l3",
+        "1g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_prev",
+        "3g_ps_targets_slot_share_per_game": "ps_hist_targets_slot_share_l3",
+        "1g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_prev",
+        "3g_ps_targets_wide_share_per_game": "ps_hist_targets_wide_share_l3",
+        "1g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_prev",
+        "3g_ps_targets_inline_share_per_game": "ps_hist_targets_inline_share_l3",
+        "1g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_prev",
+        "3g_ps_targets_backfield_share_per_game": "ps_hist_targets_backfield_share_l3",
+        "1g_ps_total_touches_per_game": "ps_hist_total_touches_prev",
+        "3g_ps_total_touches_per_game": "ps_hist_total_touches_l3",
+        "1g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_prev",
+        "3g_ps_scripted_touches_per_game": "ps_hist_scripted_touches_l3",
+        "1g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_prev",
+        "3g_ps_scripted_touch_share_per_game": "ps_hist_scripted_touch_share_l3",
     }
     existing = set(enriched.columns)
     valid_renames = {k: v for k, v in rename_map.items() if k in existing}
@@ -1369,28 +1418,6 @@
     if alias_exprs:
         enriched = enriched.with_columns(alias_exprs)
 
-    available_cols = set(enriched.columns)
-    ps_base_cols = [
-        "ps_route_participation_pct",
-        "ps_route_participation_plays",
-        "ps_targets_total",
-        "ps_targets_slot_count",
-        "ps_targets_wide_count",
-        "ps_targets_inline_count",
-        "ps_targets_backfield_count",
-        "ps_targets_slot_share",
-        "ps_targets_wide_share",
-        "ps_targets_inline_share",
-        "ps_targets_backfield_share",
-    ]
-    ps_prev_exprs = [
-        pl.col(col).alias(f"{col}_prev")
-        for col in ps_base_cols
-        if col in enriched.columns and f"{col}_prev" not in enriched.columns
-    ]
-    if ps_prev_exprs:
-        enriched = enriched.with_columns(ps_prev_exprs)
-
     cutoff_hours = float(get_decision_cutoff_hours())
     fallback_hours = float(get_fallback_cutoff_hours())
     if "decision_cutoff_ts" in enriched.columns:
@@ -2331,27 +2358,36 @@
              
     return adj
 
-def _predict_for_problem(features: pd.DataFrame, problem_name: str, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+def _predict_for_problem(features: pd.DataFrame, problem_config: dict, artifacts: dict, threshold: float = 0.5) -> np.ndarray:
+    """Load the trained model and return probability or point forecasts based on task metadata."""
+    problem_name = problem_config.get("name", "<unknown>")
+    task_type = str(
+        problem_config.get("task_type")
+        or artifacts.get("task_type")
+        or ""
+    ).lower()
+    output_mode = artifacts.get("output_mode") or problem_config.get("output_mode")
+
     X, _ = _prepare_feature_matrix(features, artifacts)
-    
     model = joblib.load(_latest_model_path(problem_name))
-    
-    # Assuming XGBoost or similar with predict_proba for classification and predict for regression
-    # But for simplicity and compatibility with regression, check model type or problem definition?
-    # Actually, regression models in sklearn/xgb return values directly on predict().
-    # Classification models return class labels on predict(), and probas on predict_proba().
-    
-    try:
-        # Heuristic: Try predict_proba first if it looks like a classifier (anytime_td)
-        # But we need to know task type.
-        if "anytime_td" in problem_name:
-             proba = model.predict_proba(X)[:, 1]
+
+    is_classification = task_type in {"classification", "binary", "multiclass"}
+    if is_classification:
+        if hasattr(model, "predict_proba"):
+            preds = model.predict_proba(X)
+            if preds.ndim > 1 and preds.shape[1] > 1:
+                preds = preds[:, 1]
         else:
-             proba = model.predict(X)
-    except AttributeError:
-        proba = model.predict(X)
-        
-    return proba
+            preds = model.predict(X)
+        preds = np.asarray(preds, dtype=float)
+        preds = np.clip(preds, 0.0, 1.0)
+    else:
+        preds = np.asarray(model.predict(X), dtype=float)
+
+    if output_mode and output_mode == "logit":
+        preds = 1.0 / (1.0 + np.exp(-preds))
+
+    return preds
 
 def main() -> None:
     _ensure_imports_ready()
@@ -2401,7 +2437,7 @@
                 logger.warning("Skipping %s (artifacts not found).", p_name)
                 continue
 
-            preds = _predict_for_problem(features, p_name, artifacts)
+            preds = _predict_for_problem(features, problem, artifacts)
             
             # Apply guards for availability components immediately
             if p_name == "availability_active":
diff --git a/pipeline/train.py b/pipeline/train.py
index 2e2508f5ee50bf4b1877b56465304ecac80dc0bb..30c70ab8292088cc8aad350882ef2c5e8cc7efa6
--- a/pipeline/train.py
+++ b/pipeline/train.py
@@ -2073,7 +2073,7 @@
 
         # --- Save inference artifacts AFTER all models for the problem are trained ---
         # This ensures the state (imputation, categories) is from the pre-tuning/pre-holdout phase.
-        save_inference_artifacts(self, problem_name)
+        save_inference_artifacts(self, problem_name, problem_copy)
 
     def _unwrap_base_model(self, model):
         """Return the true fitted estimator, no matter how it's wrapped."""
@@ -2334,7 +2334,7 @@
                     logger.warning("Failed to initialise team total scaling for %s: %s", problem_name, exc)
             if not use_cached_for_problem:
                 self._fit_feature_artifacts(df_train, problem_copy)
-                save_inference_artifacts(self, problem_name)
+                save_inference_artifacts(self, problem_name, problem_copy)
 
             # Log final feature list used
             logger.info(f"--- Using {len(self.feature_columns)} features for {problem_name} ---")
@@ -2697,4 +2697,4 @@
             train(config_path=args.config, ordinal_only=args.ordinal_only, ordinal_ev=ordinal_ev_flag, **overrides)
     except Exception as e:
         logger.critical(f"The pipeline has failed with a critical error: {e}", exc_info=True)
-        sys.exit(1)
\ No newline at end of file
+        sys.exit(1)
diff --git a/tests/test_predict_probabilities.py b/tests/test_predict_probabilities.py
new file mode 100644
index 0000000000000000000000000000000000000000..bd68c2fa4ae83bf2ab6533daea100378f36d07f3
--- /dev/null
+++ b/tests/test_predict_probabilities.py
@@ -0,0 +1,32 @@
+from pathlib import Path
+
+import numpy as np
+import pandas as pd
+
+import pipeline.predict as predict
+
+
+def test_predict_for_problem_uses_predict_proba(monkeypatch):
+    calls = {"proba": 0, "predict": 0}
+
+    class DummyModel:
+        def predict_proba(self, X):
+            calls["proba"] += 1
+            return np.column_stack([np.zeros(len(X)), np.full(len(X), 0.7)])
+
+        def predict(self, X):
+            calls["predict"] += 1
+            return np.full(len(X), 0.2)
+
+    monkeypatch.setattr(predict.joblib, "load", lambda path: DummyModel())
+    monkeypatch.setattr(predict, "_latest_model_path", lambda name: Path("dummy"))
+
+    artifacts = {"feature_columns": ["a"], "task_type": "classification"}
+    df = pd.DataFrame({"a": [0, 1]})
+
+    preds = predict._predict_for_problem(df, {"name": "any", "task_type": "classification"}, artifacts)
+
+    assert calls["proba"] == 1
+    assert calls["predict"] == 0
+    assert np.allclose(preds, 0.7)
+    assert preds.dtype.kind == "f"
diff --git a/tests/test_training_config_features.py b/tests/test_training_config_features.py
index c8dc5f3391185bd24a48956183ded4d5174f984d..55365dd1217c1453a4f114216d285d83ed880320
--- a/tests/test_training_config_features.py
+++ b/tests/test_training_config_features.py
@@ -14,6 +14,19 @@
         return yaml.safe_load(fh)
 
 
+def test_problem_names_unique():
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    names = [p.get("name") for p in problems]
+    seen = {}
+    duplicates = set()
+    for name in names:
+        if name in seen:
+            duplicates.add(name)
+        seen[name] = True
+    assert not duplicates, f"Duplicate problem names in config: {sorted(duplicates)}"
+
+
 def test_training_config_feature_guards():
     """Ensure columns_to_discard and other_features_to_include don't overlap."""
     training_cfg = _load_training_config()
@@ -113,6 +126,20 @@
     )
 
 
+def test_ps_prefixes_use_hist_namespace():
+    """Prevent accidental inclusion of same-game ps_* columns as features."""
+    training_cfg = _load_training_config()
+    problems = training_cfg.get("problems", [])
+    offenders = {}
+    for problem in problems:
+        name = problem.get("name", "<unknown>")
+        prefixes = problem.get("feature_prefixes_to_include") or []
+        bad = [p for p in prefixes if p.startswith("ps_") and not p.startswith("ps_hist_")]
+        if bad:
+            offenders[name] = bad
+    assert not offenders, f"Same-game pre-snap prefixes should be removed; found {offenders}"
+
+
 def test_asof_snapshots_not_after_cutoff():
     """Validate that stored snapshot timestamps never exceed the decision cutoff."""
     asof_path = Path(__file__).resolve().parents[1] / "data" / "processed" / "asof_metadata.parquet"
@@ -150,4 +177,3 @@
         "As-of snapshot coverage dropped below expected thresholds: "
         f"{coverage_failures}"
     )
-
diff --git a/utils/feature/player_game_level.py b/utils/feature/player_game_level.py
index 9e1815850ea403c2302796b89b480367ae98d346..ff6dd18d098d7644dd664613ebe3cd12f9dbb80c
--- a/utils/feature/player_game_level.py
+++ b/utils/feature/player_game_level.py
@@ -157,12 +157,27 @@
 ]
 PRE_SNAP_ROLLING_TARGETS = [
     "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
     "ps_scripted_touch_share",
+    "ps_scripted_touches",
+    "ps_total_touches",
     "ps_targets_slot_share",
     "ps_targets_wide_share",
     "ps_targets_inline_share",
     "ps_targets_backfield_share",
 ]
+
+
+def _ps_game_alias(name: str) -> str:
+    """Return the ps_game_ alias for a ps_* column."""
+    if not name.startswith("ps_"):
+        return name
+    return f"ps_game_{name[len('ps_'):]}"
 def _safe_split(col: pl.Expr) -> pl.Expr:
     return (
         pl.when(col.is_not_null())
@@ -494,6 +509,16 @@
     merged = merged.with_columns(
         [pl.col(col).fill_null(0).cast(pl.Float32).alias(col) for col in numeric_cols]
     )
+    # Expose realized same-game stats under a clear namespace for downstream label use.
+    game_alias_exprs = []
+    for col in numeric_cols:
+        if not col.startswith("ps_"):
+            continue
+        alias = _ps_game_alias(col)
+        if alias not in merged.columns:
+            game_alias_exprs.append(pl.col(col).alias(alias))
+    if game_alias_exprs:
+        merged = merged.with_columns(game_alias_exprs)
     return merged
 
 
@@ -1580,6 +1605,13 @@
             df_merged = df_merged.with_columns(
                 pl.lit(0).cast(pl.Float32).alias(col)
             )
+    ps_game_aliases: list[pl.Expr] = []
+    for col in PRE_SNAP_BASE_COLUMNS:
+        alias = _ps_game_alias(col)
+        if alias not in df_merged.columns and col in df_merged.columns:
+            ps_game_aliases.append(pl.col(col).alias(alias))
+    if ps_game_aliases:
+        df_merged = df_merged.with_columns(ps_game_aliases)
 
     if PRE_SNAP_ROLLING_TARGETS:
         df_merged = df_merged.sort(["player_id", "season", "week"])
@@ -1604,6 +1636,14 @@
                 for col in PRE_SNAP_ROLLING_TARGETS
             ]
         )
+        hist_aliases: list[pl.Expr] = []
+        for base in PRE_SNAP_ROLLING_TARGETS:
+            for suffix in ("prev", "l3"):
+                name = f"{base}_{suffix}"
+                if name in df_merged.columns:
+                    hist_aliases.append(pl.col(name).alias(f"ps_hist_{name[len('ps_'):]}"))
+        if hist_aliases:
+            df_merged = df_merged.with_columns(hist_aliases)
     
     logger.info("Final player-game rows: %d (after merging multi-role players)", len(df_merged))
     # Enrich with roster metadata (position, depth chart, injury status)
@@ -3316,4 +3356,3 @@
     ]).drop("_total_touchdowns")
     
     return merged
-
diff --git a/utils/feature/stats.py b/utils/feature/stats.py
index a6f324b662101ef922661f22384a66d6e5339a5b..6d40cd9c6f514a9e649095ae32eb87b14e0a6549
--- a/utils/feature/stats.py
+++ b/utils/feature/stats.py
@@ -104,6 +104,21 @@
     "receiving_yards",
     "rushing_yards",
     "passing_yards",
+    # Pre-snap realized stats (for historical projections only)
+    "ps_route_participation_pct",
+    "ps_route_participation_plays",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
 ]
 
 # Columns required for player identification and time-series operations
diff --git a/utils/general/constants.py b/utils/general/constants.py
index babd5d5bc2d268b66b776d9fbba47375c25863fc..8c3adade539683f26ffca412d381349224eeeeb4
--- a/utils/general/constants.py
+++ b/utils/general/constants.py
@@ -141,6 +141,37 @@
     "defense_pct",
     "st_snaps",
     "st_pct",
+    # Pre-snap realized usage (same-game; should only be labels/diagnostics)
+    "ps_route_participation_plays",
+    "ps_route_participation_pct",
+    "ps_team_dropbacks",
+    "ps_targets_total",
+    "ps_targets_slot_count",
+    "ps_targets_wide_count",
+    "ps_targets_inline_count",
+    "ps_targets_backfield_count",
+    "ps_targets_slot_share",
+    "ps_targets_wide_share",
+    "ps_targets_inline_share",
+    "ps_targets_backfield_share",
+    "ps_total_touches",
+    "ps_scripted_touches",
+    "ps_scripted_touch_share",
+    "ps_game_route_participation_plays",
+    "ps_game_route_participation_pct",
+    "ps_game_team_dropbacks",
+    "ps_game_targets_total",
+    "ps_game_targets_slot_count",
+    "ps_game_targets_wide_count",
+    "ps_game_targets_inline_count",
+    "ps_game_targets_backfield_count",
+    "ps_game_targets_slot_share",
+    "ps_game_targets_wide_share",
+    "ps_game_targets_inline_share",
+    "ps_game_targets_backfield_share",
+    "ps_game_total_touches",
+    "ps_game_scripted_touches",
+    "ps_game_scripted_touch_share",
 )
 
 
@@ -214,4 +245,3 @@
     "IDENTIFIER_COLUMNS",
     "NFL_TARGET_COLUMNS",
 ]
-
diff --git a/utils/train/persist.py b/utils/train/persist.py
index 2f386fd86cc2adcd3229f0a0816b027fb3ac95d1..eb5471f38ae1512ba5cabf81e6baf81aab0e986b
--- a/utils/train/persist.py
+++ b/utils/train/persist.py
@@ -44,18 +44,31 @@
             formatted[k] = v
     return formatted
 
-def save_inference_artifacts(trainer, problem_name: str) -> None:
+def save_inference_artifacts(trainer, problem_name: str, problem_config: dict | None = None) -> None:
     # Versioned artifact copy
     v_dir = _vdir(trainer, problem_name, None, "artifacts") / "inference"
     v_dir.mkdir(parents=True, exist_ok=True)
     v_path = v_dir / f"inference_artifacts_{problem_name}.joblib"
     # Legacy artifact path (loader in train.py reads this)
     legacy = trainer.paths.model_dir / f"inference_artifacts_{problem_name}.joblib"
+    task_type = None
+    output_mode = None
+    if problem_config:
+        task_type = problem_config.get("task_type")
+        output_mode = problem_config.get("output_mode")
+    if output_mode is None and task_type:
+        if str(task_type).lower() in ("classification", "binary", "multiclass"):
+            output_mode = "probability"
+        else:
+            output_mode = "value"
+
     payload = {
         "feature_columns": trainer.feature_columns,
         "imputation_values": trainer.imputation_values.get(problem_name, {}),
         "category_levels": trainer.category_levels.get(problem_name, {}),
         "categorical_features": trainer.categorical_features.get(problem_name, []),
+        "task_type": task_type,
+        "output_mode": output_mode,
     }
     joblib.dump(payload, v_path)
     # keep legacy in sync

tokens used
142,504
- Introduced explicit same-game vs historical namespaces: pre-snap stats now emit `ps_game_*` aliases and `ps_hist_*` historical counterparts, rolling stat surface includes pre-snap metrics, prediction renames/fallbacks honor the new hist names, and training config consumes only `ps_hist_` while marking `ps_game_/ps_*` as leak-prone (`utils/feature/player_game_level.py`, `utils/feature/stats.py`, `pipeline/predict.py`, `config/training.yaml`, `utils/general/constants.py`, `tests/test_training_config_features.py`).
- Classification inference is metadata-driven: inference artifacts now carry `task_type/output_mode`, `_predict_for_problem` always uses `predict_proba` for classifiers, and calls were updated accordingly (`utils/train/persist.py`, `pipeline/train.py`, `pipeline/predict.py`); added a unit test to lock in the proba behavior (`tests/test_predict_probabilities.py`).
- Cleaned TD config duplication and added config hygiene (unique problem names, ps_hist namespace guard) plus deduped the double `efficiency_tds` block (`config/training.yaml`, `tests/test_training_config_features.py`).

Tests: `python3 -m pytest tests/test_training_config_features.py tests/test_predict_probabilities.py` (pytest not installed in the environment).

Notes: Unable to stage/commit because the sandbox blocks writes inside `.git` (index.lock/permission errors remain). Models will need retraining so artifacts include the new `ps_hist_*` feature names and task metadata.

PROGRESS: Tier-1 scaffolding done (ps_hist namespace, classifier probabilities, TD config cleanup); remaining epics (T2/T3 feature audits, tracking coverage, scripted heuristics, docs) still outstanding. Next steps: install pytest, rerun the targeted tests, retrain pipelines to regenerate artifacts with the updated feature set, and extend audits/tests for leakage across the remaining epics.
